<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>/var/www/portal/public/js/jquery-3.2.0.js - Chell PHP Portal</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
    <div class="navbar navbar-fixed-top navbar-inverse">
        <div class="navbar-inner">
            <div class="container">
                <div class="row">
                    <a href="../">
                        <img alt="Chell PHP Portal" src="../../../img/icons/favicons/android-chrome-48x48.png" title="Chell PHP Portal">
                        <h1 class="brand">Chell PHP Portal</h1>
                    </a>
                    <ul class="nav">
                        <li class="divider-vertical"></li>
                        <li>
                            <p class="navbar-text">
                                API Docs for Version: <b>1.0</b>
                            </p>
                        </li>
                    </ul>
                    <form class="navbar-form pull-right">
                        <input style="margin-top: 0;" type="text" class="form-control" placeholder="Search for classes/modules..." data-obj='["classes/Devices", "classes/Gallery", "classes/Index", "classes/Nowplaying", "classes/PHPSysInfo", "classes/Transmission", "classes/Window", "modules/Dashboard", "modules/DashboardBlocks", "modules/General", "modules/Settings"]'>
                    </form>
                </div>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="row">
            <div class="span3">
                <div>
                    <h3>APIs</h3>
                    <div id="sidebar">
                        <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
                            <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
                            <li><a href="#modules" data-toggle="tab">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" placeholder="Type to filter APIs">
                        </div>
                
                        <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
                            <div class="tab-pane active" id="classes">
                                <ul id="api-classes" class="nav nav-list">
                                        <li><a href="../classes/Devices.html">Devices</a></li>
                                        <li><a href="../classes/Gallery.html">Gallery</a></li>
                                        <li><a href="../classes/Index.html">Index</a></li>
                                        <li><a href="../classes/Nowplaying.html">Nowplaying</a></li>
                                        <li><a href="../classes/PHPSysInfo.html">PHPSysInfo</a></li>
                                        <li><a href="../classes/Transmission.html">Transmission</a></li>
                                        <li><a href="../classes/Window.html">Window</a></li>
                                </ul>
                            </div>
                
                            <div class="tab-pane" id="modules">
                                <ul id="api-modules" class="nav nav-list">
                                        <li><a href="../modules/Dashboard.html">Dashboard</a></li>
                                        <li><a href="../modules/DashboardBlocks.html">DashboardBlocks</a></li>
                                        <li><a href="../modules/General.html">General</a></li>
                                        <li><a href="../modules/Settings.html">Settings</a></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="span9">
                    <form id="options-form" class="form-inline pull-right">
                        Show:
                        <label for="api-show-inherited" class="checkbox">
                            <input type="checkbox" id="api-show-inherited" checked>
                            Inherited
                        </label>
                
                        <label for="api-show-protected" class="checkbox">
                            <input type="checkbox" id="api-show-protected">
                            Protected
                        </label>
                
                        <label for="api-show-private" class="checkbox">
                            <input type="checkbox" id="api-show-private">
                            Private
                        </label>
                        <label for="api-show-deprecated" class="checkbox">
                            <input type="checkbox" id="api-show-deprecated">
                            Deprecated
                        </label>
                
                    </form>
                
                <div class="apidocs">
                    <div id="docs-main">
                        <div class="content">
                            <div class="page-header">
                                <h1>/var/www/portal/public/js/jquery-3.2.0.js <small>File</small></h1>
                            </div>
                            
                            <div class="file">
                                <pre class="prettyprint linenums">
                            /*!
                             * jQuery JavaScript Library v3.2.0
                             * https://jquery.com/
                             *
                             * Includes Sizzle.js
                             * https://sizzlejs.com/
                             *
                             * Copyright JS Foundation and other contributors
                             * Released under the MIT license
                             * https://jquery.org/license
                             *
                             * Date: 2017-03-16T21:26Z
                             */
                            ( function( global, factory ) {
                            
                            	&quot;use strict&quot;;
                            
                            	if ( typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot; ) {
                            
                            		// For CommonJS and CommonJS-like environments where a proper &#x60;window&#x60;
                            		// is present, execute the factory and get jQuery.
                            		// For environments that do not have a &#x60;window&#x60; with a &#x60;document&#x60;
                            		// (such as Node.js), expose a factory as module.exports.
                            		// This accentuates the need for the creation of a real &#x60;window&#x60;.
                            		// e.g. var jQuery = require(&quot;jquery&quot;)(window);
                            		// See ticket #14549 for more info.
                            		module.exports = global.document ?
                            			factory( global, true ) :
                            			function( w ) {
                            				if ( !w.document ) {
                            					throw new Error( &quot;jQuery requires a window with a document&quot; );
                            				}
                            				return factory( w );
                            			};
                            	} else {
                            		factory( global );
                            	}
                            
                            // Pass this if window is not defined yet
                            } )( typeof window !== &quot;undefined&quot; ? window : this, function( window, noGlobal ) {
                            
                            // Edge &lt;= 12 - 13+, Firefox &lt;=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
                            // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
                            // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
                            // enough that all such attempts are guarded in a try block.
                            &quot;use strict&quot;;
                            
                            var arr = [];
                            
                            var document = window.document;
                            
                            var getProto = Object.getPrototypeOf;
                            
                            var slice = arr.slice;
                            
                            var concat = arr.concat;
                            
                            var push = arr.push;
                            
                            var indexOf = arr.indexOf;
                            
                            var class2type = {};
                            
                            var toString = class2type.toString;
                            
                            var hasOwn = class2type.hasOwnProperty;
                            
                            var fnToString = hasOwn.toString;
                            
                            var ObjectFunctionString = fnToString.call( Object );
                            
                            var support = {};
                            
                            
                            
                            	function DOMEval( code, doc ) {
                            		doc = doc || document;
                            
                            		var script = doc.createElement( &quot;script&quot; );
                            
                            		script.text = code;
                            		doc.head.appendChild( script ).parentNode.removeChild( script );
                            	}
                            /* global Symbol */
                            // Defining this global in .eslintrc.json would create a danger of using the global
                            // unguarded in another place, it seems safer to define global only for this module
                            
                            
                            
                            var
                            	version = &quot;3.2.0&quot;,
                            
                            	// Define a local copy of jQuery
                            	jQuery = function( selector, context ) {
                            
                            		// The jQuery object is actually just the init constructor &#x27;enhanced&#x27;
                            		// Need init if jQuery is called (just allow error to be thrown if not included)
                            		return new jQuery.fn.init( selector, context );
                            	},
                            
                            	// Support: Android &lt;=4.0 only
                            	// Make sure we trim BOM and NBSP
                            	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
                            
                            	// Matches dashed string for camelizing
                            	rmsPrefix = /^-ms-/,
                            	rdashAlpha = /-([a-z])/g,
                            
                            	// Used by jQuery.camelCase as callback to replace()
                            	fcamelCase = function( all, letter ) {
                            		return letter.toUpperCase();
                            	};
                            
                            jQuery.fn = jQuery.prototype = {
                            
                            	// The current version of jQuery being used
                            	jquery: version,
                            
                            	constructor: jQuery,
                            
                            	// The default length of a jQuery object is 0
                            	length: 0,
                            
                            	toArray: function() {
                            		return slice.call( this );
                            	},
                            
                            	// Get the Nth element in the matched element set OR
                            	// Get the whole matched element set as a clean array
                            	get: function( num ) {
                            
                            		// Return all the elements in a clean array
                            		if ( num == null ) {
                            			return slice.call( this );
                            		}
                            
                            		// Return just the one element from the set
                            		return num &lt; 0 ? this[ num + this.length ] : this[ num ];
                            	},
                            
                            	// Take an array of elements and push it onto the stack
                            	// (returning the new matched element set)
                            	pushStack: function( elems ) {
                            
                            		// Build a new jQuery matched element set
                            		var ret = jQuery.merge( this.constructor(), elems );
                            
                            		// Add the old object onto the stack (as a reference)
                            		ret.prevObject = this;
                            
                            		// Return the newly-formed element set
                            		return ret;
                            	},
                            
                            	// Execute a callback for every element in the matched set.
                            	each: function( callback ) {
                            		return jQuery.each( this, callback );
                            	},
                            
                            	map: function( callback ) {
                            		return this.pushStack( jQuery.map( this, function( elem, i ) {
                            			return callback.call( elem, i, elem );
                            		} ) );
                            	},
                            
                            	slice: function() {
                            		return this.pushStack( slice.apply( this, arguments ) );
                            	},
                            
                            	first: function() {
                            		return this.eq( 0 );
                            	},
                            
                            	last: function() {
                            		return this.eq( -1 );
                            	},
                            
                            	eq: function( i ) {
                            		var len = this.length,
                            			j = +i + ( i &lt; 0 ? len : 0 );
                            		return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[ j ] ] : [] );
                            	},
                            
                            	end: function() {
                            		return this.prevObject || this.constructor();
                            	},
                            
                            	// For internal use only.
                            	// Behaves like an Array&#x27;s method, not like a jQuery method.
                            	push: push,
                            	sort: arr.sort,
                            	splice: arr.splice
                            };
                            
                            jQuery.extend = jQuery.fn.extend = function() {
                            	var options, name, src, copy, copyIsArray, clone,
                            		target = arguments[ 0 ] || {},
                            		i = 1,
                            		length = arguments.length,
                            		deep = false;
                            
                            	// Handle a deep copy situation
                            	if ( typeof target === &quot;boolean&quot; ) {
                            		deep = target;
                            
                            		// Skip the boolean and the target
                            		target = arguments[ i ] || {};
                            		i++;
                            	}
                            
                            	// Handle case when target is a string or something (possible in deep copy)
                            	if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction( target ) ) {
                            		target = {};
                            	}
                            
                            	// Extend jQuery itself if only one argument is passed
                            	if ( i === length ) {
                            		target = this;
                            		i--;
                            	}
                            
                            	for ( ; i &lt; length; i++ ) {
                            
                            		// Only deal with non-null/undefined values
                            		if ( ( options = arguments[ i ] ) != null ) {
                            
                            			// Extend the base object
                            			for ( name in options ) {
                            				src = target[ name ];
                            				copy = options[ name ];
                            
                            				// Prevent never-ending loop
                            				if ( target === copy ) {
                            					continue;
                            				}
                            
                            				// Recurse if we&#x27;re merging plain objects or arrays
                            				if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) ||
                            					( copyIsArray = Array.isArray( copy ) ) ) ) {
                            
                            					if ( copyIsArray ) {
                            						copyIsArray = false;
                            						clone = src &amp;&amp; Array.isArray( src ) ? src : [];
                            
                            					} else {
                            						clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : {};
                            					}
                            
                            					// Never move original objects, clone them
                            					target[ name ] = jQuery.extend( deep, clone, copy );
                            
                            				// Don&#x27;t bring in undefined values
                            				} else if ( copy !== undefined ) {
                            					target[ name ] = copy;
                            				}
                            			}
                            		}
                            	}
                            
                            	// Return the modified object
                            	return target;
                            };
                            
                            jQuery.extend( {
                            
                            	// Unique for each copy of jQuery on the page
                            	expando: &quot;jQuery&quot; + ( version + Math.random() ).replace( /\D/g, &quot;&quot; ),
                            
                            	// Assume jQuery is ready without the ready module
                            	isReady: true,
                            
                            	error: function( msg ) {
                            		throw new Error( msg );
                            	},
                            
                            	noop: function() {},
                            
                            	isFunction: function( obj ) {
                            		return jQuery.type( obj ) === &quot;function&quot;;
                            	},
                            
                            	isWindow: function( obj ) {
                            		return obj != null &amp;&amp; obj === obj.window;
                            	},
                            
                            	isNumeric: function( obj ) {
                            
                            		// As of jQuery 3.0, isNumeric is limited to
                            		// strings and numbers (primitives or objects)
                            		// that can be coerced to finite numbers (gh-2662)
                            		var type = jQuery.type( obj );
                            		return ( type === &quot;number&quot; || type === &quot;string&quot; ) &amp;&amp;
                            
                            			// parseFloat NaNs numeric-cast false positives (&quot;&quot;)
                            			// ...but misinterprets leading-number strings, particularly hex literals (&quot;0x...&quot;)
                            			// subtraction forces infinities to NaN
                            			!isNaN( obj - parseFloat( obj ) );
                            	},
                            
                            	isPlainObject: function( obj ) {
                            		var proto, Ctor;
                            
                            		// Detect obvious negatives
                            		// Use toString instead of jQuery.type to catch host objects
                            		if ( !obj || toString.call( obj ) !== &quot;[object Object]&quot; ) {
                            			return false;
                            		}
                            
                            		proto = getProto( obj );
                            
                            		// Objects with no prototype (e.g., &#x60;Object.create( null )&#x60;) are plain
                            		if ( !proto ) {
                            			return true;
                            		}
                            
                            		// Objects with prototype are plain iff they were constructed by a global Object function
                            		Ctor = hasOwn.call( proto, &quot;constructor&quot; ) &amp;&amp; proto.constructor;
                            		return typeof Ctor === &quot;function&quot; &amp;&amp; fnToString.call( Ctor ) === ObjectFunctionString;
                            	},
                            
                            	isEmptyObject: function( obj ) {
                            
                            		/* eslint-disable no-unused-vars */
                            		// See https://github.com/eslint/eslint/issues/6125
                            		var name;
                            
                            		for ( name in obj ) {
                            			return false;
                            		}
                            		return true;
                            	},
                            
                            	type: function( obj ) {
                            		if ( obj == null ) {
                            			return obj + &quot;&quot;;
                            		}
                            
                            		// Support: Android &lt;=2.3 only (functionish RegExp)
                            		return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?
                            			class2type[ toString.call( obj ) ] || &quot;object&quot; :
                            			typeof obj;
                            	},
                            
                            	// Evaluates a script in a global context
                            	globalEval: function( code ) {
                            		DOMEval( code );
                            	},
                            
                            	// Convert dashed to camelCase; used by the css and data modules
                            	// Support: IE &lt;=9 - 11, Edge 12 - 13
                            	// Microsoft forgot to hump their vendor prefix (#9572)
                            	camelCase: function( string ) {
                            		return string.replace( rmsPrefix, &quot;ms-&quot; ).replace( rdashAlpha, fcamelCase );
                            	},
                            
                            	each: function( obj, callback ) {
                            		var length, i = 0;
                            
                            		if ( isArrayLike( obj ) ) {
                            			length = obj.length;
                            			for ( ; i &lt; length; i++ ) {
                            				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                            					break;
                            				}
                            			}
                            		} else {
                            			for ( i in obj ) {
                            				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                            					break;
                            				}
                            			}
                            		}
                            
                            		return obj;
                            	},
                            
                            	// Support: Android &lt;=4.0 only
                            	trim: function( text ) {
                            		return text == null ?
                            			&quot;&quot; :
                            			( text + &quot;&quot; ).replace( rtrim, &quot;&quot; );
                            	},
                            
                            	// results is for internal usage only
                            	makeArray: function( arr, results ) {
                            		var ret = results || [];
                            
                            		if ( arr != null ) {
                            			if ( isArrayLike( Object( arr ) ) ) {
                            				jQuery.merge( ret,
                            					typeof arr === &quot;string&quot; ?
                            					[ arr ] : arr
                            				);
                            			} else {
                            				push.call( ret, arr );
                            			}
                            		}
                            
                            		return ret;
                            	},
                            
                            	inArray: function( elem, arr, i ) {
                            		return arr == null ? -1 : indexOf.call( arr, elem, i );
                            	},
                            
                            	// Support: Android &lt;=4.0 only, PhantomJS 1 only
                            	// push.apply(_, arraylike) throws on ancient WebKit
                            	merge: function( first, second ) {
                            		var len = +second.length,
                            			j = 0,
                            			i = first.length;
                            
                            		for ( ; j &lt; len; j++ ) {
                            			first[ i++ ] = second[ j ];
                            		}
                            
                            		first.length = i;
                            
                            		return first;
                            	},
                            
                            	grep: function( elems, callback, invert ) {
                            		var callbackInverse,
                            			matches = [],
                            			i = 0,
                            			length = elems.length,
                            			callbackExpect = !invert;
                            
                            		// Go through the array, only saving the items
                            		// that pass the validator function
                            		for ( ; i &lt; length; i++ ) {
                            			callbackInverse = !callback( elems[ i ], i );
                            			if ( callbackInverse !== callbackExpect ) {
                            				matches.push( elems[ i ] );
                            			}
                            		}
                            
                            		return matches;
                            	},
                            
                            	// arg is for internal usage only
                            	map: function( elems, callback, arg ) {
                            		var length, value,
                            			i = 0,
                            			ret = [];
                            
                            		// Go through the array, translating each of the items to their new values
                            		if ( isArrayLike( elems ) ) {
                            			length = elems.length;
                            			for ( ; i &lt; length; i++ ) {
                            				value = callback( elems[ i ], i, arg );
                            
                            				if ( value != null ) {
                            					ret.push( value );
                            				}
                            			}
                            
                            		// Go through every key on the object,
                            		} else {
                            			for ( i in elems ) {
                            				value = callback( elems[ i ], i, arg );
                            
                            				if ( value != null ) {
                            					ret.push( value );
                            				}
                            			}
                            		}
                            
                            		// Flatten any nested arrays
                            		return concat.apply( [], ret );
                            	},
                            
                            	// A global GUID counter for objects
                            	guid: 1,
                            
                            	// Bind a function to a context, optionally partially applying any
                            	// arguments.
                            	proxy: function( fn, context ) {
                            		var tmp, args, proxy;
                            
                            		if ( typeof context === &quot;string&quot; ) {
                            			tmp = fn[ context ];
                            			context = fn;
                            			fn = tmp;
                            		}
                            
                            		// Quick check to determine if target is callable, in the spec
                            		// this throws a TypeError, but we will just return undefined.
                            		if ( !jQuery.isFunction( fn ) ) {
                            			return undefined;
                            		}
                            
                            		// Simulated bind
                            		args = slice.call( arguments, 2 );
                            		proxy = function() {
                            			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
                            		};
                            
                            		// Set the guid of unique handler to the same of original handler, so it can be removed
                            		proxy.guid = fn.guid = fn.guid || jQuery.guid++;
                            
                            		return proxy;
                            	},
                            
                            	now: Date.now,
                            
                            	// jQuery.support is not used in Core but other projects attach their
                            	// properties to it so it needs to exist.
                            	support: support
                            } );
                            
                            if ( typeof Symbol === &quot;function&quot; ) {
                            	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
                            }
                            
                            // Populate the class2type map
                            jQuery.each( &quot;Boolean Number String Function Array Date RegExp Object Error Symbol&quot;.split( &quot; &quot; ),
                            function( i, name ) {
                            	class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();
                            } );
                            
                            function isArrayLike( obj ) {
                            
                            	// Support: real iOS 8.2 only (not reproducible in simulator)
                            	// &#x60;in&#x60; check used to prevent JIT error (gh-2145)
                            	// hasOwn isn&#x27;t used here due to false negatives
                            	// regarding Nodelist length in IE
                            	var length = !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length,
                            		type = jQuery.type( obj );
                            
                            	if ( type === &quot;function&quot; || jQuery.isWindow( obj ) ) {
                            		return false;
                            	}
                            
                            	return type === &quot;array&quot; || length === 0 ||
                            		typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj;
                            }
                            var Sizzle =
                            /*!
                             * Sizzle CSS Selector Engine v2.3.3
                             * https://sizzlejs.com/
                             *
                             * Copyright jQuery Foundation and other contributors
                             * Released under the MIT license
                             * http://jquery.org/license
                             *
                             * Date: 2016-08-08
                             */
                            (function( window ) {
                            
                            var i,
                            	support,
                            	Expr,
                            	getText,
                            	isXML,
                            	tokenize,
                            	compile,
                            	select,
                            	outermostContext,
                            	sortInput,
                            	hasDuplicate,
                            
                            	// Local document vars
                            	setDocument,
                            	document,
                            	docElem,
                            	documentIsHTML,
                            	rbuggyQSA,
                            	rbuggyMatches,
                            	matches,
                            	contains,
                            
                            	// Instance-specific data
                            	expando = &quot;sizzle&quot; + 1 * new Date(),
                            	preferredDoc = window.document,
                            	dirruns = 0,
                            	done = 0,
                            	classCache = createCache(),
                            	tokenCache = createCache(),
                            	compilerCache = createCache(),
                            	sortOrder = function( a, b ) {
                            		if ( a === b ) {
                            			hasDuplicate = true;
                            		}
                            		return 0;
                            	},
                            
                            	// Instance methods
                            	hasOwn = ({}).hasOwnProperty,
                            	arr = [],
                            	pop = arr.pop,
                            	push_native = arr.push,
                            	push = arr.push,
                            	slice = arr.slice,
                            	// Use a stripped-down indexOf as it&#x27;s faster than native
                            	// https://jsperf.com/thor-indexof-vs-for/5
                            	indexOf = function( list, elem ) {
                            		var i = 0,
                            			len = list.length;
                            		for ( ; i &lt; len; i++ ) {
                            			if ( list[i] === elem ) {
                            				return i;
                            			}
                            		}
                            		return -1;
                            	},
                            
                            	booleans = &quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;,
                            
                            	// Regular expressions
                            
                            	// http://www.w3.org/TR/css3-selectors/#whitespace
                            	whitespace = &quot;[\\x20\\t\\r\\n\\f]&quot;,
                            
                            	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                            	identifier = &quot;(?:\\\\.|[\\w-]|[^\0-\\xa0])+&quot;,
                            
                            	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                            	attributes = &quot;\\[&quot; + whitespace + &quot;*(&quot; + identifier + &quot;)(?:&quot; + whitespace +
                            		// Operator (capture 2)
                            		&quot;*([*^$|!~]?=)&quot; + whitespace +
                            		// &quot;Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]&quot;
                            		&quot;*(?:&#x27;((?:\\\\.|[^\\\\&#x27;])*)&#x27;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;|(&quot; + identifier + &quot;))|)&quot; + whitespace +
                            		&quot;*\\]&quot;,
                            
                            	pseudos = &quot;:(&quot; + identifier + &quot;)(?:\\((&quot; +
                            		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                            		// 1. quoted (capture 3; capture 4 or capture 5)
                            		&quot;(&#x27;((?:\\\\.|[^\\\\&#x27;])*)&#x27;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;)|&quot; +
                            		// 2. simple (capture 6)
                            		&quot;((?:\\\\.|[^\\\\()[\\]]|&quot; + attributes + &quot;)*)|&quot; +
                            		// 3. anything else (capture 2)
                            		&quot;.*&quot; +
                            		&quot;)\\)|)&quot;,
                            
                            	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                            	rwhitespace = new RegExp( whitespace + &quot;+&quot;, &quot;g&quot; ),
                            	rtrim = new RegExp( &quot;^&quot; + whitespace + &quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot; + whitespace + &quot;+$&quot;, &quot;g&quot; ),
                            
                            	rcomma = new RegExp( &quot;^&quot; + whitespace + &quot;*,&quot; + whitespace + &quot;*&quot; ),
                            	rcombinators = new RegExp( &quot;^&quot; + whitespace + &quot;*([&gt;+~]|&quot; + whitespace + &quot;)&quot; + whitespace + &quot;*&quot; ),
                            
                            	rattributeQuotes = new RegExp( &quot;=&quot; + whitespace + &quot;*([^\\]&#x27;\&quot;]*?)&quot; + whitespace + &quot;*\\]&quot;, &quot;g&quot; ),
                            
                            	rpseudo = new RegExp( pseudos ),
                            	ridentifier = new RegExp( &quot;^&quot; + identifier + &quot;$&quot; ),
                            
                            	matchExpr = {
                            		&quot;ID&quot;: new RegExp( &quot;^#(&quot; + identifier + &quot;)&quot; ),
                            		&quot;CLASS&quot;: new RegExp( &quot;^\\.(&quot; + identifier + &quot;)&quot; ),
                            		&quot;TAG&quot;: new RegExp( &quot;^(&quot; + identifier + &quot;|[*])&quot; ),
                            		&quot;ATTR&quot;: new RegExp( &quot;^&quot; + attributes ),
                            		&quot;PSEUDO&quot;: new RegExp( &quot;^&quot; + pseudos ),
                            		&quot;CHILD&quot;: new RegExp( &quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&quot; + whitespace +
                            			&quot;*(even|odd|(([+-]|)(\\d*)n|)&quot; + whitespace + &quot;*(?:([+-]|)&quot; + whitespace +
                            			&quot;*(\\d+)|))&quot; + whitespace + &quot;*\\)|)&quot;, &quot;i&quot; ),
                            		&quot;bool&quot;: new RegExp( &quot;^(?:&quot; + booleans + &quot;)$&quot;, &quot;i&quot; ),
                            		// For use in libraries implementing .is()
                            		// We use this for POS matching in &#x60;select&#x60;
                            		&quot;needsContext&quot;: new RegExp( &quot;^&quot; + whitespace + &quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; +
                            			whitespace + &quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?=[^-]|$)&quot;, &quot;i&quot; )
                            	},
                            
                            	rinputs = /^(?:input|select|textarea|button)$/i,
                            	rheader = /^h\d$/i,
                            
                            	rnative = /^[^{]+\{\s*\[native \w/,
                            
                            	// Easily-parseable/retrievable ID or TAG or CLASS selectors
                            	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                            
                            	rsibling = /[+~]/,
                            
                            	// CSS escapes
                            	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                            	runescape = new RegExp( &quot;\\\\([\\da-f]{1,6}&quot; + whitespace + &quot;?|(&quot; + whitespace + &quot;)|.)&quot;, &quot;ig&quot; ),
                            	funescape = function( _, escaped, escapedWhitespace ) {
                            		var high = &quot;0x&quot; + escaped - 0x10000;
                            		// NaN means non-codepoint
                            		// Support: Firefox&lt;24
                            		// Workaround erroneous numeric interpretation of +&quot;0x&quot;
                            		return high !== high || escapedWhitespace ?
                            			escaped :
                            			high &lt; 0 ?
                            				// BMP codepoint
                            				String.fromCharCode( high + 0x10000 ) :
                            				// Supplemental Plane codepoint (surrogate pair)
                            				String.fromCharCode( high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00 );
                            	},
                            
                            	// CSS string/identifier serialization
                            	// https://drafts.csswg.org/cssom/#common-serializing-idioms
                            	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                            	fcssescape = function( ch, asCodePoint ) {
                            		if ( asCodePoint ) {
                            
                            			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                            			if ( ch === &quot;\0&quot; ) {
                            				return &quot;\uFFFD&quot;;
                            			}
                            
                            			// Control characters and (dependent upon position) numbers get escaped as code points
                            			return ch.slice( 0, -1 ) + &quot;\\&quot; + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + &quot; &quot;;
                            		}
                            
                            		// Other potentially-special ASCII characters get backslash-escaped
                            		return &quot;\\&quot; + ch;
                            	},
                            
                            	// Used for iframes
                            	// See setDocument()
                            	// Removing the function wrapper causes a &quot;Permission Denied&quot;
                            	// error in IE
                            	unloadHandler = function() {
                            		setDocument();
                            	},
                            
                            	disabledAncestor = addCombinator(
                            		function( elem ) {
                            			return elem.disabled === true &amp;&amp; (&quot;form&quot; in elem || &quot;label&quot; in elem);
                            		},
                            		{ dir: &quot;parentNode&quot;, next: &quot;legend&quot; }
                            	);
                            
                            // Optimize for push.apply( _, NodeList )
                            try {
                            	push.apply(
                            		(arr = slice.call( preferredDoc.childNodes )),
                            		preferredDoc.childNodes
                            	);
                            	// Support: Android&lt;4.0
                            	// Detect silently failing push.apply
                            	arr[ preferredDoc.childNodes.length ].nodeType;
                            } catch ( e ) {
                            	push = { apply: arr.length ?
                            
                            		// Leverage slice if possible
                            		function( target, els ) {
                            			push_native.apply( target, slice.call(els) );
                            		} :
                            
                            		// Support: IE&lt;9
                            		// Otherwise append directly
                            		function( target, els ) {
                            			var j = target.length,
                            				i = 0;
                            			// Can&#x27;t trust NodeList.length
                            			while ( (target[j++] = els[i++]) ) {}
                            			target.length = j - 1;
                            		}
                            	};
                            }
                            
                            function Sizzle( selector, context, results, seed ) {
                            	var m, i, elem, nid, match, groups, newSelector,
                            		newContext = context &amp;&amp; context.ownerDocument,
                            
                            		// nodeType defaults to 9, since context defaults to document
                            		nodeType = context ? context.nodeType : 9;
                            
                            	results = results || [];
                            
                            	// Return early from calls with invalid selector or context
                            	if ( typeof selector !== &quot;string&quot; || !selector ||
                            		nodeType !== 1 &amp;&amp; nodeType !== 9 &amp;&amp; nodeType !== 11 ) {
                            
                            		return results;
                            	}
                            
                            	// Try to shortcut find operations (as opposed to filters) in HTML documents
                            	if ( !seed ) {
                            
                            		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
                            			setDocument( context );
                            		}
                            		context = context || document;
                            
                            		if ( documentIsHTML ) {
                            
                            			// If the selector is sufficiently simple, try using a &quot;get*By*&quot; DOM method
                            			// (excepting DocumentFragment context, where the methods don&#x27;t exist)
                            			if ( nodeType !== 11 &amp;&amp; (match = rquickExpr.exec( selector )) ) {
                            
                            				// ID selector
                            				if ( (m = match[1]) ) {
                            
                            					// Document context
                            					if ( nodeType === 9 ) {
                            						if ( (elem = context.getElementById( m )) ) {
                            
                            							// Support: IE, Opera, Webkit
                            							// TODO: identify versions
                            							// getElementById can match elements by name instead of ID
                            							if ( elem.id === m ) {
                            								results.push( elem );
                            								return results;
                            							}
                            						} else {
                            							return results;
                            						}
                            
                            					// Element context
                            					} else {
                            
                            						// Support: IE, Opera, Webkit
                            						// TODO: identify versions
                            						// getElementById can match elements by name instead of ID
                            						if ( newContext &amp;&amp; (elem = newContext.getElementById( m )) &amp;&amp;
                            							contains( context, elem ) &amp;&amp;
                            							elem.id === m ) {
                            
                            							results.push( elem );
                            							return results;
                            						}
                            					}
                            
                            				// Type selector
                            				} else if ( match[2] ) {
                            					push.apply( results, context.getElementsByTagName( selector ) );
                            					return results;
                            
                            				// Class selector
                            				} else if ( (m = match[3]) &amp;&amp; support.getElementsByClassName &amp;&amp;
                            					context.getElementsByClassName ) {
                            
                            					push.apply( results, context.getElementsByClassName( m ) );
                            					return results;
                            				}
                            			}
                            
                            			// Take advantage of querySelectorAll
                            			if ( support.qsa &amp;&amp;
                            				!compilerCache[ selector + &quot; &quot; ] &amp;&amp;
                            				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
                            
                            				if ( nodeType !== 1 ) {
                            					newContext = context;
                            					newSelector = selector;
                            
                            				// qSA looks outside Element context, which is not what we want
                            				// Thanks to Andrew Dupont for this workaround technique
                            				// Support: IE &lt;=8
                            				// Exclude object elements
                            				} else if ( context.nodeName.toLowerCase() !== &quot;object&quot; ) {
                            
                            					// Capture the context ID, setting it first if necessary
                            					if ( (nid = context.getAttribute( &quot;id&quot; )) ) {
                            						nid = nid.replace( rcssescape, fcssescape );
                            					} else {
                            						context.setAttribute( &quot;id&quot;, (nid = expando) );
                            					}
                            
                            					// Prefix every selector in the list
                            					groups = tokenize( selector );
                            					i = groups.length;
                            					while ( i-- ) {
                            						groups[i] = &quot;#&quot; + nid + &quot; &quot; + toSelector( groups[i] );
                            					}
                            					newSelector = groups.join( &quot;,&quot; );
                            
                            					// Expand context for sibling selectors
                            					newContext = rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) ||
                            						context;
                            				}
                            
                            				if ( newSelector ) {
                            					try {
                            						push.apply( results,
                            							newContext.querySelectorAll( newSelector )
                            						);
                            						return results;
                            					} catch ( qsaError ) {
                            					} finally {
                            						if ( nid === expando ) {
                            							context.removeAttribute( &quot;id&quot; );
                            						}
                            					}
                            				}
                            			}
                            		}
                            	}
                            
                            	// All others
                            	return select( selector.replace( rtrim, &quot;$1&quot; ), context, results, seed );
                            }
                            
                            /**
                             * Create key-value caches of limited size
                             * @returns {function(string, object)} Returns the Object data after storing it on itself with
                             *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
                             *	deleting the oldest entry
                             */
                            function createCache() {
                            	var keys = [];
                            
                            	function cache( key, value ) {
                            		// Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)
                            		if ( keys.push( key + &quot; &quot; ) &gt; Expr.cacheLength ) {
                            			// Only keep the most recent entries
                            			delete cache[ keys.shift() ];
                            		}
                            		return (cache[ key + &quot; &quot; ] = value);
                            	}
                            	return cache;
                            }
                            
                            /**
                             * Mark a function for special use by Sizzle
                             * @param {Function} fn The function to mark
                             */
                            function markFunction( fn ) {
                            	fn[ expando ] = true;
                            	return fn;
                            }
                            
                            /**
                             * Support testing using an element
                             * @param {Function} fn Passed the created element and returns a boolean result
                             */
                            function assert( fn ) {
                            	var el = document.createElement(&quot;fieldset&quot;);
                            
                            	try {
                            		return !!fn( el );
                            	} catch (e) {
                            		return false;
                            	} finally {
                            		// Remove from its parent by default
                            		if ( el.parentNode ) {
                            			el.parentNode.removeChild( el );
                            		}
                            		// release memory in IE
                            		el = null;
                            	}
                            }
                            
                            /**
                             * Adds the same handler for all of the specified attrs
                             * @param {String} attrs Pipe-separated list of attributes
                             * @param {Function} handler The method that will be applied
                             */
                            function addHandle( attrs, handler ) {
                            	var arr = attrs.split(&quot;|&quot;),
                            		i = arr.length;
                            
                            	while ( i-- ) {
                            		Expr.attrHandle[ arr[i] ] = handler;
                            	}
                            }
                            
                            /**
                             * Checks document order of two siblings
                             * @param {Element} a
                             * @param {Element} b
                             * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
                             */
                            function siblingCheck( a, b ) {
                            	var cur = b &amp;&amp; a,
                            		diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp;
                            			a.sourceIndex - b.sourceIndex;
                            
                            	// Use IE sourceIndex if available on both nodes
                            	if ( diff ) {
                            		return diff;
                            	}
                            
                            	// Check if b follows a
                            	if ( cur ) {
                            		while ( (cur = cur.nextSibling) ) {
                            			if ( cur === b ) {
                            				return -1;
                            			}
                            		}
                            	}
                            
                            	return a ? 1 : -1;
                            }
                            
                            /**
                             * Returns a function to use in pseudos for input types
                             * @param {String} type
                             */
                            function createInputPseudo( type ) {
                            	return function( elem ) {
                            		var name = elem.nodeName.toLowerCase();
                            		return name === &quot;input&quot; &amp;&amp; elem.type === type;
                            	};
                            }
                            
                            /**
                             * Returns a function to use in pseudos for buttons
                             * @param {String} type
                             */
                            function createButtonPseudo( type ) {
                            	return function( elem ) {
                            		var name = elem.nodeName.toLowerCase();
                            		return (name === &quot;input&quot; || name === &quot;button&quot;) &amp;&amp; elem.type === type;
                            	};
                            }
                            
                            /**
                             * Returns a function to use in pseudos for :enabled/:disabled
                             * @param {Boolean} disabled true for :disabled; false for :enabled
                             */
                            function createDisabledPseudo( disabled ) {
                            
                            	// Known :disabled false positives: fieldset[disabled] &gt; legend:nth-of-type(n+2) :can-disable
                            	return function( elem ) {
                            
                            		// Only certain elements can match :enabled or :disabled
                            		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                            		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                            		if ( &quot;form&quot; in elem ) {
                            
                            			// Check for inherited disabledness on relevant non-disabled elements:
                            			// * listed form-associated elements in a disabled fieldset
                            			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                            			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                            			// * option elements in a disabled optgroup
                            			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                            			// All such elements have a &quot;form&quot; property.
                            			if ( elem.parentNode &amp;&amp; elem.disabled === false ) {
                            
                            				// Option elements defer to a parent optgroup if present
                            				if ( &quot;label&quot; in elem ) {
                            					if ( &quot;label&quot; in elem.parentNode ) {
                            						return elem.parentNode.disabled === disabled;
                            					} else {
                            						return elem.disabled === disabled;
                            					}
                            				}
                            
                            				// Support: IE 6 - 11
                            				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
                            				return elem.isDisabled === disabled ||
                            
                            					// Where there is no isDisabled, check manually
                            					/* jshint -W018 */
                            					elem.isDisabled !== !disabled &amp;&amp;
                            						disabledAncestor( elem ) === disabled;
                            			}
                            
                            			return elem.disabled === disabled;
                            
                            		// Try to winnow out elements that can&#x27;t be disabled before trusting the disabled property.
                            		// Some victims get caught in our net (label, legend, menu, track), but it shouldn&#x27;t
                            		// even exist on them, let alone have a boolean value.
                            		} else if ( &quot;label&quot; in elem ) {
                            			return elem.disabled === disabled;
                            		}
                            
                            		// Remaining elements are neither :enabled nor :disabled
                            		return false;
                            	};
                            }
                            
                            /**
                             * Returns a function to use in pseudos for positionals
                             * @param {Function} fn
                             */
                            function createPositionalPseudo( fn ) {
                            	return markFunction(function( argument ) {
                            		argument = +argument;
                            		return markFunction(function( seed, matches ) {
                            			var j,
                            				matchIndexes = fn( [], seed.length, argument ),
                            				i = matchIndexes.length;
                            
                            			// Match elements found at the specified indexes
                            			while ( i-- ) {
                            				if ( seed[ (j = matchIndexes[i]) ] ) {
                            					seed[j] = !(matches[j] = seed[j]);
                            				}
                            			}
                            		});
                            	});
                            }
                            
                            /**
                             * Checks a node for validity as a Sizzle context
                             * @param {Element|Object=} context
                             * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
                             */
                            function testContext( context ) {
                            	return context &amp;&amp; typeof context.getElementsByTagName !== &quot;undefined&quot; &amp;&amp; context;
                            }
                            
                            // Expose support vars for convenience
                            support = Sizzle.support = {};
                            
                            /**
                             * Detects XML nodes
                             * @param {Element|Object} elem An element or a document
                             * @returns {Boolean} True iff elem is a non-HTML XML node
                             */
                            isXML = Sizzle.isXML = function( elem ) {
                            	// documentElement is verified for cases where it doesn&#x27;t yet exist
                            	// (such as loading iframes in IE - #4833)
                            	var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
                            	return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false;
                            };
                            
                            /**
                             * Sets document-related variables once based on the current document
                             * @param {Element|Object} [doc] An element or document object to use to set the document
                             * @returns {Object} Returns the current document
                             */
                            setDocument = Sizzle.setDocument = function( node ) {
                            	var hasCompare, subWindow,
                            		doc = node ? node.ownerDocument || node : preferredDoc;
                            
                            	// Return early if doc is invalid or already selected
                            	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
                            		return document;
                            	}
                            
                            	// Update global variables
                            	document = doc;
                            	docElem = document.documentElement;
                            	documentIsHTML = !isXML( document );
                            
                            	// Support: IE 9-11, Edge
                            	// Accessing iframe documents after unload throws &quot;permission denied&quot; errors (jQuery #13936)
                            	if ( preferredDoc !== document &amp;&amp;
                            		(subWindow = document.defaultView) &amp;&amp; subWindow.top !== subWindow ) {
                            
                            		// Support: IE 11, Edge
                            		if ( subWindow.addEventListener ) {
                            			subWindow.addEventListener( &quot;unload&quot;, unloadHandler, false );
                            
                            		// Support: IE 9 - 10 only
                            		} else if ( subWindow.attachEvent ) {
                            			subWindow.attachEvent( &quot;onunload&quot;, unloadHandler );
                            		}
                            	}
                            
                            	/* Attributes
                            	---------------------------------------------------------------------- */
                            
                            	// Support: IE&lt;8
                            	// Verify that getAttribute really returns attributes and not properties
                            	// (excepting IE8 booleans)
                            	support.attributes = assert(function( el ) {
                            		el.className = &quot;i&quot;;
                            		return !el.getAttribute(&quot;className&quot;);
                            	});
                            
                            	/* getElement(s)By*
                            	---------------------------------------------------------------------- */
                            
                            	// Check if getElementsByTagName(&quot;*&quot;) returns only elements
                            	support.getElementsByTagName = assert(function( el ) {
                            		el.appendChild( document.createComment(&quot;&quot;) );
                            		return !el.getElementsByTagName(&quot;*&quot;).length;
                            	});
                            
                            	// Support: IE&lt;9
                            	support.getElementsByClassName = rnative.test( document.getElementsByClassName );
                            
                            	// Support: IE&lt;10
                            	// Check if getElementById returns elements by name
                            	// The broken getElementById methods don&#x27;t pick up programmatically-set names,
                            	// so use a roundabout getElementsByName test
                            	support.getById = assert(function( el ) {
                            		docElem.appendChild( el ).id = expando;
                            		return !document.getElementsByName || !document.getElementsByName( expando ).length;
                            	});
                            
                            	// ID filter and find
                            	if ( support.getById ) {
                            		Expr.filter[&quot;ID&quot;] = function( id ) {
                            			var attrId = id.replace( runescape, funescape );
                            			return function( elem ) {
                            				return elem.getAttribute(&quot;id&quot;) === attrId;
                            			};
                            		};
                            		Expr.find[&quot;ID&quot;] = function( id, context ) {
                            			if ( typeof context.getElementById !== &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
                            				var elem = context.getElementById( id );
                            				return elem ? [ elem ] : [];
                            			}
                            		};
                            	} else {
                            		Expr.filter[&quot;ID&quot;] =  function( id ) {
                            			var attrId = id.replace( runescape, funescape );
                            			return function( elem ) {
                            				var node = typeof elem.getAttributeNode !== &quot;undefined&quot; &amp;&amp;
                            					elem.getAttributeNode(&quot;id&quot;);
                            				return node &amp;&amp; node.value === attrId;
                            			};
                            		};
                            
                            		// Support: IE 6 - 7 only
                            		// getElementById is not reliable as a find shortcut
                            		Expr.find[&quot;ID&quot;] = function( id, context ) {
                            			if ( typeof context.getElementById !== &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
                            				var node, i, elems,
                            					elem = context.getElementById( id );
                            
                            				if ( elem ) {
                            
                            					// Verify the id attribute
                            					node = elem.getAttributeNode(&quot;id&quot;);
                            					if ( node &amp;&amp; node.value === id ) {
                            						return [ elem ];
                            					}
                            
                            					// Fall back on getElementsByName
                            					elems = context.getElementsByName( id );
                            					i = 0;
                            					while ( (elem = elems[i++]) ) {
                            						node = elem.getAttributeNode(&quot;id&quot;);
                            						if ( node &amp;&amp; node.value === id ) {
                            							return [ elem ];
                            						}
                            					}
                            				}
                            
                            				return [];
                            			}
                            		};
                            	}
                            
                            	// Tag
                            	Expr.find[&quot;TAG&quot;] = support.getElementsByTagName ?
                            		function( tag, context ) {
                            			if ( typeof context.getElementsByTagName !== &quot;undefined&quot; ) {
                            				return context.getElementsByTagName( tag );
                            
                            			// DocumentFragment nodes don&#x27;t have gEBTN
                            			} else if ( support.qsa ) {
                            				return context.querySelectorAll( tag );
                            			}
                            		} :
                            
                            		function( tag, context ) {
                            			var elem,
                            				tmp = [],
                            				i = 0,
                            				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                            				results = context.getElementsByTagName( tag );
                            
                            			// Filter out possible comments
                            			if ( tag === &quot;*&quot; ) {
                            				while ( (elem = results[i++]) ) {
                            					if ( elem.nodeType === 1 ) {
                            						tmp.push( elem );
                            					}
                            				}
                            
                            				return tmp;
                            			}
                            			return results;
                            		};
                            
                            	// Class
                            	Expr.find[&quot;CLASS&quot;] = support.getElementsByClassName &amp;&amp; function( className, context ) {
                            		if ( typeof context.getElementsByClassName !== &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
                            			return context.getElementsByClassName( className );
                            		}
                            	};
                            
                            	/* QSA/matchesSelector
                            	---------------------------------------------------------------------- */
                            
                            	// QSA and matchesSelector support
                            
                            	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                            	rbuggyMatches = [];
                            
                            	// qSa(:focus) reports false when true (Chrome 21)
                            	// We allow this because of a bug in IE8/9 that throws an error
                            	// whenever &#x60;document.activeElement&#x60; is accessed on an iframe
                            	// So, we allow :focus to pass through QSA all the time to avoid the IE error
                            	// See https://bugs.jquery.com/ticket/13378
                            	rbuggyQSA = [];
                            
                            	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
                            		// Build QSA regex
                            		// Regex strategy adopted from Diego Perini
                            		assert(function( el ) {
                            			// Select is set to empty string on purpose
                            			// This is to test IE&#x27;s treatment of not explicitly
                            			// setting a boolean content attribute,
                            			// since its presence should be enough
                            			// https://bugs.jquery.com/ticket/12359
                            			docElem.appendChild( el ).innerHTML = &quot;&lt;a id=&#x27;&quot; + expando + &quot;&#x27;&gt;&lt;/a&gt;&quot; +
                            				&quot;&lt;select id=&#x27;&quot; + expando + &quot;-\r\\&#x27; msallowcapture=&#x27;&#x27;&gt;&quot; +
                            				&quot;&lt;option selected=&#x27;&#x27;&gt;&lt;/option&gt;&lt;/select&gt;&quot;;
                            
                            			// Support: IE8, Opera 11-12.16
                            			// Nothing should be selected when empty strings follow ^= or $= or *=
                            			// The test attribute must be unknown in Opera but &quot;safe&quot; for WinRT
                            			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                            			if ( el.querySelectorAll(&quot;[msallowcapture^=&#x27;&#x27;]&quot;).length ) {
                            				rbuggyQSA.push( &quot;[*^$]=&quot; + whitespace + &quot;*(?:&#x27;&#x27;|\&quot;\&quot;)&quot; );
                            			}
                            
                            			// Support: IE8
                            			// Boolean attributes and &quot;value&quot; are not treated correctly
                            			if ( !el.querySelectorAll(&quot;[selected]&quot;).length ) {
                            				rbuggyQSA.push( &quot;\\[&quot; + whitespace + &quot;*(?:value|&quot; + booleans + &quot;)&quot; );
                            			}
                            
                            			// Support: Chrome&lt;29, Android&lt;4.4, Safari&lt;7.0+, iOS&lt;7.0+, PhantomJS&lt;1.9.8+
                            			if ( !el.querySelectorAll( &quot;[id~=&quot; + expando + &quot;-]&quot; ).length ) {
                            				rbuggyQSA.push(&quot;~=&quot;);
                            			}
                            
                            			// Webkit/Opera - :checked should return selected option elements
                            			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                            			// IE8 throws error here and will not see later tests
                            			if ( !el.querySelectorAll(&quot;:checked&quot;).length ) {
                            				rbuggyQSA.push(&quot;:checked&quot;);
                            			}
                            
                            			// Support: Safari 8+, iOS 8+
                            			// https://bugs.webkit.org/show_bug.cgi?id=136851
                            			// In-page &#x60;selector#id sibling-combinator selector&#x60; fails
                            			if ( !el.querySelectorAll( &quot;a#&quot; + expando + &quot;+*&quot; ).length ) {
                            				rbuggyQSA.push(&quot;.#.+[+~]&quot;);
                            			}
                            		});
                            
                            		assert(function( el ) {
                            			el.innerHTML = &quot;&lt;a href=&#x27;&#x27; disabled=&#x27;disabled&#x27;&gt;&lt;/a&gt;&quot; +
                            				&quot;&lt;select disabled=&#x27;disabled&#x27;&gt;&lt;option/&gt;&lt;/select&gt;&quot;;
                            
                            			// Support: Windows 8 Native Apps
                            			// The type and name attributes are restricted during .innerHTML assignment
                            			var input = document.createElement(&quot;input&quot;);
                            			input.setAttribute( &quot;type&quot;, &quot;hidden&quot; );
                            			el.appendChild( input ).setAttribute( &quot;name&quot;, &quot;D&quot; );
                            
                            			// Support: IE8
                            			// Enforce case-sensitivity of name attribute
                            			if ( el.querySelectorAll(&quot;[name=d]&quot;).length ) {
                            				rbuggyQSA.push( &quot;name&quot; + whitespace + &quot;*[*^$|!~]?=&quot; );
                            			}
                            
                            			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                            			// IE8 throws error here and will not see later tests
                            			if ( el.querySelectorAll(&quot;:enabled&quot;).length !== 2 ) {
                            				rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
                            			}
                            
                            			// Support: IE9-11+
                            			// IE&#x27;s :disabled selector does not pick up the children of disabled fieldsets
                            			docElem.appendChild( el ).disabled = true;
                            			if ( el.querySelectorAll(&quot;:disabled&quot;).length !== 2 ) {
                            				rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
                            			}
                            
                            			// Opera 10-11 does not throw on post-comma invalid pseudos
                            			el.querySelectorAll(&quot;*,:x&quot;);
                            			rbuggyQSA.push(&quot;,.*:&quot;);
                            		});
                            	}
                            
                            	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
                            		docElem.webkitMatchesSelector ||
                            		docElem.mozMatchesSelector ||
                            		docElem.oMatchesSelector ||
                            		docElem.msMatchesSelector) )) ) {
                            
                            		assert(function( el ) {
                            			// Check to see if it&#x27;s possible to do matchesSelector
                            			// on a disconnected node (IE 9)
                            			support.disconnectedMatch = matches.call( el, &quot;*&quot; );
                            
                            			// This should fail with an exception
                            			// Gecko does not error, returns false instead
                            			matches.call( el, &quot;[s!=&#x27;&#x27;]:x&quot; );
                            			rbuggyMatches.push( &quot;!=&quot;, pseudos );
                            		});
                            	}
                            
                            	rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp( rbuggyQSA.join(&quot;|&quot;) );
                            	rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp( rbuggyMatches.join(&quot;|&quot;) );
                            
                            	/* Contains
                            	---------------------------------------------------------------------- */
                            	hasCompare = rnative.test( docElem.compareDocumentPosition );
                            
                            	// Element contains another
                            	// Purposefully self-exclusive
                            	// As in, an element does not contain itself
                            	contains = hasCompare || rnative.test( docElem.contains ) ?
                            		function( a, b ) {
                            			var adown = a.nodeType === 9 ? a.documentElement : a,
                            				bup = b &amp;&amp; b.parentNode;
                            			return a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (
                            				adown.contains ?
                            					adown.contains( bup ) :
                            					a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16
                            			));
                            		} :
                            		function( a, b ) {
                            			if ( b ) {
                            				while ( (b = b.parentNode) ) {
                            					if ( b === a ) {
                            						return true;
                            					}
                            				}
                            			}
                            			return false;
                            		};
                            
                            	/* Sorting
                            	---------------------------------------------------------------------- */
                            
                            	// Document order sorting
                            	sortOrder = hasCompare ?
                            	function( a, b ) {
                            
                            		// Flag for duplicate removal
                            		if ( a === b ) {
                            			hasDuplicate = true;
                            			return 0;
                            		}
                            
                            		// Sort on method existence if only one input has compareDocumentPosition
                            		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                            		if ( compare ) {
                            			return compare;
                            		}
                            
                            		// Calculate position if both inputs belong to the same document
                            		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                            			a.compareDocumentPosition( b ) :
                            
                            			// Otherwise we know they are disconnected
                            			1;
                            
                            		// Disconnected nodes
                            		if ( compare &amp; 1 ||
                            			(!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) {
                            
                            			// Choose the first element that is related to our preferred document
                            			if ( a === document || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a) ) {
                            				return -1;
                            			}
                            			if ( b === document || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b) ) {
                            				return 1;
                            			}
                            
                            			// Maintain original order
                            			return sortInput ?
                            				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                            				0;
                            		}
                            
                            		return compare &amp; 4 ? -1 : 1;
                            	} :
                            	function( a, b ) {
                            		// Exit early if the nodes are identical
                            		if ( a === b ) {
                            			hasDuplicate = true;
                            			return 0;
                            		}
                            
                            		var cur,
                            			i = 0,
                            			aup = a.parentNode,
                            			bup = b.parentNode,
                            			ap = [ a ],
                            			bp = [ b ];
                            
                            		// Parentless nodes are either documents or disconnected
                            		if ( !aup || !bup ) {
                            			return a === document ? -1 :
                            				b === document ? 1 :
                            				aup ? -1 :
                            				bup ? 1 :
                            				sortInput ?
                            				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                            				0;
                            
                            		// If the nodes are siblings, we can do a quick check
                            		} else if ( aup === bup ) {
                            			return siblingCheck( a, b );
                            		}
                            
                            		// Otherwise we need full lists of their ancestors for comparison
                            		cur = a;
                            		while ( (cur = cur.parentNode) ) {
                            			ap.unshift( cur );
                            		}
                            		cur = b;
                            		while ( (cur = cur.parentNode) ) {
                            			bp.unshift( cur );
                            		}
                            
                            		// Walk down the tree looking for a discrepancy
                            		while ( ap[i] === bp[i] ) {
                            			i++;
                            		}
                            
                            		return i ?
                            			// Do a sibling check if the nodes have a common ancestor
                            			siblingCheck( ap[i], bp[i] ) :
                            
                            			// Otherwise nodes in our document sort first
                            			ap[i] === preferredDoc ? -1 :
                            			bp[i] === preferredDoc ? 1 :
                            			0;
                            	};
                            
                            	return document;
                            };
                            
                            Sizzle.matches = function( expr, elements ) {
                            	return Sizzle( expr, null, null, elements );
                            };
                            
                            Sizzle.matchesSelector = function( elem, expr ) {
                            	// Set document vars if needed
                            	if ( ( elem.ownerDocument || elem ) !== document ) {
                            		setDocument( elem );
                            	}
                            
                            	// Make sure that attribute selectors are quoted
                            	expr = expr.replace( rattributeQuotes, &quot;=&#x27;$1&#x27;]&quot; );
                            
                            	if ( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
                            		!compilerCache[ expr + &quot; &quot; ] &amp;&amp;
                            		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp;
                            		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
                            
                            		try {
                            			var ret = matches.call( elem, expr );
                            
                            			// IE 9&#x27;s matchesSelector returns false on disconnected nodes
                            			if ( ret || support.disconnectedMatch ||
                            					// As well, disconnected nodes are said to be in a document
                            					// fragment in IE 9
                            					elem.document &amp;&amp; elem.document.nodeType !== 11 ) {
                            				return ret;
                            			}
                            		} catch (e) {}
                            	}
                            
                            	return Sizzle( expr, document, null, [ elem ] ).length &gt; 0;
                            };
                            
                            Sizzle.contains = function( context, elem ) {
                            	// Set document vars if needed
                            	if ( ( context.ownerDocument || context ) !== document ) {
                            		setDocument( context );
                            	}
                            	return contains( context, elem );
                            };
                            
                            Sizzle.attr = function( elem, name ) {
                            	// Set document vars if needed
                            	if ( ( elem.ownerDocument || elem ) !== document ) {
                            		setDocument( elem );
                            	}
                            
                            	var fn = Expr.attrHandle[ name.toLowerCase() ],
                            		// Don&#x27;t get fooled by Object.prototype properties (jQuery #13807)
                            		val = fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                            			fn( elem, name, !documentIsHTML ) :
                            			undefined;
                            
                            	return val !== undefined ?
                            		val :
                            		support.attributes || !documentIsHTML ?
                            			elem.getAttribute( name ) :
                            			(val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
                            				val.value :
                            				null;
                            };
                            
                            Sizzle.escape = function( sel ) {
                            	return (sel + &quot;&quot;).replace( rcssescape, fcssescape );
                            };
                            
                            Sizzle.error = function( msg ) {
                            	throw new Error( &quot;Syntax error, unrecognized expression: &quot; + msg );
                            };
                            
                            /**
                             * Document sorting and removing duplicates
                             * @param {ArrayLike} results
                             */
                            Sizzle.uniqueSort = function( results ) {
                            	var elem,
                            		duplicates = [],
                            		j = 0,
                            		i = 0;
                            
                            	// Unless we *know* we can detect duplicates, assume their presence
                            	hasDuplicate = !support.detectDuplicates;
                            	sortInput = !support.sortStable &amp;&amp; results.slice( 0 );
                            	results.sort( sortOrder );
                            
                            	if ( hasDuplicate ) {
                            		while ( (elem = results[i++]) ) {
                            			if ( elem === results[ i ] ) {
                            				j = duplicates.push( i );
                            			}
                            		}
                            		while ( j-- ) {
                            			results.splice( duplicates[ j ], 1 );
                            		}
                            	}
                            
                            	// Clear input after sorting to release objects
                            	// See https://github.com/jquery/sizzle/pull/225
                            	sortInput = null;
                            
                            	return results;
                            };
                            
                            /**
                             * Utility function for retrieving the text value of an array of DOM nodes
                             * @param {Array|Element} elem
                             */
                            getText = Sizzle.getText = function( elem ) {
                            	var node,
                            		ret = &quot;&quot;,
                            		i = 0,
                            		nodeType = elem.nodeType;
                            
                            	if ( !nodeType ) {
                            		// If no nodeType, this is expected to be an array
                            		while ( (node = elem[i++]) ) {
                            			// Do not traverse comment nodes
                            			ret += getText( node );
                            		}
                            	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
                            		// Use textContent for elements
                            		// innerText usage removed for consistency of new lines (jQuery #11153)
                            		if ( typeof elem.textContent === &quot;string&quot; ) {
                            			return elem.textContent;
                            		} else {
                            			// Traverse its children
                            			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                            				ret += getText( elem );
                            			}
                            		}
                            	} else if ( nodeType === 3 || nodeType === 4 ) {
                            		return elem.nodeValue;
                            	}
                            	// Do not include comment or processing instruction nodes
                            
                            	return ret;
                            };
                            
                            Expr = Sizzle.selectors = {
                            
                            	// Can be adjusted by the user
                            	cacheLength: 50,
                            
                            	createPseudo: markFunction,
                            
                            	match: matchExpr,
                            
                            	attrHandle: {},
                            
                            	find: {},
                            
                            	relative: {
                            		&quot;&gt;&quot;: { dir: &quot;parentNode&quot;, first: true },
                            		&quot; &quot;: { dir: &quot;parentNode&quot; },
                            		&quot;+&quot;: { dir: &quot;previousSibling&quot;, first: true },
                            		&quot;~&quot;: { dir: &quot;previousSibling&quot; }
                            	},
                            
                            	preFilter: {
                            		&quot;ATTR&quot;: function( match ) {
                            			match[1] = match[1].replace( runescape, funescape );
                            
                            			// Move the given value to match[3] whether quoted or unquoted
                            			match[3] = ( match[3] || match[4] || match[5] || &quot;&quot; ).replace( runescape, funescape );
                            
                            			if ( match[2] === &quot;~=&quot; ) {
                            				match[3] = &quot; &quot; + match[3] + &quot; &quot;;
                            			}
                            
                            			return match.slice( 0, 4 );
                            		},
                            
                            		&quot;CHILD&quot;: function( match ) {
                            			/* matches from matchExpr[&quot;CHILD&quot;]
                            				1 type (only|nth|...)
                            				2 what (child|of-type)
                            				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                            				4 xn-component of xn+y argument ([+-]?\d*n|)
                            				5 sign of xn-component
                            				6 x of xn-component
                            				7 sign of y-component
                            				8 y of y-component
                            			*/
                            			match[1] = match[1].toLowerCase();
                            
                            			if ( match[1].slice( 0, 3 ) === &quot;nth&quot; ) {
                            				// nth-* requires argument
                            				if ( !match[3] ) {
                            					Sizzle.error( match[0] );
                            				}
                            
                            				// numeric x and y parameters for Expr.filter.CHILD
                            				// remember that false/true cast respectively to 0/1
                            				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === &quot;even&quot; || match[3] === &quot;odd&quot; ) );
                            				match[5] = +( ( match[7] + match[8] ) || match[3] === &quot;odd&quot; );
                            
                            			// other types prohibit arguments
                            			} else if ( match[3] ) {
                            				Sizzle.error( match[0] );
                            			}
                            
                            			return match;
                            		},
                            
                            		&quot;PSEUDO&quot;: function( match ) {
                            			var excess,
                            				unquoted = !match[6] &amp;&amp; match[2];
                            
                            			if ( matchExpr[&quot;CHILD&quot;].test( match[0] ) ) {
                            				return null;
                            			}
                            
                            			// Accept quoted arguments as-is
                            			if ( match[3] ) {
                            				match[2] = match[4] || match[5] || &quot;&quot;;
                            
                            			// Strip excess characters from unquoted arguments
                            			} else if ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp;
                            				// Get excess from tokenize (recursively)
                            				(excess = tokenize( unquoted, true )) &amp;&amp;
                            				// advance to the next closing parenthesis
                            				(excess = unquoted.indexOf( &quot;)&quot;, unquoted.length - excess ) - unquoted.length) ) {
                            
                            				// excess is a negative index
                            				match[0] = match[0].slice( 0, excess );
                            				match[2] = unquoted.slice( 0, excess );
                            			}
                            
                            			// Return only captures needed by the pseudo filter method (type and argument)
                            			return match.slice( 0, 3 );
                            		}
                            	},
                            
                            	filter: {
                            
                            		&quot;TAG&quot;: function( nodeNameSelector ) {
                            			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                            			return nodeNameSelector === &quot;*&quot; ?
                            				function() { return true; } :
                            				function( elem ) {
                            					return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
                            				};
                            		},
                            
                            		&quot;CLASS&quot;: function( className ) {
                            			var pattern = classCache[ className + &quot; &quot; ];
                            
                            			return pattern ||
                            				(pattern = new RegExp( &quot;(^|&quot; + whitespace + &quot;)&quot; + className + &quot;(&quot; + whitespace + &quot;|$)&quot; )) &amp;&amp;
                            				classCache( className, function( elem ) {
                            					return pattern.test( typeof elem.className === &quot;string&quot; &amp;&amp; elem.className || typeof elem.getAttribute !== &quot;undefined&quot; &amp;&amp; elem.getAttribute(&quot;class&quot;) || &quot;&quot; );
                            				});
                            		},
                            
                            		&quot;ATTR&quot;: function( name, operator, check ) {
                            			return function( elem ) {
                            				var result = Sizzle.attr( elem, name );
                            
                            				if ( result == null ) {
                            					return operator === &quot;!=&quot;;
                            				}
                            				if ( !operator ) {
                            					return true;
                            				}
                            
                            				result += &quot;&quot;;
                            
                            				return operator === &quot;=&quot; ? result === check :
                            					operator === &quot;!=&quot; ? result !== check :
                            					operator === &quot;^=&quot; ? check &amp;&amp; result.indexOf( check ) === 0 :
                            					operator === &quot;*=&quot; ? check &amp;&amp; result.indexOf( check ) &gt; -1 :
                            					operator === &quot;$=&quot; ? check &amp;&amp; result.slice( -check.length ) === check :
                            					operator === &quot;~=&quot; ? ( &quot; &quot; + result.replace( rwhitespace, &quot; &quot; ) + &quot; &quot; ).indexOf( check ) &gt; -1 :
                            					operator === &quot;|=&quot; ? result === check || result.slice( 0, check.length + 1 ) === check + &quot;-&quot; :
                            					false;
                            			};
                            		},
                            
                            		&quot;CHILD&quot;: function( type, what, argument, first, last ) {
                            			var simple = type.slice( 0, 3 ) !== &quot;nth&quot;,
                            				forward = type.slice( -4 ) !== &quot;last&quot;,
                            				ofType = what === &quot;of-type&quot;;
                            
                            			return first === 1 &amp;&amp; last === 0 ?
                            
                            				// Shortcut for :nth-*(n)
                            				function( elem ) {
                            					return !!elem.parentNode;
                            				} :
                            
                            				function( elem, context, xml ) {
                            					var cache, uniqueCache, outerCache, node, nodeIndex, start,
                            						dir = simple !== forward ? &quot;nextSibling&quot; : &quot;previousSibling&quot;,
                            						parent = elem.parentNode,
                            						name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
                            						useCache = !xml &amp;&amp; !ofType,
                            						diff = false;
                            
                            					if ( parent ) {
                            
                            						// :(first|last|only)-(child|of-type)
                            						if ( simple ) {
                            							while ( dir ) {
                            								node = elem;
                            								while ( (node = node[ dir ]) ) {
                            									if ( ofType ?
                            										node.nodeName.toLowerCase() === name :
                            										node.nodeType === 1 ) {
                            
                            										return false;
                            									}
                            								}
                            								// Reverse direction for :only-* (if we haven&#x27;t yet done so)
                            								start = dir = type === &quot;only&quot; &amp;&amp; !start &amp;&amp; &quot;nextSibling&quot;;
                            							}
                            							return true;
                            						}
                            
                            						start = [ forward ? parent.firstChild : parent.lastChild ];
                            
                            						// non-xml :nth-child(...) stores cache data on &#x60;parent&#x60;
                            						if ( forward &amp;&amp; useCache ) {
                            
                            							// Seek &#x60;elem&#x60; from a previously-cached index
                            
                            							// ...in a gzip-friendly way
                            							node = parent;
                            							outerCache = node[ expando ] || (node[ expando ] = {});
                            
                            							// Support: IE &lt;9 only
                            							// Defend against cloned attroperties (jQuery gh-1709)
                            							uniqueCache = outerCache[ node.uniqueID ] ||
                            								(outerCache[ node.uniqueID ] = {});
                            
                            							cache = uniqueCache[ type ] || [];
                            							nodeIndex = cache[ 0 ] === dirruns &amp;&amp; cache[ 1 ];
                            							diff = nodeIndex &amp;&amp; cache[ 2 ];
                            							node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ];
                            
                            							while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
                            
                            								// Fallback to seeking &#x60;elem&#x60; from the start
                            								(diff = nodeIndex = 0) || start.pop()) ) {
                            
                            								// When found, cache indexes on &#x60;parent&#x60; and break
                            								if ( node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem ) {
                            									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
                            									break;
                            								}
                            							}
                            
                            						} else {
                            							// Use previously-cached element index if available
                            							if ( useCache ) {
                            								// ...in a gzip-friendly way
                            								node = elem;
                            								outerCache = node[ expando ] || (node[ expando ] = {});
                            
                            								// Support: IE &lt;9 only
                            								// Defend against cloned attroperties (jQuery gh-1709)
                            								uniqueCache = outerCache[ node.uniqueID ] ||
                            									(outerCache[ node.uniqueID ] = {});
                            
                            								cache = uniqueCache[ type ] || [];
                            								nodeIndex = cache[ 0 ] === dirruns &amp;&amp; cache[ 1 ];
                            								diff = nodeIndex;
                            							}
                            
                            							// xml :nth-child(...)
                            							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
                            							if ( diff === false ) {
                            								// Use the same loop as above to seek &#x60;elem&#x60; from the start
                            								while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
                            									(diff = nodeIndex = 0) || start.pop()) ) {
                            
                            									if ( ( ofType ?
                            										node.nodeName.toLowerCase() === name :
                            										node.nodeType === 1 ) &amp;&amp;
                            										++diff ) {
                            
                            										// Cache the index of each encountered element
                            										if ( useCache ) {
                            											outerCache = node[ expando ] || (node[ expando ] = {});
                            
                            											// Support: IE &lt;9 only
                            											// Defend against cloned attroperties (jQuery gh-1709)
                            											uniqueCache = outerCache[ node.uniqueID ] ||
                            												(outerCache[ node.uniqueID ] = {});
                            
                            											uniqueCache[ type ] = [ dirruns, diff ];
                            										}
                            
                            										if ( node === elem ) {
                            											break;
                            										}
                            									}
                            								}
                            							}
                            						}
                            
                            						// Incorporate the offset, then check against cycle size
                            						diff -= last;
                            						return diff === first || ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 );
                            					}
                            				};
                            		},
                            
                            		&quot;PSEUDO&quot;: function( pseudo, argument ) {
                            			// pseudo-class names are case-insensitive
                            			// http://www.w3.org/TR/selectors/#pseudo-classes
                            			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                            			// Remember that setFilters inherits from pseudos
                            			var args,
                            				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                            					Sizzle.error( &quot;unsupported pseudo: &quot; + pseudo );
                            
                            			// The user may use createPseudo to indicate that
                            			// arguments are needed to create the filter function
                            			// just as Sizzle does
                            			if ( fn[ expando ] ) {
                            				return fn( argument );
                            			}
                            
                            			// But maintain support for old signatures
                            			if ( fn.length &gt; 1 ) {
                            				args = [ pseudo, pseudo, &quot;&quot;, argument ];
                            				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                            					markFunction(function( seed, matches ) {
                            						var idx,
                            							matched = fn( seed, argument ),
                            							i = matched.length;
                            						while ( i-- ) {
                            							idx = indexOf( seed, matched[i] );
                            							seed[ idx ] = !( matches[ idx ] = matched[i] );
                            						}
                            					}) :
                            					function( elem ) {
                            						return fn( elem, 0, args );
                            					};
                            			}
                            
                            			return fn;
                            		}
                            	},
                            
                            	pseudos: {
                            		// Potentially complex pseudos
                            		&quot;not&quot;: markFunction(function( selector ) {
                            			// Trim the selector passed to compile
                            			// to avoid treating leading and trailing
                            			// spaces as combinators
                            			var input = [],
                            				results = [],
                            				matcher = compile( selector.replace( rtrim, &quot;$1&quot; ) );
                            
                            			return matcher[ expando ] ?
                            				markFunction(function( seed, matches, context, xml ) {
                            					var elem,
                            						unmatched = matcher( seed, null, xml, [] ),
                            						i = seed.length;
                            
                            					// Match elements unmatched by &#x60;matcher&#x60;
                            					while ( i-- ) {
                            						if ( (elem = unmatched[i]) ) {
                            							seed[i] = !(matches[i] = elem);
                            						}
                            					}
                            				}) :
                            				function( elem, context, xml ) {
                            					input[0] = elem;
                            					matcher( input, null, xml, results );
                            					// Don&#x27;t keep the element (issue #299)
                            					input[0] = null;
                            					return !results.pop();
                            				};
                            		}),
                            
                            		&quot;has&quot;: markFunction(function( selector ) {
                            			return function( elem ) {
                            				return Sizzle( selector, elem ).length &gt; 0;
                            			};
                            		}),
                            
                            		&quot;contains&quot;: markFunction(function( text ) {
                            			text = text.replace( runescape, funescape );
                            			return function( elem ) {
                            				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -1;
                            			};
                            		}),
                            
                            		// &quot;Whether an element is represented by a :lang() selector
                            		// is based solely on the element&#x27;s language value
                            		// being equal to the identifier C,
                            		// or beginning with the identifier C immediately followed by &quot;-&quot;.
                            		// The matching of C against the element&#x27;s language value is performed case-insensitively.
                            		// The identifier C does not have to be a valid language name.&quot;
                            		// http://www.w3.org/TR/selectors/#lang-pseudo
                            		&quot;lang&quot;: markFunction( function( lang ) {
                            			// lang value must be a valid identifier
                            			if ( !ridentifier.test(lang || &quot;&quot;) ) {
                            				Sizzle.error( &quot;unsupported lang: &quot; + lang );
                            			}
                            			lang = lang.replace( runescape, funescape ).toLowerCase();
                            			return function( elem ) {
                            				var elemLang;
                            				do {
                            					if ( (elemLang = documentIsHTML ?
                            						elem.lang :
                            						elem.getAttribute(&quot;xml:lang&quot;) || elem.getAttribute(&quot;lang&quot;)) ) {
                            
                            						elemLang = elemLang.toLowerCase();
                            						return elemLang === lang || elemLang.indexOf( lang + &quot;-&quot; ) === 0;
                            					}
                            				} while ( (elem = elem.parentNode) &amp;&amp; elem.nodeType === 1 );
                            				return false;
                            			};
                            		}),
                            
                            		// Miscellaneous
                            		&quot;target&quot;: function( elem ) {
                            			var hash = window.location &amp;&amp; window.location.hash;
                            			return hash &amp;&amp; hash.slice( 1 ) === elem.id;
                            		},
                            
                            		&quot;root&quot;: function( elem ) {
                            			return elem === docElem;
                            		},
                            
                            		&quot;focus&quot;: function( elem ) {
                            			return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
                            		},
                            
                            		// Boolean properties
                            		&quot;enabled&quot;: createDisabledPseudo( false ),
                            		&quot;disabled&quot;: createDisabledPseudo( true ),
                            
                            		&quot;checked&quot;: function( elem ) {
                            			// In CSS3, :checked should return both checked and selected elements
                            			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                            			var nodeName = elem.nodeName.toLowerCase();
                            			return (nodeName === &quot;input&quot; &amp;&amp; !!elem.checked) || (nodeName === &quot;option&quot; &amp;&amp; !!elem.selected);
                            		},
                            
                            		&quot;selected&quot;: function( elem ) {
                            			// Accessing this property makes selected-by-default
                            			// options in Safari work properly
                            			if ( elem.parentNode ) {
                            				elem.parentNode.selectedIndex;
                            			}
                            
                            			return elem.selected === true;
                            		},
                            
                            		// Contents
                            		&quot;empty&quot;: function( elem ) {
                            			// http://www.w3.org/TR/selectors/#empty-pseudo
                            			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                            			//   but not by others (comment: 8; processing instruction: 7; etc.)
                            			// nodeType &lt; 6 works because attributes (2) do not appear as children
                            			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                            				if ( elem.nodeType &lt; 6 ) {
                            					return false;
                            				}
                            			}
                            			return true;
                            		},
                            
                            		&quot;parent&quot;: function( elem ) {
                            			return !Expr.pseudos[&quot;empty&quot;]( elem );
                            		},
                            
                            		// Element/input types
                            		&quot;header&quot;: function( elem ) {
                            			return rheader.test( elem.nodeName );
                            		},
                            
                            		&quot;input&quot;: function( elem ) {
                            			return rinputs.test( elem.nodeName );
                            		},
                            
                            		&quot;button&quot;: function( elem ) {
                            			var name = elem.nodeName.toLowerCase();
                            			return name === &quot;input&quot; &amp;&amp; elem.type === &quot;button&quot; || name === &quot;button&quot;;
                            		},
                            
                            		&quot;text&quot;: function( elem ) {
                            			var attr;
                            			return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp;
                            				elem.type === &quot;text&quot; &amp;&amp;
                            
                            				// Support: IE&lt;8
                            				// New HTML5 attribute values (e.g., &quot;search&quot;) appear with elem.type === &quot;text&quot;
                            				( (attr = elem.getAttribute(&quot;type&quot;)) == null || attr.toLowerCase() === &quot;text&quot; );
                            		},
                            
                            		// Position-in-collection
                            		&quot;first&quot;: createPositionalPseudo(function() {
                            			return [ 0 ];
                            		}),
                            
                            		&quot;last&quot;: createPositionalPseudo(function( matchIndexes, length ) {
                            			return [ length - 1 ];
                            		}),
                            
                            		&quot;eq&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
                            			return [ argument &lt; 0 ? argument + length : argument ];
                            		}),
                            
                            		&quot;even&quot;: createPositionalPseudo(function( matchIndexes, length ) {
                            			var i = 0;
                            			for ( ; i &lt; length; i += 2 ) {
                            				matchIndexes.push( i );
                            			}
                            			return matchIndexes;
                            		}),
                            
                            		&quot;odd&quot;: createPositionalPseudo(function( matchIndexes, length ) {
                            			var i = 1;
                            			for ( ; i &lt; length; i += 2 ) {
                            				matchIndexes.push( i );
                            			}
                            			return matchIndexes;
                            		}),
                            
                            		&quot;lt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
                            			var i = argument &lt; 0 ? argument + length : argument;
                            			for ( ; --i &gt;= 0; ) {
                            				matchIndexes.push( i );
                            			}
                            			return matchIndexes;
                            		}),
                            
                            		&quot;gt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
                            			var i = argument &lt; 0 ? argument + length : argument;
                            			for ( ; ++i &lt; length; ) {
                            				matchIndexes.push( i );
                            			}
                            			return matchIndexes;
                            		})
                            	}
                            };
                            
                            Expr.pseudos[&quot;nth&quot;] = Expr.pseudos[&quot;eq&quot;];
                            
                            // Add button/input type pseudos
                            for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
                            	Expr.pseudos[ i ] = createInputPseudo( i );
                            }
                            for ( i in { submit: true, reset: true } ) {
                            	Expr.pseudos[ i ] = createButtonPseudo( i );
                            }
                            
                            // Easy API for creating new setFilters
                            function setFilters() {}
                            setFilters.prototype = Expr.filters = Expr.pseudos;
                            Expr.setFilters = new setFilters();
                            
                            tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
                            	var matched, match, tokens, type,
                            		soFar, groups, preFilters,
                            		cached = tokenCache[ selector + &quot; &quot; ];
                            
                            	if ( cached ) {
                            		return parseOnly ? 0 : cached.slice( 0 );
                            	}
                            
                            	soFar = selector;
                            	groups = [];
                            	preFilters = Expr.preFilter;
                            
                            	while ( soFar ) {
                            
                            		// Comma and first run
                            		if ( !matched || (match = rcomma.exec( soFar )) ) {
                            			if ( match ) {
                            				// Don&#x27;t consume trailing commas as valid
                            				soFar = soFar.slice( match[0].length ) || soFar;
                            			}
                            			groups.push( (tokens = []) );
                            		}
                            
                            		matched = false;
                            
                            		// Combinators
                            		if ( (match = rcombinators.exec( soFar )) ) {
                            			matched = match.shift();
                            			tokens.push({
                            				value: matched,
                            				// Cast descendant combinators to space
                            				type: match[0].replace( rtrim, &quot; &quot; )
                            			});
                            			soFar = soFar.slice( matched.length );
                            		}
                            
                            		// Filters
                            		for ( type in Expr.filter ) {
                            			if ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||
                            				(match = preFilters[ type ]( match ))) ) {
                            				matched = match.shift();
                            				tokens.push({
                            					value: matched,
                            					type: type,
                            					matches: match
                            				});
                            				soFar = soFar.slice( matched.length );
                            			}
                            		}
                            
                            		if ( !matched ) {
                            			break;
                            		}
                            	}
                            
                            	// Return the length of the invalid excess
                            	// if we&#x27;re just parsing
                            	// Otherwise, throw an error or return tokens
                            	return parseOnly ?
                            		soFar.length :
                            		soFar ?
                            			Sizzle.error( selector ) :
                            			// Cache the tokens
                            			tokenCache( selector, groups ).slice( 0 );
                            };
                            
                            function toSelector( tokens ) {
                            	var i = 0,
                            		len = tokens.length,
                            		selector = &quot;&quot;;
                            	for ( ; i &lt; len; i++ ) {
                            		selector += tokens[i].value;
                            	}
                            	return selector;
                            }
                            
                            function addCombinator( matcher, combinator, base ) {
                            	var dir = combinator.dir,
                            		skip = combinator.next,
                            		key = skip || dir,
                            		checkNonElements = base &amp;&amp; key === &quot;parentNode&quot;,
                            		doneName = done++;
                            
                            	return combinator.first ?
                            		// Check against closest ancestor/preceding element
                            		function( elem, context, xml ) {
                            			while ( (elem = elem[ dir ]) ) {
                            				if ( elem.nodeType === 1 || checkNonElements ) {
                            					return matcher( elem, context, xml );
                            				}
                            			}
                            			return false;
                            		} :
                            
                            		// Check against all ancestor/preceding elements
                            		function( elem, context, xml ) {
                            			var oldCache, uniqueCache, outerCache,
                            				newCache = [ dirruns, doneName ];
                            
                            			// We can&#x27;t set arbitrary data on XML nodes, so they don&#x27;t benefit from combinator caching
                            			if ( xml ) {
                            				while ( (elem = elem[ dir ]) ) {
                            					if ( elem.nodeType === 1 || checkNonElements ) {
                            						if ( matcher( elem, context, xml ) ) {
                            							return true;
                            						}
                            					}
                            				}
                            			} else {
                            				while ( (elem = elem[ dir ]) ) {
                            					if ( elem.nodeType === 1 || checkNonElements ) {
                            						outerCache = elem[ expando ] || (elem[ expando ] = {});
                            
                            						// Support: IE &lt;9 only
                            						// Defend against cloned attroperties (jQuery gh-1709)
                            						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
                            
                            						if ( skip &amp;&amp; skip === elem.nodeName.toLowerCase() ) {
                            							elem = elem[ dir ] || elem;
                            						} else if ( (oldCache = uniqueCache[ key ]) &amp;&amp;
                            							oldCache[ 0 ] === dirruns &amp;&amp; oldCache[ 1 ] === doneName ) {
                            
                            							// Assign to newCache so results back-propagate to previous elements
                            							return (newCache[ 2 ] = oldCache[ 2 ]);
                            						} else {
                            							// Reuse newcache so results back-propagate to previous elements
                            							uniqueCache[ key ] = newCache;
                            
                            							// A match means we&#x27;re done; a fail means we have to keep checking
                            							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                            								return true;
                            							}
                            						}
                            					}
                            				}
                            			}
                            			return false;
                            		};
                            }
                            
                            function elementMatcher( matchers ) {
                            	return matchers.length &gt; 1 ?
                            		function( elem, context, xml ) {
                            			var i = matchers.length;
                            			while ( i-- ) {
                            				if ( !matchers[i]( elem, context, xml ) ) {
                            					return false;
                            				}
                            			}
                            			return true;
                            		} :
                            		matchers[0];
                            }
                            
                            function multipleContexts( selector, contexts, results ) {
                            	var i = 0,
                            		len = contexts.length;
                            	for ( ; i &lt; len; i++ ) {
                            		Sizzle( selector, contexts[i], results );
                            	}
                            	return results;
                            }
                            
                            function condense( unmatched, map, filter, context, xml ) {
                            	var elem,
                            		newUnmatched = [],
                            		i = 0,
                            		len = unmatched.length,
                            		mapped = map != null;
                            
                            	for ( ; i &lt; len; i++ ) {
                            		if ( (elem = unmatched[i]) ) {
                            			if ( !filter || filter( elem, context, xml ) ) {
                            				newUnmatched.push( elem );
                            				if ( mapped ) {
                            					map.push( i );
                            				}
                            			}
                            		}
                            	}
                            
                            	return newUnmatched;
                            }
                            
                            function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
                            	if ( postFilter &amp;&amp; !postFilter[ expando ] ) {
                            		postFilter = setMatcher( postFilter );
                            	}
                            	if ( postFinder &amp;&amp; !postFinder[ expando ] ) {
                            		postFinder = setMatcher( postFinder, postSelector );
                            	}
                            	return markFunction(function( seed, results, context, xml ) {
                            		var temp, i, elem,
                            			preMap = [],
                            			postMap = [],
                            			preexisting = results.length,
                            
                            			// Get initial elements from seed or context
                            			elems = seed || multipleContexts( selector || &quot;*&quot;, context.nodeType ? [ context ] : context, [] ),
                            
                            			// Prefilter to get matcher input, preserving a map for seed-results synchronization
                            			matcherIn = preFilter &amp;&amp; ( seed || !selector ) ?
                            				condense( elems, preMap, preFilter, context, xml ) :
                            				elems,
                            
                            			matcherOut = matcher ?
                            				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                            				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
                            
                            					// ...intermediate processing is necessary
                            					[] :
                            
                            					// ...otherwise use results directly
                            					results :
                            				matcherIn;
                            
                            		// Find primary matches
                            		if ( matcher ) {
                            			matcher( matcherIn, matcherOut, context, xml );
                            		}
                            
                            		// Apply postFilter
                            		if ( postFilter ) {
                            			temp = condense( matcherOut, postMap );
                            			postFilter( temp, [], context, xml );
                            
                            			// Un-match failing elements by moving them back to matcherIn
                            			i = temp.length;
                            			while ( i-- ) {
                            				if ( (elem = temp[i]) ) {
                            					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                            				}
                            			}
                            		}
                            
                            		if ( seed ) {
                            			if ( postFinder || preFilter ) {
                            				if ( postFinder ) {
                            					// Get the final matcherOut by condensing this intermediate into postFinder contexts
                            					temp = [];
                            					i = matcherOut.length;
                            					while ( i-- ) {
                            						if ( (elem = matcherOut[i]) ) {
                            							// Restore matcherIn since elem is not yet a final match
                            							temp.push( (matcherIn[i] = elem) );
                            						}
                            					}
                            					postFinder( null, (matcherOut = []), temp, xml );
                            				}
                            
                            				// Move matched elements from seed to results to keep them synchronized
                            				i = matcherOut.length;
                            				while ( i-- ) {
                            					if ( (elem = matcherOut[i]) &amp;&amp;
                            						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) &gt; -1 ) {
                            
                            						seed[temp] = !(results[temp] = elem);
                            					}
                            				}
                            			}
                            
                            		// Add elements to results, through postFinder if defined
                            		} else {
                            			matcherOut = condense(
                            				matcherOut === results ?
                            					matcherOut.splice( preexisting, matcherOut.length ) :
                            					matcherOut
                            			);
                            			if ( postFinder ) {
                            				postFinder( null, results, matcherOut, xml );
                            			} else {
                            				push.apply( results, matcherOut );
                            			}
                            		}
                            	});
                            }
                            
                            function matcherFromTokens( tokens ) {
                            	var checkContext, matcher, j,
                            		len = tokens.length,
                            		leadingRelative = Expr.relative[ tokens[0].type ],
                            		implicitRelative = leadingRelative || Expr.relative[&quot; &quot;],
                            		i = leadingRelative ? 1 : 0,
                            
                            		// The foundational matcher ensures that elements are reachable from top-level context(s)
                            		matchContext = addCombinator( function( elem ) {
                            			return elem === checkContext;
                            		}, implicitRelative, true ),
                            		matchAnyContext = addCombinator( function( elem ) {
                            			return indexOf( checkContext, elem ) &gt; -1;
                            		}, implicitRelative, true ),
                            		matchers = [ function( elem, context, xml ) {
                            			var ret = ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || (
                            				(checkContext = context).nodeType ?
                            					matchContext( elem, context, xml ) :
                            					matchAnyContext( elem, context, xml ) );
                            			// Avoid hanging onto element (issue #299)
                            			checkContext = null;
                            			return ret;
                            		} ];
                            
                            	for ( ; i &lt; len; i++ ) {
                            		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
                            			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
                            		} else {
                            			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
                            
                            			// Return special upon seeing a positional matcher
                            			if ( matcher[ expando ] ) {
                            				// Find the next relative operator (if any) for proper handling
                            				j = ++i;
                            				for ( ; j &lt; len; j++ ) {
                            					if ( Expr.relative[ tokens[j].type ] ) {
                            						break;
                            					}
                            				}
                            				return setMatcher(
                            					i &gt; 1 &amp;&amp; elementMatcher( matchers ),
                            					i &gt; 1 &amp;&amp; toSelector(
                            						// If the preceding token was a descendant combinator, insert an implicit any-element &#x60;*&#x60;
                            						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === &quot; &quot; ? &quot;*&quot; : &quot;&quot; })
                            					).replace( rtrim, &quot;$1&quot; ),
                            					matcher,
                            					i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),
                            					j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ),
                            					j &lt; len &amp;&amp; toSelector( tokens )
                            				);
                            			}
                            			matchers.push( matcher );
                            		}
                            	}
                            
                            	return elementMatcher( matchers );
                            }
                            
                            function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
                            	var bySet = setMatchers.length &gt; 0,
                            		byElement = elementMatchers.length &gt; 0,
                            		superMatcher = function( seed, context, xml, results, outermost ) {
                            			var elem, j, matcher,
                            				matchedCount = 0,
                            				i = &quot;0&quot;,
                            				unmatched = seed &amp;&amp; [],
                            				setMatched = [],
                            				contextBackup = outermostContext,
                            				// We must always have either seed elements or outermost context
                            				elems = seed || byElement &amp;&amp; Expr.find[&quot;TAG&quot;]( &quot;*&quot;, outermost ),
                            				// Use integer dirruns iff this is the outermost matcher
                            				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                            				len = elems.length;
                            
                            			if ( outermost ) {
                            				outermostContext = context === document || context || outermost;
                            			}
                            
                            			// Add elements passing elementMatchers directly to results
                            			// Support: IE&lt;9, Safari
                            			// Tolerate NodeList properties (IE: &quot;length&quot;; Safari: &lt;number&gt;) matching elements by id
                            			for ( ; i !== len &amp;&amp; (elem = elems[i]) != null; i++ ) {
                            				if ( byElement &amp;&amp; elem ) {
                            					j = 0;
                            					if ( !context &amp;&amp; elem.ownerDocument !== document ) {
                            						setDocument( elem );
                            						xml = !documentIsHTML;
                            					}
                            					while ( (matcher = elementMatchers[j++]) ) {
                            						if ( matcher( elem, context || document, xml) ) {
                            							results.push( elem );
                            							break;
                            						}
                            					}
                            					if ( outermost ) {
                            						dirruns = dirrunsUnique;
                            					}
                            				}
                            
                            				// Track unmatched elements for set filters
                            				if ( bySet ) {
                            					// They will have gone through all possible matchers
                            					if ( (elem = !matcher &amp;&amp; elem) ) {
                            						matchedCount--;
                            					}
                            
                            					// Lengthen the array for every element, matched or not
                            					if ( seed ) {
                            						unmatched.push( elem );
                            					}
                            				}
                            			}
                            
                            			// &#x60;i&#x60; is now the count of elements visited above, and adding it to &#x60;matchedCount&#x60;
                            			// makes the latter nonnegative.
                            			matchedCount += i;
                            
                            			// Apply set filters to unmatched elements
                            			// NOTE: This can be skipped if there are no unmatched elements (i.e., &#x60;matchedCount&#x60;
                            			// equals &#x60;i&#x60;), unless we didn&#x27;t visit _any_ elements in the above loop because we have
                            			// no element matchers and no seed.
                            			// Incrementing an initially-string &quot;0&quot; &#x60;i&#x60; allows &#x60;i&#x60; to remain a string only in that
                            			// case, which will result in a &quot;00&quot; &#x60;matchedCount&#x60; that differs from &#x60;i&#x60; but is also
                            			// numerically zero.
                            			if ( bySet &amp;&amp; i !== matchedCount ) {
                            				j = 0;
                            				while ( (matcher = setMatchers[j++]) ) {
                            					matcher( unmatched, setMatched, context, xml );
                            				}
                            
                            				if ( seed ) {
                            					// Reintegrate element matches to eliminate the need for sorting
                            					if ( matchedCount &gt; 0 ) {
                            						while ( i-- ) {
                            							if ( !(unmatched[i] || setMatched[i]) ) {
                            								setMatched[i] = pop.call( results );
                            							}
                            						}
                            					}
                            
                            					// Discard index placeholder values to get only actual matches
                            					setMatched = condense( setMatched );
                            				}
                            
                            				// Add matches to results
                            				push.apply( results, setMatched );
                            
                            				// Seedless set matches succeeding multiple successful matchers stipulate sorting
                            				if ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;
                            					( matchedCount + setMatchers.length ) &gt; 1 ) {
                            
                            					Sizzle.uniqueSort( results );
                            				}
                            			}
                            
                            			// Override manipulation of globals by nested matchers
                            			if ( outermost ) {
                            				dirruns = dirrunsUnique;
                            				outermostContext = contextBackup;
                            			}
                            
                            			return unmatched;
                            		};
                            
                            	return bySet ?
                            		markFunction( superMatcher ) :
                            		superMatcher;
                            }
                            
                            compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
                            	var i,
                            		setMatchers = [],
                            		elementMatchers = [],
                            		cached = compilerCache[ selector + &quot; &quot; ];
                            
                            	if ( !cached ) {
                            		// Generate a function of recursive functions that can be used to check each element
                            		if ( !match ) {
                            			match = tokenize( selector );
                            		}
                            		i = match.length;
                            		while ( i-- ) {
                            			cached = matcherFromTokens( match[i] );
                            			if ( cached[ expando ] ) {
                            				setMatchers.push( cached );
                            			} else {
                            				elementMatchers.push( cached );
                            			}
                            		}
                            
                            		// Cache the compiled function
                            		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
                            
                            		// Save selector and tokenization
                            		cached.selector = selector;
                            	}
                            	return cached;
                            };
                            
                            /**
                             * A low-level selection function that works with Sizzle&#x27;s compiled
                             *  selector functions
                             * @param {String|Function} selector A selector or a pre-compiled
                             *  selector function built with Sizzle.compile
                             * @param {Element} context
                             * @param {Array} [results]
                             * @param {Array} [seed] A set of elements to match against
                             */
                            select = Sizzle.select = function( selector, context, results, seed ) {
                            	var i, tokens, token, type, find,
                            		compiled = typeof selector === &quot;function&quot; &amp;&amp; selector,
                            		match = !seed &amp;&amp; tokenize( (selector = compiled.selector || selector) );
                            
                            	results = results || [];
                            
                            	// Try to minimize operations if there is only one selector in the list and no seed
                            	// (the latter of which guarantees us context)
                            	if ( match.length === 1 ) {
                            
                            		// Reduce context if the leading compound selector is an ID
                            		tokens = match[0] = match[0].slice( 0 );
                            		if ( tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === &quot;ID&quot; &amp;&amp;
                            				context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp; Expr.relative[ tokens[1].type ] ) {
                            
                            			context = ( Expr.find[&quot;ID&quot;]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
                            			if ( !context ) {
                            				return results;
                            
                            			// Precompiled matchers will still verify ancestry, so step up a level
                            			} else if ( compiled ) {
                            				context = context.parentNode;
                            			}
                            
                            			selector = selector.slice( tokens.shift().value.length );
                            		}
                            
                            		// Fetch a seed set for right-to-left matching
                            		i = matchExpr[&quot;needsContext&quot;].test( selector ) ? 0 : tokens.length;
                            		while ( i-- ) {
                            			token = tokens[i];
                            
                            			// Abort if we hit a combinator
                            			if ( Expr.relative[ (type = token.type) ] ) {
                            				break;
                            			}
                            			if ( (find = Expr.find[ type ]) ) {
                            				// Search, expanding context for leading sibling combinators
                            				if ( (seed = find(
                            					token.matches[0].replace( runescape, funescape ),
                            					rsibling.test( tokens[0].type ) &amp;&amp; testContext( context.parentNode ) || context
                            				)) ) {
                            
                            					// If seed is empty or no tokens remain, we can return early
                            					tokens.splice( i, 1 );
                            					selector = seed.length &amp;&amp; toSelector( tokens );
                            					if ( !selector ) {
                            						push.apply( results, seed );
                            						return results;
                            					}
                            
                            					break;
                            				}
                            			}
                            		}
                            	}
                            
                            	// Compile and execute a filtering function if one is not provided
                            	// Provide &#x60;match&#x60; to avoid retokenization if we modified the selector above
                            	( compiled || compile( selector, match ) )(
                            		seed,
                            		context,
                            		!documentIsHTML,
                            		results,
                            		!context || rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context
                            	);
                            	return results;
                            };
                            
                            // One-time assignments
                            
                            // Sort stability
                            support.sortStable = expando.split(&quot;&quot;).sort( sortOrder ).join(&quot;&quot;) === expando;
                            
                            // Support: Chrome 14-35+
                            // Always assume duplicates if they aren&#x27;t passed to the comparison function
                            support.detectDuplicates = !!hasDuplicate;
                            
                            // Initialize against the default document
                            setDocument();
                            
                            // Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                            // Detached nodes confoundingly follow *each other*
                            support.sortDetached = assert(function( el ) {
                            	// Should return 1, but returns 4 (following)
                            	return el.compareDocumentPosition( document.createElement(&quot;fieldset&quot;) ) &amp; 1;
                            });
                            
                            // Support: IE&lt;8
                            // Prevent attribute/property &quot;interpolation&quot;
                            // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                            if ( !assert(function( el ) {
                            	el.innerHTML = &quot;&lt;a href=&#x27;#&#x27;&gt;&lt;/a&gt;&quot;;
                            	return el.firstChild.getAttribute(&quot;href&quot;) === &quot;#&quot; ;
                            }) ) {
                            	addHandle( &quot;type|href|height|width&quot;, function( elem, name, isXML ) {
                            		if ( !isXML ) {
                            			return elem.getAttribute( name, name.toLowerCase() === &quot;type&quot; ? 1 : 2 );
                            		}
                            	});
                            }
                            
                            // Support: IE&lt;9
                            // Use defaultValue in place of getAttribute(&quot;value&quot;)
                            if ( !support.attributes || !assert(function( el ) {
                            	el.innerHTML = &quot;&lt;input/&gt;&quot;;
                            	el.firstChild.setAttribute( &quot;value&quot;, &quot;&quot; );
                            	return el.firstChild.getAttribute( &quot;value&quot; ) === &quot;&quot;;
                            }) ) {
                            	addHandle( &quot;value&quot;, function( elem, name, isXML ) {
                            		if ( !isXML &amp;&amp; elem.nodeName.toLowerCase() === &quot;input&quot; ) {
                            			return elem.defaultValue;
                            		}
                            	});
                            }
                            
                            // Support: IE&lt;9
                            // Use getAttributeNode to fetch booleans when getAttribute lies
                            if ( !assert(function( el ) {
                            	return el.getAttribute(&quot;disabled&quot;) == null;
                            }) ) {
                            	addHandle( booleans, function( elem, name, isXML ) {
                            		var val;
                            		if ( !isXML ) {
                            			return elem[ name ] === true ? name.toLowerCase() :
                            					(val = elem.getAttributeNode( name )) &amp;&amp; val.specified ?
                            					val.value :
                            				null;
                            		}
                            	});
                            }
                            
                            return Sizzle;
                            
                            })( window );
                            
                            
                            
                            jQuery.find = Sizzle;
                            jQuery.expr = Sizzle.selectors;
                            
                            // Deprecated
                            jQuery.expr[ &quot;:&quot; ] = jQuery.expr.pseudos;
                            jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
                            jQuery.text = Sizzle.getText;
                            jQuery.isXMLDoc = Sizzle.isXML;
                            jQuery.contains = Sizzle.contains;
                            jQuery.escapeSelector = Sizzle.escape;
                            
                            
                            
                            
                            var dir = function( elem, dir, until ) {
                            	var matched = [],
                            		truncate = until !== undefined;
                            
                            	while ( ( elem = elem[ dir ] ) &amp;&amp; elem.nodeType !== 9 ) {
                            		if ( elem.nodeType === 1 ) {
                            			if ( truncate &amp;&amp; jQuery( elem ).is( until ) ) {
                            				break;
                            			}
                            			matched.push( elem );
                            		}
                            	}
                            	return matched;
                            };
                            
                            
                            var siblings = function( n, elem ) {
                            	var matched = [];
                            
                            	for ( ; n; n = n.nextSibling ) {
                            		if ( n.nodeType === 1 &amp;&amp; n !== elem ) {
                            			matched.push( n );
                            		}
                            	}
                            
                            	return matched;
                            };
                            
                            
                            var rneedsContext = jQuery.expr.match.needsContext;
                            
                            
                            
                            function nodeName( elem, name ) {
                            
                              return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();
                            
                            };
                            var rsingleTag = ( /^&lt;([a-z][^\/\0&gt;:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?&gt;(?:&lt;\/\1&gt;|)$/i );
                            
                            
                            
                            var risSimple = /^.[^:#\[\.,]*$/;
                            
                            // Implement the identical functionality for filter and not
                            function winnow( elements, qualifier, not ) {
                            	if ( jQuery.isFunction( qualifier ) ) {
                            		return jQuery.grep( elements, function( elem, i ) {
                            			return !!qualifier.call( elem, i, elem ) !== not;
                            		} );
                            	}
                            
                            	// Single element
                            	if ( qualifier.nodeType ) {
                            		return jQuery.grep( elements, function( elem ) {
                            			return ( elem === qualifier ) !== not;
                            		} );
                            	}
                            
                            	// Arraylike of elements (jQuery, arguments, Array)
                            	if ( typeof qualifier !== &quot;string&quot; ) {
                            		return jQuery.grep( elements, function( elem ) {
                            			return ( indexOf.call( qualifier, elem ) &gt; -1 ) !== not;
                            		} );
                            	}
                            
                            	// Simple selector that can be filtered directly, removing non-Elements
                            	if ( risSimple.test( qualifier ) ) {
                            		return jQuery.filter( qualifier, elements, not );
                            	}
                            
                            	// Complex selector, compare the two sets, removing non-Elements
                            	qualifier = jQuery.filter( qualifier, elements );
                            	return jQuery.grep( elements, function( elem ) {
                            		return ( indexOf.call( qualifier, elem ) &gt; -1 ) !== not &amp;&amp; elem.nodeType === 1;
                            	} );
                            }
                            
                            jQuery.filter = function( expr, elems, not ) {
                            	var elem = elems[ 0 ];
                            
                            	if ( not ) {
                            		expr = &quot;:not(&quot; + expr + &quot;)&quot;;
                            	}
                            
                            	if ( elems.length === 1 &amp;&amp; elem.nodeType === 1 ) {
                            		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
                            	}
                            
                            	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
                            		return elem.nodeType === 1;
                            	} ) );
                            };
                            
                            jQuery.fn.extend( {
                            	find: function( selector ) {
                            		var i, ret,
                            			len = this.length,
                            			self = this;
                            
                            		if ( typeof selector !== &quot;string&quot; ) {
                            			return this.pushStack( jQuery( selector ).filter( function() {
                            				for ( i = 0; i &lt; len; i++ ) {
                            					if ( jQuery.contains( self[ i ], this ) ) {
                            						return true;
                            					}
                            				}
                            			} ) );
                            		}
                            
                            		ret = this.pushStack( [] );
                            
                            		for ( i = 0; i &lt; len; i++ ) {
                            			jQuery.find( selector, self[ i ], ret );
                            		}
                            
                            		return len &gt; 1 ? jQuery.uniqueSort( ret ) : ret;
                            	},
                            	filter: function( selector ) {
                            		return this.pushStack( winnow( this, selector || [], false ) );
                            	},
                            	not: function( selector ) {
                            		return this.pushStack( winnow( this, selector || [], true ) );
                            	},
                            	is: function( selector ) {
                            		return !!winnow(
                            			this,
                            
                            			// If this is a positional/relative selector, check membership in the returned set
                            			// so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won&#x27;t return true for a doc with two &quot;p&quot;.
                            			typeof selector === &quot;string&quot; &amp;&amp; rneedsContext.test( selector ) ?
                            				jQuery( selector ) :
                            				selector || [],
                            			false
                            		).length;
                            	}
                            } );
                            
                            
                            // Initialize a jQuery object
                            
                            
                            // A central reference to the root jQuery(document)
                            var rootjQuery,
                            
                            	// A simple way to check for HTML strings
                            	// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)
                            	// Strict HTML recognition (#11290: must start with &lt;)
                            	// Shortcut simple #id case for speed
                            	rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]+))$/,
                            
                            	init = jQuery.fn.init = function( selector, context, root ) {
                            		var match, elem;
                            
                            		// HANDLE: $(&quot;&quot;), $(null), $(undefined), $(false)
                            		if ( !selector ) {
                            			return this;
                            		}
                            
                            		// Method init() accepts an alternate rootjQuery
                            		// so migrate can support jQuery.sub (gh-2101)
                            		root = root || rootjQuery;
                            
                            		// Handle HTML strings
                            		if ( typeof selector === &quot;string&quot; ) {
                            			if ( selector[ 0 ] === &quot;&lt;&quot; &amp;&amp;
                            				selector[ selector.length - 1 ] === &quot;&gt;&quot; &amp;&amp;
                            				selector.length &gt;= 3 ) {
                            
                            				// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check
                            				match = [ null, selector, null ];
                            
                            			} else {
                            				match = rquickExpr.exec( selector );
                            			}
                            
                            			// Match html or make sure no context is specified for #id
                            			if ( match &amp;&amp; ( match[ 1 ] || !context ) ) {
                            
                            				// HANDLE: $(html) -&gt; $(array)
                            				if ( match[ 1 ] ) {
                            					context = context instanceof jQuery ? context[ 0 ] : context;
                            
                            					// Option to run scripts is true for back-compat
                            					// Intentionally let the error be thrown if parseHTML is not present
                            					jQuery.merge( this, jQuery.parseHTML(
                            						match[ 1 ],
                            						context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,
                            						true
                            					) );
                            
                            					// HANDLE: $(html, props)
                            					if ( rsingleTag.test( match[ 1 ] ) &amp;&amp; jQuery.isPlainObject( context ) ) {
                            						for ( match in context ) {
                            
                            							// Properties of context are called as methods if possible
                            							if ( jQuery.isFunction( this[ match ] ) ) {
                            								this[ match ]( context[ match ] );
                            
                            							// ...and otherwise set as attributes
                            							} else {
                            								this.attr( match, context[ match ] );
                            							}
                            						}
                            					}
                            
                            					return this;
                            
                            				// HANDLE: $(#id)
                            				} else {
                            					elem = document.getElementById( match[ 2 ] );
                            
                            					if ( elem ) {
                            
                            						// Inject the element directly into the jQuery object
                            						this[ 0 ] = elem;
                            						this.length = 1;
                            					}
                            					return this;
                            				}
                            
                            			// HANDLE: $(expr, $(...))
                            			} else if ( !context || context.jquery ) {
                            				return ( context || root ).find( selector );
                            
                            			// HANDLE: $(expr, context)
                            			// (which is just equivalent to: $(context).find(expr)
                            			} else {
                            				return this.constructor( context ).find( selector );
                            			}
                            
                            		// HANDLE: $(DOMElement)
                            		} else if ( selector.nodeType ) {
                            			this[ 0 ] = selector;
                            			this.length = 1;
                            			return this;
                            
                            		// HANDLE: $(function)
                            		// Shortcut for document ready
                            		} else if ( jQuery.isFunction( selector ) ) {
                            			return root.ready !== undefined ?
                            				root.ready( selector ) :
                            
                            				// Execute immediately if ready is not present
                            				selector( jQuery );
                            		}
                            
                            		return jQuery.makeArray( selector, this );
                            	};
                            
                            // Give the init function the jQuery prototype for later instantiation
                            init.prototype = jQuery.fn;
                            
                            // Initialize central reference
                            rootjQuery = jQuery( document );
                            
                            
                            var rparentsprev = /^(?:parents|prev(?:Until|All))/,
                            
                            	// Methods guaranteed to produce a unique set when starting from a unique set
                            	guaranteedUnique = {
                            		children: true,
                            		contents: true,
                            		next: true,
                            		prev: true
                            	};
                            
                            jQuery.fn.extend( {
                            	has: function( target ) {
                            		var targets = jQuery( target, this ),
                            			l = targets.length;
                            
                            		return this.filter( function() {
                            			var i = 0;
                            			for ( ; i &lt; l; i++ ) {
                            				if ( jQuery.contains( this, targets[ i ] ) ) {
                            					return true;
                            				}
                            			}
                            		} );
                            	},
                            
                            	closest: function( selectors, context ) {
                            		var cur,
                            			i = 0,
                            			l = this.length,
                            			matched = [],
                            			targets = typeof selectors !== &quot;string&quot; &amp;&amp; jQuery( selectors );
                            
                            		// Positional selectors never match, since there&#x27;s no _selection_ context
                            		if ( !rneedsContext.test( selectors ) ) {
                            			for ( ; i &lt; l; i++ ) {
                            				for ( cur = this[ i ]; cur &amp;&amp; cur !== context; cur = cur.parentNode ) {
                            
                            					// Always skip document fragments
                            					if ( cur.nodeType &lt; 11 &amp;&amp; ( targets ?
                            						targets.index( cur ) &gt; -1 :
                            
                            						// Don&#x27;t pass non-elements to Sizzle
                            						cur.nodeType === 1 &amp;&amp;
                            							jQuery.find.matchesSelector( cur, selectors ) ) ) {
                            
                            						matched.push( cur );
                            						break;
                            					}
                            				}
                            			}
                            		}
                            
                            		return this.pushStack( matched.length &gt; 1 ? jQuery.uniqueSort( matched ) : matched );
                            	},
                            
                            	// Determine the position of an element within the set
                            	index: function( elem ) {
                            
                            		// No argument, return index in parent
                            		if ( !elem ) {
                            			return ( this[ 0 ] &amp;&amp; this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
                            		}
                            
                            		// Index in selector
                            		if ( typeof elem === &quot;string&quot; ) {
                            			return indexOf.call( jQuery( elem ), this[ 0 ] );
                            		}
                            
                            		// Locate the position of the desired element
                            		return indexOf.call( this,
                            
                            			// If it receives a jQuery object, the first element is used
                            			elem.jquery ? elem[ 0 ] : elem
                            		);
                            	},
                            
                            	add: function( selector, context ) {
                            		return this.pushStack(
                            			jQuery.uniqueSort(
                            				jQuery.merge( this.get(), jQuery( selector, context ) )
                            			)
                            		);
                            	},
                            
                            	addBack: function( selector ) {
                            		return this.add( selector == null ?
                            			this.prevObject : this.prevObject.filter( selector )
                            		);
                            	}
                            } );
                            
                            function sibling( cur, dir ) {
                            	while ( ( cur = cur[ dir ] ) &amp;&amp; cur.nodeType !== 1 ) {}
                            	return cur;
                            }
                            
                            jQuery.each( {
                            	parent: function( elem ) {
                            		var parent = elem.parentNode;
                            		return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;
                            	},
                            	parents: function( elem ) {
                            		return dir( elem, &quot;parentNode&quot; );
                            	},
                            	parentsUntil: function( elem, i, until ) {
                            		return dir( elem, &quot;parentNode&quot;, until );
                            	},
                            	next: function( elem ) {
                            		return sibling( elem, &quot;nextSibling&quot; );
                            	},
                            	prev: function( elem ) {
                            		return sibling( elem, &quot;previousSibling&quot; );
                            	},
                            	nextAll: function( elem ) {
                            		return dir( elem, &quot;nextSibling&quot; );
                            	},
                            	prevAll: function( elem ) {
                            		return dir( elem, &quot;previousSibling&quot; );
                            	},
                            	nextUntil: function( elem, i, until ) {
                            		return dir( elem, &quot;nextSibling&quot;, until );
                            	},
                            	prevUntil: function( elem, i, until ) {
                            		return dir( elem, &quot;previousSibling&quot;, until );
                            	},
                            	siblings: function( elem ) {
                            		return siblings( ( elem.parentNode || {} ).firstChild, elem );
                            	},
                            	children: function( elem ) {
                            		return siblings( elem.firstChild );
                            	},
                            	contents: function( elem ) {
                                    if ( nodeName( elem, &quot;iframe&quot; ) ) {
                                        return elem.contentDocument;
                                    }
                            
                                    // Support: IE 9 - 11 only, iOS 7 only, Android Browser &lt;=4.3 only
                                    // Treat the template element as a regular one in browsers that
                                    // don&#x27;t support it.
                                    if ( nodeName( elem, &quot;template&quot; ) ) {
                                        elem = elem.content || elem;
                                    }
                            
                                    return jQuery.merge( [], elem.childNodes );
                            	}
                            }, function( name, fn ) {
                            	jQuery.fn[ name ] = function( until, selector ) {
                            		var matched = jQuery.map( this, fn, until );
                            
                            		if ( name.slice( -5 ) !== &quot;Until&quot; ) {
                            			selector = until;
                            		}
                            
                            		if ( selector &amp;&amp; typeof selector === &quot;string&quot; ) {
                            			matched = jQuery.filter( selector, matched );
                            		}
                            
                            		if ( this.length &gt; 1 ) {
                            
                            			// Remove duplicates
                            			if ( !guaranteedUnique[ name ] ) {
                            				jQuery.uniqueSort( matched );
                            			}
                            
                            			// Reverse order for parents* and prev-derivatives
                            			if ( rparentsprev.test( name ) ) {
                            				matched.reverse();
                            			}
                            		}
                            
                            		return this.pushStack( matched );
                            	};
                            } );
                            var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );
                            
                            
                            
                            // Convert String-formatted options into Object-formatted ones
                            function createOptions( options ) {
                            	var object = {};
                            	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
                            		object[ flag ] = true;
                            	} );
                            	return object;
                            }
                            
                            /*
                             * Create a callback list using the following parameters:
                             *
                             *	options: an optional list of space-separated options that will change how
                             *			the callback list behaves or a more traditional option object
                             *
                             * By default a callback list will act like an event callback list and can be
                             * &quot;fired&quot; multiple times.
                             *
                             * Possible options:
                             *
                             *	once:			will ensure the callback list can only be fired once (like a Deferred)
                             *
                             *	memory:			will keep track of previous values and will call any callback added
                             *					after the list has been fired right away with the latest &quot;memorized&quot;
                             *					values (like a Deferred)
                             *
                             *	unique:			will ensure a callback can only be added once (no duplicate in the list)
                             *
                             *	stopOnFalse:	interrupt callings when a callback returns false
                             *
                             */
                            jQuery.Callbacks = function( options ) {
                            
                            	// Convert options from String-formatted to Object-formatted if needed
                            	// (we check in cache first)
                            	options = typeof options === &quot;string&quot; ?
                            		createOptions( options ) :
                            		jQuery.extend( {}, options );
                            
                            	var // Flag to know if list is currently firing
                            		firing,
                            
                            		// Last fire value for non-forgettable lists
                            		memory,
                            
                            		// Flag to know if list was already fired
                            		fired,
                            
                            		// Flag to prevent firing
                            		locked,
                            
                            		// Actual callback list
                            		list = [],
                            
                            		// Queue of execution data for repeatable lists
                            		queue = [],
                            
                            		// Index of currently firing callback (modified by add/remove as needed)
                            		firingIndex = -1,
                            
                            		// Fire callbacks
                            		fire = function() {
                            
                            			// Enforce single-firing
                            			locked = locked || options.once;
                            
                            			// Execute callbacks for all pending executions,
                            			// respecting firingIndex overrides and runtime changes
                            			fired = firing = true;
                            			for ( ; queue.length; firingIndex = -1 ) {
                            				memory = queue.shift();
                            				while ( ++firingIndex &lt; list.length ) {
                            
                            					// Run callback and check for early termination
                            					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &amp;&amp;
                            						options.stopOnFalse ) {
                            
                            						// Jump to end and forget the data so .add doesn&#x27;t re-fire
                            						firingIndex = list.length;
                            						memory = false;
                            					}
                            				}
                            			}
                            
                            			// Forget the data if we&#x27;re done with it
                            			if ( !options.memory ) {
                            				memory = false;
                            			}
                            
                            			firing = false;
                            
                            			// Clean up if we&#x27;re done firing for good
                            			if ( locked ) {
                            
                            				// Keep an empty list if we have data for future add calls
                            				if ( memory ) {
                            					list = [];
                            
                            				// Otherwise, this object is spent
                            				} else {
                            					list = &quot;&quot;;
                            				}
                            			}
                            		},
                            
                            		// Actual Callbacks object
                            		self = {
                            
                            			// Add a callback or a collection of callbacks to the list
                            			add: function() {
                            				if ( list ) {
                            
                            					// If we have memory from a past run, we should fire after adding
                            					if ( memory &amp;&amp; !firing ) {
                            						firingIndex = list.length - 1;
                            						queue.push( memory );
                            					}
                            
                            					( function add( args ) {
                            						jQuery.each( args, function( _, arg ) {
                            							if ( jQuery.isFunction( arg ) ) {
                            								if ( !options.unique || !self.has( arg ) ) {
                            									list.push( arg );
                            								}
                            							} else if ( arg &amp;&amp; arg.length &amp;&amp; jQuery.type( arg ) !== &quot;string&quot; ) {
                            
                            								// Inspect recursively
                            								add( arg );
                            							}
                            						} );
                            					} )( arguments );
                            
                            					if ( memory &amp;&amp; !firing ) {
                            						fire();
                            					}
                            				}
                            				return this;
                            			},
                            
                            			// Remove a callback from the list
                            			remove: function() {
                            				jQuery.each( arguments, function( _, arg ) {
                            					var index;
                            					while ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) {
                            						list.splice( index, 1 );
                            
                            						// Handle firing indexes
                            						if ( index &lt;= firingIndex ) {
                            							firingIndex--;
                            						}
                            					}
                            				} );
                            				return this;
                            			},
                            
                            			// Check if a given callback is in the list.
                            			// If no argument is given, return whether or not list has callbacks attached.
                            			has: function( fn ) {
                            				return fn ?
                            					jQuery.inArray( fn, list ) &gt; -1 :
                            					list.length &gt; 0;
                            			},
                            
                            			// Remove all callbacks from the list
                            			empty: function() {
                            				if ( list ) {
                            					list = [];
                            				}
                            				return this;
                            			},
                            
                            			// Disable .fire and .add
                            			// Abort any current/pending executions
                            			// Clear all callbacks and values
                            			disable: function() {
                            				locked = queue = [];
                            				list = memory = &quot;&quot;;
                            				return this;
                            			},
                            			disabled: function() {
                            				return !list;
                            			},
                            
                            			// Disable .fire
                            			// Also disable .add unless we have memory (since it would have no effect)
                            			// Abort any pending executions
                            			lock: function() {
                            				locked = queue = [];
                            				if ( !memory &amp;&amp; !firing ) {
                            					list = memory = &quot;&quot;;
                            				}
                            				return this;
                            			},
                            			locked: function() {
                            				return !!locked;
                            			},
                            
                            			// Call all callbacks with the given context and arguments
                            			fireWith: function( context, args ) {
                            				if ( !locked ) {
                            					args = args || [];
                            					args = [ context, args.slice ? args.slice() : args ];
                            					queue.push( args );
                            					if ( !firing ) {
                            						fire();
                            					}
                            				}
                            				return this;
                            			},
                            
                            			// Call all the callbacks with the given arguments
                            			fire: function() {
                            				self.fireWith( this, arguments );
                            				return this;
                            			},
                            
                            			// To know if the callbacks have already been called at least once
                            			fired: function() {
                            				return !!fired;
                            			}
                            		};
                            
                            	return self;
                            };
                            
                            
                            function Identity( v ) {
                            	return v;
                            }
                            function Thrower( ex ) {
                            	throw ex;
                            }
                            
                            function adoptValue( value, resolve, reject, noValue ) {
                            	var method;
                            
                            	try {
                            
                            		// Check for promise aspect first to privilege synchronous behavior
                            		if ( value &amp;&amp; jQuery.isFunction( ( method = value.promise ) ) ) {
                            			method.call( value ).done( resolve ).fail( reject );
                            
                            		// Other thenables
                            		} else if ( value &amp;&amp; jQuery.isFunction( ( method = value.then ) ) ) {
                            			method.call( value, resolve, reject );
                            
                            		// Other non-thenables
                            		} else {
                            
                            			// Control &#x60;resolve&#x60; arguments by letting Array#slice cast boolean &#x60;noValue&#x60; to integer:
                            			// * false: [ value ].slice( 0 ) =&gt; resolve( value )
                            			// * true: [ value ].slice( 1 ) =&gt; resolve()
                            			resolve.apply( undefined, [ value ].slice( noValue ) );
                            		}
                            
                            	// For Promises/A+, convert exceptions into rejections
                            	// Since jQuery.when doesn&#x27;t unwrap thenables, we can skip the extra checks appearing in
                            	// Deferred#then to conditionally suppress rejection.
                            	} catch ( value ) {
                            
                            		// Support: Android 4.0 only
                            		// Strict mode functions invoked without .call/.apply get global-object context
                            		reject.apply( undefined, [ value ] );
                            	}
                            }
                            
                            jQuery.extend( {
                            
                            	Deferred: function( func ) {
                            		var tuples = [
                            
                            				// action, add listener, callbacks,
                            				// ... .then handlers, argument index, [final state]
                            				[ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks( &quot;memory&quot; ),
                            					jQuery.Callbacks( &quot;memory&quot; ), 2 ],
                            				[ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks( &quot;once memory&quot; ),
                            					jQuery.Callbacks( &quot;once memory&quot; ), 0, &quot;resolved&quot; ],
                            				[ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks( &quot;once memory&quot; ),
                            					jQuery.Callbacks( &quot;once memory&quot; ), 1, &quot;rejected&quot; ]
                            			],
                            			state = &quot;pending&quot;,
                            			promise = {
                            				state: function() {
                            					return state;
                            				},
                            				always: function() {
                            					deferred.done( arguments ).fail( arguments );
                            					return this;
                            				},
                            				&quot;catch&quot;: function( fn ) {
                            					return promise.then( null, fn );
                            				},
                            
                            				// Keep pipe for back-compat
                            				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
                            					var fns = arguments;
                            
                            					return jQuery.Deferred( function( newDefer ) {
                            						jQuery.each( tuples, function( i, tuple ) {
                            
                            							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
                            							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) &amp;&amp; fns[ tuple[ 4 ] ];
                            
                            							// deferred.progress(function() { bind to newDefer or newDefer.notify })
                            							// deferred.done(function() { bind to newDefer or newDefer.resolve })
                            							// deferred.fail(function() { bind to newDefer or newDefer.reject })
                            							deferred[ tuple[ 1 ] ]( function() {
                            								var returned = fn &amp;&amp; fn.apply( this, arguments );
                            								if ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) {
                            									returned.promise()
                            										.progress( newDefer.notify )
                            										.done( newDefer.resolve )
                            										.fail( newDefer.reject );
                            								} else {
                            									newDefer[ tuple[ 0 ] + &quot;With&quot; ](
                            										this,
                            										fn ? [ returned ] : arguments
                            									);
                            								}
                            							} );
                            						} );
                            						fns = null;
                            					} ).promise();
                            				},
                            				then: function( onFulfilled, onRejected, onProgress ) {
                            					var maxDepth = 0;
                            					function resolve( depth, deferred, handler, special ) {
                            						return function() {
                            							var that = this,
                            								args = arguments,
                            								mightThrow = function() {
                            									var returned, then;
                            
                            									// Support: Promises/A+ section 2.3.3.3.3
                            									// https://promisesaplus.com/#point-59
                            									// Ignore double-resolution attempts
                            									if ( depth &lt; maxDepth ) {
                            										return;
                            									}
                            
                            									returned = handler.apply( that, args );
                            
                            									// Support: Promises/A+ section 2.3.1
                            									// https://promisesaplus.com/#point-48
                            									if ( returned === deferred.promise() ) {
                            										throw new TypeError( &quot;Thenable self-resolution&quot; );
                            									}
                            
                            									// Support: Promises/A+ sections 2.3.3.1, 3.5
                            									// https://promisesaplus.com/#point-54
                            									// https://promisesaplus.com/#point-75
                            									// Retrieve &#x60;then&#x60; only once
                            									then = returned &amp;&amp;
                            
                            										// Support: Promises/A+ section 2.3.4
                            										// https://promisesaplus.com/#point-64
                            										// Only check objects and functions for thenability
                            										( typeof returned === &quot;object&quot; ||
                            											typeof returned === &quot;function&quot; ) &amp;&amp;
                            										returned.then;
                            
                            									// Handle a returned thenable
                            									if ( jQuery.isFunction( then ) ) {
                            
                            										// Special processors (notify) just wait for resolution
                            										if ( special ) {
                            											then.call(
                            												returned,
                            												resolve( maxDepth, deferred, Identity, special ),
                            												resolve( maxDepth, deferred, Thrower, special )
                            											);
                            
                            										// Normal processors (resolve) also hook into progress
                            										} else {
                            
                            											// ...and disregard older resolution values
                            											maxDepth++;
                            
                            											then.call(
                            												returned,
                            												resolve( maxDepth, deferred, Identity, special ),
                            												resolve( maxDepth, deferred, Thrower, special ),
                            												resolve( maxDepth, deferred, Identity,
                            													deferred.notifyWith )
                            											);
                            										}
                            
                            									// Handle all other returned values
                            									} else {
                            
                            										// Only substitute handlers pass on context
                            										// and multiple values (non-spec behavior)
                            										if ( handler !== Identity ) {
                            											that = undefined;
                            											args = [ returned ];
                            										}
                            
                            										// Process the value(s)
                            										// Default process is resolve
                            										( special || deferred.resolveWith )( that, args );
                            									}
                            								},
                            
                            								// Only normal processors (resolve) catch and reject exceptions
                            								process = special ?
                            									mightThrow :
                            									function() {
                            										try {
                            											mightThrow();
                            										} catch ( e ) {
                            
                            											if ( jQuery.Deferred.exceptionHook ) {
                            												jQuery.Deferred.exceptionHook( e,
                            													process.stackTrace );
                            											}
                            
                            											// Support: Promises/A+ section 2.3.3.3.4.1
                            											// https://promisesaplus.com/#point-61
                            											// Ignore post-resolution exceptions
                            											if ( depth + 1 &gt;= maxDepth ) {
                            
                            												// Only substitute handlers pass on context
                            												// and multiple values (non-spec behavior)
                            												if ( handler !== Thrower ) {
                            													that = undefined;
                            													args = [ e ];
                            												}
                            
                            												deferred.rejectWith( that, args );
                            											}
                            										}
                            									};
                            
                            							// Support: Promises/A+ section 2.3.3.3.1
                            							// https://promisesaplus.com/#point-57
                            							// Re-resolve promises immediately to dodge false rejection from
                            							// subsequent errors
                            							if ( depth ) {
                            								process();
                            							} else {
                            
                            								// Call an optional hook to record the stack, in case of exception
                            								// since it&#x27;s otherwise lost when execution goes async
                            								if ( jQuery.Deferred.getStackHook ) {
                            									process.stackTrace = jQuery.Deferred.getStackHook();
                            								}
                            								window.setTimeout( process );
                            							}
                            						};
                            					}
                            
                            					return jQuery.Deferred( function( newDefer ) {
                            
                            						// progress_handlers.add( ... )
                            						tuples[ 0 ][ 3 ].add(
                            							resolve(
                            								0,
                            								newDefer,
                            								jQuery.isFunction( onProgress ) ?
                            									onProgress :
                            									Identity,
                            								newDefer.notifyWith
                            							)
                            						);
                            
                            						// fulfilled_handlers.add( ... )
                            						tuples[ 1 ][ 3 ].add(
                            							resolve(
                            								0,
                            								newDefer,
                            								jQuery.isFunction( onFulfilled ) ?
                            									onFulfilled :
                            									Identity
                            							)
                            						);
                            
                            						// rejected_handlers.add( ... )
                            						tuples[ 2 ][ 3 ].add(
                            							resolve(
                            								0,
                            								newDefer,
                            								jQuery.isFunction( onRejected ) ?
                            									onRejected :
                            									Thrower
                            							)
                            						);
                            					} ).promise();
                            				},
                            
                            				// Get a promise for this deferred
                            				// If obj is provided, the promise aspect is added to the object
                            				promise: function( obj ) {
                            					return obj != null ? jQuery.extend( obj, promise ) : promise;
                            				}
                            			},
                            			deferred = {};
                            
                            		// Add list-specific methods
                            		jQuery.each( tuples, function( i, tuple ) {
                            			var list = tuple[ 2 ],
                            				stateString = tuple[ 5 ];
                            
                            			// promise.progress = list.add
                            			// promise.done = list.add
                            			// promise.fail = list.add
                            			promise[ tuple[ 1 ] ] = list.add;
                            
                            			// Handle state
                            			if ( stateString ) {
                            				list.add(
                            					function() {
                            
                            						// state = &quot;resolved&quot; (i.e., fulfilled)
                            						// state = &quot;rejected&quot;
                            						state = stateString;
                            					},
                            
                            					// rejected_callbacks.disable
                            					// fulfilled_callbacks.disable
                            					tuples[ 3 - i ][ 2 ].disable,
                            
                            					// progress_callbacks.lock
                            					tuples[ 0 ][ 2 ].lock
                            				);
                            			}
                            
                            			// progress_handlers.fire
                            			// fulfilled_handlers.fire
                            			// rejected_handlers.fire
                            			list.add( tuple[ 3 ].fire );
                            
                            			// deferred.notify = function() { deferred.notifyWith(...) }
                            			// deferred.resolve = function() { deferred.resolveWith(...) }
                            			// deferred.reject = function() { deferred.rejectWith(...) }
                            			deferred[ tuple[ 0 ] ] = function() {
                            				deferred[ tuple[ 0 ] + &quot;With&quot; ]( this === deferred ? undefined : this, arguments );
                            				return this;
                            			};
                            
                            			// deferred.notifyWith = list.fireWith
                            			// deferred.resolveWith = list.fireWith
                            			// deferred.rejectWith = list.fireWith
                            			deferred[ tuple[ 0 ] + &quot;With&quot; ] = list.fireWith;
                            		} );
                            
                            		// Make the deferred a promise
                            		promise.promise( deferred );
                            
                            		// Call given func if any
                            		if ( func ) {
                            			func.call( deferred, deferred );
                            		}
                            
                            		// All done!
                            		return deferred;
                            	},
                            
                            	// Deferred helper
                            	when: function( singleValue ) {
                            		var
                            
                            			// count of uncompleted subordinates
                            			remaining = arguments.length,
                            
                            			// count of unprocessed arguments
                            			i = remaining,
                            
                            			// subordinate fulfillment data
                            			resolveContexts = Array( i ),
                            			resolveValues = slice.call( arguments ),
                            
                            			// the master Deferred
                            			master = jQuery.Deferred(),
                            
                            			// subordinate callback factory
                            			updateFunc = function( i ) {
                            				return function( value ) {
                            					resolveContexts[ i ] = this;
                            					resolveValues[ i ] = arguments.length &gt; 1 ? slice.call( arguments ) : value;
                            					if ( !( --remaining ) ) {
                            						master.resolveWith( resolveContexts, resolveValues );
                            					}
                            				};
                            			};
                            
                            		// Single- and empty arguments are adopted like Promise.resolve
                            		if ( remaining &lt;= 1 ) {
                            			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
                            				!remaining );
                            
                            			// Use .then() to unwrap secondary thenables (cf. gh-3000)
                            			if ( master.state() === &quot;pending&quot; ||
                            				jQuery.isFunction( resolveValues[ i ] &amp;&amp; resolveValues[ i ].then ) ) {
                            
                            				return master.then();
                            			}
                            		}
                            
                            		// Multiple arguments are aggregated like Promise.all array elements
                            		while ( i-- ) {
                            			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
                            		}
                            
                            		return master.promise();
                            	}
                            } );
                            
                            
                            // These usually indicate a programmer mistake during development,
                            // warn about them ASAP rather than swallowing them by default.
                            var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
                            
                            jQuery.Deferred.exceptionHook = function( error, stack ) {
                            
                            	// Support: IE 8 - 9 only
                            	// Console exists when dev tools are open, which can happen at any time
                            	if ( window.console &amp;&amp; window.console.warn &amp;&amp; error &amp;&amp; rerrorNames.test( error.name ) ) {
                            		window.console.warn( &quot;jQuery.Deferred exception: &quot; + error.message, error.stack, stack );
                            	}
                            };
                            
                            
                            
                            
                            jQuery.readyException = function( error ) {
                            	window.setTimeout( function() {
                            		throw error;
                            	} );
                            };
                            
                            
                            
                            
                            // The deferred used on DOM ready
                            var readyList = jQuery.Deferred();
                            
                            jQuery.fn.ready = function( fn ) {
                            
                            	readyList
                            		.then( fn )
                            
                            		// Wrap jQuery.readyException in a function so that the lookup
                            		// happens at the time of error handling instead of callback
                            		// registration.
                            		.catch( function( error ) {
                            			jQuery.readyException( error );
                            		} );
                            
                            	return this;
                            };
                            
                            jQuery.extend( {
                            
                            	// Is the DOM ready to be used? Set to true once it occurs.
                            	isReady: false,
                            
                            	// A counter to track how many items to wait for before
                            	// the ready event fires. See #6781
                            	readyWait: 1,
                            
                            	// Handle when the DOM is ready
                            	ready: function( wait ) {
                            
                            		// Abort if there are pending holds or we&#x27;re already ready
                            		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
                            			return;
                            		}
                            
                            		// Remember that the DOM is ready
                            		jQuery.isReady = true;
                            
                            		// If a normal DOM Ready event fired, decrement, and wait if need be
                            		if ( wait !== true &amp;&amp; --jQuery.readyWait &gt; 0 ) {
                            			return;
                            		}
                            
                            		// If there are functions bound, to execute
                            		readyList.resolveWith( document, [ jQuery ] );
                            	}
                            } );
                            
                            jQuery.ready.then = readyList.then;
                            
                            // The ready event handler and self cleanup method
                            function completed() {
                            	document.removeEventListener( &quot;DOMContentLoaded&quot;, completed );
                            	window.removeEventListener( &quot;load&quot;, completed );
                            	jQuery.ready();
                            }
                            
                            // Catch cases where $(document).ready() is called
                            // after the browser event has already occurred.
                            // Support: IE &lt;=9 - 10 only
                            // Older IE sometimes signals &quot;interactive&quot; too soon
                            if ( document.readyState === &quot;complete&quot; ||
                            	( document.readyState !== &quot;loading&quot; &amp;&amp; !document.documentElement.doScroll ) ) {
                            
                            	// Handle it asynchronously to allow scripts the opportunity to delay ready
                            	window.setTimeout( jQuery.ready );
                            
                            } else {
                            
                            	// Use the handy event callback
                            	document.addEventListener( &quot;DOMContentLoaded&quot;, completed );
                            
                            	// A fallback to window.onload, that will always work
                            	window.addEventListener( &quot;load&quot;, completed );
                            }
                            
                            
                            
                            
                            // Multifunctional method to get and set values of a collection
                            // The value/s can optionally be executed if it&#x27;s a function
                            var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
                            	var i = 0,
                            		len = elems.length,
                            		bulk = key == null;
                            
                            	// Sets many values
                            	if ( jQuery.type( key ) === &quot;object&quot; ) {
                            		chainable = true;
                            		for ( i in key ) {
                            			access( elems, fn, i, key[ i ], true, emptyGet, raw );
                            		}
                            
                            	// Sets one value
                            	} else if ( value !== undefined ) {
                            		chainable = true;
                            
                            		if ( !jQuery.isFunction( value ) ) {
                            			raw = true;
                            		}
                            
                            		if ( bulk ) {
                            
                            			// Bulk operations run against the entire set
                            			if ( raw ) {
                            				fn.call( elems, value );
                            				fn = null;
                            
                            			// ...except when executing function values
                            			} else {
                            				bulk = fn;
                            				fn = function( elem, key, value ) {
                            					return bulk.call( jQuery( elem ), value );
                            				};
                            			}
                            		}
                            
                            		if ( fn ) {
                            			for ( ; i &lt; len; i++ ) {
                            				fn(
                            					elems[ i ], key, raw ?
                            					value :
                            					value.call( elems[ i ], i, fn( elems[ i ], key ) )
                            				);
                            			}
                            		}
                            	}
                            
                            	if ( chainable ) {
                            		return elems;
                            	}
                            
                            	// Gets
                            	if ( bulk ) {
                            		return fn.call( elems );
                            	}
                            
                            	return len ? fn( elems[ 0 ], key ) : emptyGet;
                            };
                            var acceptData = function( owner ) {
                            
                            	// Accepts only:
                            	//  - Node
                            	//    - Node.ELEMENT_NODE
                            	//    - Node.DOCUMENT_NODE
                            	//  - Object
                            	//    - Any
                            	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
                            };
                            
                            
                            
                            
                            function Data() {
                            	this.expando = jQuery.expando + Data.uid++;
                            }
                            
                            Data.uid = 1;
                            
                            Data.prototype = {
                            
                            	cache: function( owner ) {
                            
                            		// Check if the owner object already has a cache
                            		var value = owner[ this.expando ];
                            
                            		// If not, create one
                            		if ( !value ) {
                            			value = {};
                            
                            			// We can accept data for non-element nodes in modern browsers,
                            			// but we should not, see #8335.
                            			// Always return an empty object.
                            			if ( acceptData( owner ) ) {
                            
                            				// If it is a node unlikely to be stringify-ed or looped over
                            				// use plain assignment
                            				if ( owner.nodeType ) {
                            					owner[ this.expando ] = value;
                            
                            				// Otherwise secure it in a non-enumerable property
                            				// configurable must be true to allow the property to be
                            				// deleted when data is removed
                            				} else {
                            					Object.defineProperty( owner, this.expando, {
                            						value: value,
                            						configurable: true
                            					} );
                            				}
                            			}
                            		}
                            
                            		return value;
                            	},
                            	set: function( owner, data, value ) {
                            		var prop,
                            			cache = this.cache( owner );
                            
                            		// Handle: [ owner, key, value ] args
                            		// Always use camelCase key (gh-2257)
                            		if ( typeof data === &quot;string&quot; ) {
                            			cache[ jQuery.camelCase( data ) ] = value;
                            
                            		// Handle: [ owner, { properties } ] args
                            		} else {
                            
                            			// Copy the properties one-by-one to the cache object
                            			for ( prop in data ) {
                            				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
                            			}
                            		}
                            		return cache;
                            	},
                            	get: function( owner, key ) {
                            		return key === undefined ?
                            			this.cache( owner ) :
                            
                            			// Always use camelCase key (gh-2257)
                            			owner[ this.expando ] &amp;&amp; owner[ this.expando ][ jQuery.camelCase( key ) ];
                            	},
                            	access: function( owner, key, value ) {
                            
                            		// In cases where either:
                            		//
                            		//   1. No key was specified
                            		//   2. A string key was specified, but no value provided
                            		//
                            		// Take the &quot;read&quot; path and allow the get method to determine
                            		// which value to return, respectively either:
                            		//
                            		//   1. The entire cache object
                            		//   2. The data stored at the key
                            		//
                            		if ( key === undefined ||
                            				( ( key &amp;&amp; typeof key === &quot;string&quot; ) &amp;&amp; value === undefined ) ) {
                            
                            			return this.get( owner, key );
                            		}
                            
                            		// When the key is not a string, or both a key and value
                            		// are specified, set or extend (existing objects) with either:
                            		//
                            		//   1. An object of properties
                            		//   2. A key and value
                            		//
                            		this.set( owner, key, value );
                            
                            		// Since the &quot;set&quot; path can have two possible entry points
                            		// return the expected data based on which path was taken[*]
                            		return value !== undefined ? value : key;
                            	},
                            	remove: function( owner, key ) {
                            		var i,
                            			cache = owner[ this.expando ];
                            
                            		if ( cache === undefined ) {
                            			return;
                            		}
                            
                            		if ( key !== undefined ) {
                            
                            			// Support array or space separated string of keys
                            			if ( Array.isArray( key ) ) {
                            
                            				// If key is an array of keys...
                            				// We always set camelCase keys, so remove that.
                            				key = key.map( jQuery.camelCase );
                            			} else {
                            				key = jQuery.camelCase( key );
                            
                            				// If a key with the spaces exists, use it.
                            				// Otherwise, create an array by matching non-whitespace
                            				key = key in cache ?
                            					[ key ] :
                            					( key.match( rnothtmlwhite ) || [] );
                            			}
                            
                            			i = key.length;
                            
                            			while ( i-- ) {
                            				delete cache[ key[ i ] ];
                            			}
                            		}
                            
                            		// Remove the expando if there&#x27;s no more data
                            		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
                            
                            			// Support: Chrome &lt;=35 - 45
                            			// Webkit &amp; Blink performance suffers when deleting properties
                            			// from DOM nodes, so set to undefined instead
                            			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                            			if ( owner.nodeType ) {
                            				owner[ this.expando ] = undefined;
                            			} else {
                            				delete owner[ this.expando ];
                            			}
                            		}
                            	},
                            	hasData: function( owner ) {
                            		var cache = owner[ this.expando ];
                            		return cache !== undefined &amp;&amp; !jQuery.isEmptyObject( cache );
                            	}
                            };
                            var dataPriv = new Data();
                            
                            var dataUser = new Data();
                            
                            
                            
                            //	Implementation Summary
                            //
                            //	1. Enforce API surface and semantic compatibility with 1.9.x branch
                            //	2. Improve the module&#x27;s maintainability by reducing the storage
                            //		paths to a single mechanism.
                            //	3. Use the same single mechanism to support &quot;private&quot; and &quot;user&quot; data.
                            //	4. _Never_ expose &quot;private&quot; data to user code (TODO: Drop _data, _removeData)
                            //	5. Avoid exposing implementation details on user objects (eg. expando properties)
                            //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
                            
                            var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                            	rmultiDash = /[A-Z]/g;
                            
                            function getData( data ) {
                            	if ( data === &quot;true&quot; ) {
                            		return true;
                            	}
                            
                            	if ( data === &quot;false&quot; ) {
                            		return false;
                            	}
                            
                            	if ( data === &quot;null&quot; ) {
                            		return null;
                            	}
                            
                            	// Only convert to a number if it doesn&#x27;t change the string
                            	if ( data === +data + &quot;&quot; ) {
                            		return +data;
                            	}
                            
                            	if ( rbrace.test( data ) ) {
                            		return JSON.parse( data );
                            	}
                            
                            	return data;
                            }
                            
                            function dataAttr( elem, key, data ) {
                            	var name;
                            
                            	// If nothing was found internally, try to fetch any
                            	// data from the HTML5 data-* attribute
                            	if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {
                            		name = &quot;data-&quot; + key.replace( rmultiDash, &quot;-$&amp;&quot; ).toLowerCase();
                            		data = elem.getAttribute( name );
                            
                            		if ( typeof data === &quot;string&quot; ) {
                            			try {
                            				data = getData( data );
                            			} catch ( e ) {}
                            
                            			// Make sure we set the data so it isn&#x27;t changed later
                            			dataUser.set( elem, key, data );
                            		} else {
                            			data = undefined;
                            		}
                            	}
                            	return data;
                            }
                            
                            jQuery.extend( {
                            	hasData: function( elem ) {
                            		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
                            	},
                            
                            	data: function( elem, name, data ) {
                            		return dataUser.access( elem, name, data );
                            	},
                            
                            	removeData: function( elem, name ) {
                            		dataUser.remove( elem, name );
                            	},
                            
                            	// TODO: Now that all calls to _data and _removeData have been replaced
                            	// with direct calls to dataPriv methods, these can be deprecated.
                            	_data: function( elem, name, data ) {
                            		return dataPriv.access( elem, name, data );
                            	},
                            
                            	_removeData: function( elem, name ) {
                            		dataPriv.remove( elem, name );
                            	}
                            } );
                            
                            jQuery.fn.extend( {
                            	data: function( key, value ) {
                            		var i, name, data,
                            			elem = this[ 0 ],
                            			attrs = elem &amp;&amp; elem.attributes;
                            
                            		// Gets all values
                            		if ( key === undefined ) {
                            			if ( this.length ) {
                            				data = dataUser.get( elem );
                            
                            				if ( elem.nodeType === 1 &amp;&amp; !dataPriv.get( elem, &quot;hasDataAttrs&quot; ) ) {
                            					i = attrs.length;
                            					while ( i-- ) {
                            
                            						// Support: IE 11 only
                            						// The attrs elements can be null (#14894)
                            						if ( attrs[ i ] ) {
                            							name = attrs[ i ].name;
                            							if ( name.indexOf( &quot;data-&quot; ) === 0 ) {
                            								name = jQuery.camelCase( name.slice( 5 ) );
                            								dataAttr( elem, name, data[ name ] );
                            							}
                            						}
                            					}
                            					dataPriv.set( elem, &quot;hasDataAttrs&quot;, true );
                            				}
                            			}
                            
                            			return data;
                            		}
                            
                            		// Sets multiple values
                            		if ( typeof key === &quot;object&quot; ) {
                            			return this.each( function() {
                            				dataUser.set( this, key );
                            			} );
                            		}
                            
                            		return access( this, function( value ) {
                            			var data;
                            
                            			// The calling jQuery object (element matches) is not empty
                            			// (and therefore has an element appears at this[ 0 ]) and the
                            			// &#x60;value&#x60; parameter was not undefined. An empty jQuery object
                            			// will result in &#x60;undefined&#x60; for elem = this[ 0 ] which will
                            			// throw an exception if an attempt to read a data cache is made.
                            			if ( elem &amp;&amp; value === undefined ) {
                            
                            				// Attempt to get data from the cache
                            				// The key will always be camelCased in Data
                            				data = dataUser.get( elem, key );
                            				if ( data !== undefined ) {
                            					return data;
                            				}
                            
                            				// Attempt to &quot;discover&quot; the data in
                            				// HTML5 custom data-* attrs
                            				data = dataAttr( elem, key );
                            				if ( data !== undefined ) {
                            					return data;
                            				}
                            
                            				// We tried really hard, but the data doesn&#x27;t exist.
                            				return;
                            			}
                            
                            			// Set the data...
                            			this.each( function() {
                            
                            				// We always store the camelCased key
                            				dataUser.set( this, key, value );
                            			} );
                            		}, null, value, arguments.length &gt; 1, null, true );
                            	},
                            
                            	removeData: function( key ) {
                            		return this.each( function() {
                            			dataUser.remove( this, key );
                            		} );
                            	}
                            } );
                            
                            
                            jQuery.extend( {
                            	queue: function( elem, type, data ) {
                            		var queue;
                            
                            		if ( elem ) {
                            			type = ( type || &quot;fx&quot; ) + &quot;queue&quot;;
                            			queue = dataPriv.get( elem, type );
                            
                            			// Speed up dequeue by getting out quickly if this is just a lookup
                            			if ( data ) {
                            				if ( !queue || Array.isArray( data ) ) {
                            					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
                            				} else {
                            					queue.push( data );
                            				}
                            			}
                            			return queue || [];
                            		}
                            	},
                            
                            	dequeue: function( elem, type ) {
                            		type = type || &quot;fx&quot;;
                            
                            		var queue = jQuery.queue( elem, type ),
                            			startLength = queue.length,
                            			fn = queue.shift(),
                            			hooks = jQuery._queueHooks( elem, type ),
                            			next = function() {
                            				jQuery.dequeue( elem, type );
                            			};
                            
                            		// If the fx queue is dequeued, always remove the progress sentinel
                            		if ( fn === &quot;inprogress&quot; ) {
                            			fn = queue.shift();
                            			startLength--;
                            		}
                            
                            		if ( fn ) {
                            
                            			// Add a progress sentinel to prevent the fx queue from being
                            			// automatically dequeued
                            			if ( type === &quot;fx&quot; ) {
                            				queue.unshift( &quot;inprogress&quot; );
                            			}
                            
                            			// Clear up the last queue stop function
                            			delete hooks.stop;
                            			fn.call( elem, next, hooks );
                            		}
                            
                            		if ( !startLength &amp;&amp; hooks ) {
                            			hooks.empty.fire();
                            		}
                            	},
                            
                            	// Not public - generate a queueHooks object, or return the current one
                            	_queueHooks: function( elem, type ) {
                            		var key = type + &quot;queueHooks&quot;;
                            		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
                            			empty: jQuery.Callbacks( &quot;once memory&quot; ).add( function() {
                            				dataPriv.remove( elem, [ type + &quot;queue&quot;, key ] );
                            			} )
                            		} );
                            	}
                            } );
                            
                            jQuery.fn.extend( {
                            	queue: function( type, data ) {
                            		var setter = 2;
                            
                            		if ( typeof type !== &quot;string&quot; ) {
                            			data = type;
                            			type = &quot;fx&quot;;
                            			setter--;
                            		}
                            
                            		if ( arguments.length &lt; setter ) {
                            			return jQuery.queue( this[ 0 ], type );
                            		}
                            
                            		return data === undefined ?
                            			this :
                            			this.each( function() {
                            				var queue = jQuery.queue( this, type, data );
                            
                            				// Ensure a hooks for this queue
                            				jQuery._queueHooks( this, type );
                            
                            				if ( type === &quot;fx&quot; &amp;&amp; queue[ 0 ] !== &quot;inprogress&quot; ) {
                            					jQuery.dequeue( this, type );
                            				}
                            			} );
                            	},
                            	dequeue: function( type ) {
                            		return this.each( function() {
                            			jQuery.dequeue( this, type );
                            		} );
                            	},
                            	clearQueue: function( type ) {
                            		return this.queue( type || &quot;fx&quot;, [] );
                            	},
                            
                            	// Get a promise resolved when queues of a certain type
                            	// are emptied (fx is the type by default)
                            	promise: function( type, obj ) {
                            		var tmp,
                            			count = 1,
                            			defer = jQuery.Deferred(),
                            			elements = this,
                            			i = this.length,
                            			resolve = function() {
                            				if ( !( --count ) ) {
                            					defer.resolveWith( elements, [ elements ] );
                            				}
                            			};
                            
                            		if ( typeof type !== &quot;string&quot; ) {
                            			obj = type;
                            			type = undefined;
                            		}
                            		type = type || &quot;fx&quot;;
                            
                            		while ( i-- ) {
                            			tmp = dataPriv.get( elements[ i ], type + &quot;queueHooks&quot; );
                            			if ( tmp &amp;&amp; tmp.empty ) {
                            				count++;
                            				tmp.empty.add( resolve );
                            			}
                            		}
                            		resolve();
                            		return defer.promise( obj );
                            	}
                            } );
                            var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
                            
                            var rcssNum = new RegExp( &quot;^(?:([+-])=|)(&quot; + pnum + &quot;)([a-z%]*)$&quot;, &quot;i&quot; );
                            
                            
                            var cssExpand = [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ];
                            
                            var isHiddenWithinTree = function( elem, el ) {
                            
                            		// isHiddenWithinTree might be called from jQuery#filter function;
                            		// in that case, element will be second argument
                            		elem = el || elem;
                            
                            		// Inline style trumps all
                            		return elem.style.display === &quot;none&quot; ||
                            			elem.style.display === &quot;&quot; &amp;&amp;
                            
                            			// Otherwise, check computed style
                            			// Support: Firefox &lt;=43 - 45
                            			// Disconnected elements can have computed display: none, so first confirm that elem is
                            			// in the document.
                            			jQuery.contains( elem.ownerDocument, elem ) &amp;&amp;
                            
                            			jQuery.css( elem, &quot;display&quot; ) === &quot;none&quot;;
                            	};
                            
                            var swap = function( elem, options, callback, args ) {
                            	var ret, name,
                            		old = {};
                            
                            	// Remember the old values, and insert the new ones
                            	for ( name in options ) {
                            		old[ name ] = elem.style[ name ];
                            		elem.style[ name ] = options[ name ];
                            	}
                            
                            	ret = callback.apply( elem, args || [] );
                            
                            	// Revert the old values
                            	for ( name in options ) {
                            		elem.style[ name ] = old[ name ];
                            	}
                            
                            	return ret;
                            };
                            
                            
                            
                            
                            function adjustCSS( elem, prop, valueParts, tween ) {
                            	var adjusted,
                            		scale = 1,
                            		maxIterations = 20,
                            		currentValue = tween ?
                            			function() {
                            				return tween.cur();
                            			} :
                            			function() {
                            				return jQuery.css( elem, prop, &quot;&quot; );
                            			},
                            		initial = currentValue(),
                            		unit = valueParts &amp;&amp; valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; ),
                            
                            		// Starting value computation is required for potential unit mismatches
                            		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== &quot;px&quot; &amp;&amp; +initial ) &amp;&amp;
                            			rcssNum.exec( jQuery.css( elem, prop ) );
                            
                            	if ( initialInUnit &amp;&amp; initialInUnit[ 3 ] !== unit ) {
                            
                            		// Trust units reported by jQuery.css
                            		unit = unit || initialInUnit[ 3 ];
                            
                            		// Make sure we update the tween properties later on
                            		valueParts = valueParts || [];
                            
                            		// Iteratively approximate from a nonzero starting point
                            		initialInUnit = +initial || 1;
                            
                            		do {
                            
                            			// If previous iteration zeroed out, double until we get *something*.
                            			// Use string for doubling so we don&#x27;t accidentally see scale as unchanged below
                            			scale = scale || &quot;.5&quot;;
                            
                            			// Adjust and apply
                            			initialInUnit = initialInUnit / scale;
                            			jQuery.style( elem, prop, initialInUnit + unit );
                            
                            		// Update scale, tolerating zero or NaN from tween.cur()
                            		// Break the loop if scale is unchanged or perfect, or if we&#x27;ve just had enough.
                            		} while (
                            			scale !== ( scale = currentValue() / initial ) &amp;&amp; scale !== 1 &amp;&amp; --maxIterations
                            		);
                            	}
                            
                            	if ( valueParts ) {
                            		initialInUnit = +initialInUnit || +initial || 0;
                            
                            		// Apply relative offset (+=/-=) if specified
                            		adjusted = valueParts[ 1 ] ?
                            			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
                            			+valueParts[ 2 ];
                            		if ( tween ) {
                            			tween.unit = unit;
                            			tween.start = initialInUnit;
                            			tween.end = adjusted;
                            		}
                            	}
                            	return adjusted;
                            }
                            
                            
                            var defaultDisplayMap = {};
                            
                            function getDefaultDisplay( elem ) {
                            	var temp,
                            		doc = elem.ownerDocument,
                            		nodeName = elem.nodeName,
                            		display = defaultDisplayMap[ nodeName ];
                            
                            	if ( display ) {
                            		return display;
                            	}
                            
                            	temp = doc.body.appendChild( doc.createElement( nodeName ) );
                            	display = jQuery.css( temp, &quot;display&quot; );
                            
                            	temp.parentNode.removeChild( temp );
                            
                            	if ( display === &quot;none&quot; ) {
                            		display = &quot;block&quot;;
                            	}
                            	defaultDisplayMap[ nodeName ] = display;
                            
                            	return display;
                            }
                            
                            function showHide( elements, show ) {
                            	var display, elem,
                            		values = [],
                            		index = 0,
                            		length = elements.length;
                            
                            	// Determine new display value for elements that need to change
                            	for ( ; index &lt; length; index++ ) {
                            		elem = elements[ index ];
                            		if ( !elem.style ) {
                            			continue;
                            		}
                            
                            		display = elem.style.display;
                            		if ( show ) {
                            
                            			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                            			// check is required in this first loop unless we have a nonempty display value (either
                            			// inline or about-to-be-restored)
                            			if ( display === &quot;none&quot; ) {
                            				values[ index ] = dataPriv.get( elem, &quot;display&quot; ) || null;
                            				if ( !values[ index ] ) {
                            					elem.style.display = &quot;&quot;;
                            				}
                            			}
                            			if ( elem.style.display === &quot;&quot; &amp;&amp; isHiddenWithinTree( elem ) ) {
                            				values[ index ] = getDefaultDisplay( elem );
                            			}
                            		} else {
                            			if ( display !== &quot;none&quot; ) {
                            				values[ index ] = &quot;none&quot;;
                            
                            				// Remember what we&#x27;re overwriting
                            				dataPriv.set( elem, &quot;display&quot;, display );
                            			}
                            		}
                            	}
                            
                            	// Set the display of the elements in a second loop to avoid constant reflow
                            	for ( index = 0; index &lt; length; index++ ) {
                            		if ( values[ index ] != null ) {
                            			elements[ index ].style.display = values[ index ];
                            		}
                            	}
                            
                            	return elements;
                            }
                            
                            jQuery.fn.extend( {
                            	show: function() {
                            		return showHide( this, true );
                            	},
                            	hide: function() {
                            		return showHide( this );
                            	},
                            	toggle: function( state ) {
                            		if ( typeof state === &quot;boolean&quot; ) {
                            			return state ? this.show() : this.hide();
                            		}
                            
                            		return this.each( function() {
                            			if ( isHiddenWithinTree( this ) ) {
                            				jQuery( this ).show();
                            			} else {
                            				jQuery( this ).hide();
                            			}
                            		} );
                            	}
                            } );
                            var rcheckableType = ( /^(?:checkbox|radio)$/i );
                            
                            var rtagName = ( /&lt;([a-z][^\/\0&gt;\x20\t\r\n\f]+)/i );
                            
                            var rscriptType = ( /^$|\/(?:java|ecma)script/i );
                            
                            
                            
                            // We have to close these tags to support XHTML (#13200)
                            var wrapMap = {
                            
                            	// Support: IE &lt;=9 only
                            	option: [ 1, &quot;&lt;select multiple=&#x27;multiple&#x27;&gt;&quot;, &quot;&lt;/select&gt;&quot; ],
                            
                            	// XHTML parsers do not magically insert elements in the
                            	// same way that tag soup parsers do. So we cannot shorten
                            	// this by omitting &lt;tbody&gt; or other required elements.
                            	thead: [ 1, &quot;&lt;table&gt;&quot;, &quot;&lt;/table&gt;&quot; ],
                            	col: [ 2, &quot;&lt;table&gt;&lt;colgroup&gt;&quot;, &quot;&lt;/colgroup&gt;&lt;/table&gt;&quot; ],
                            	tr: [ 2, &quot;&lt;table&gt;&lt;tbody&gt;&quot;, &quot;&lt;/tbody&gt;&lt;/table&gt;&quot; ],
                            	td: [ 3, &quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot;, &quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot; ],
                            
                            	_default: [ 0, &quot;&quot;, &quot;&quot; ]
                            };
                            
                            // Support: IE &lt;=9 only
                            wrapMap.optgroup = wrapMap.option;
                            
                            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
                            wrapMap.th = wrapMap.td;
                            
                            
                            function getAll( context, tag ) {
                            
                            	// Support: IE &lt;=9 - 11 only
                            	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
                            	var ret;
                            
                            	if ( typeof context.getElementsByTagName !== &quot;undefined&quot; ) {
                            		ret = context.getElementsByTagName( tag || &quot;*&quot; );
                            
                            	} else if ( typeof context.querySelectorAll !== &quot;undefined&quot; ) {
                            		ret = context.querySelectorAll( tag || &quot;*&quot; );
                            
                            	} else {
                            		ret = [];
                            	}
                            
                            	if ( tag === undefined || tag &amp;&amp; nodeName( context, tag ) ) {
                            		return jQuery.merge( [ context ], ret );
                            	}
                            
                            	return ret;
                            }
                            
                            
                            // Mark scripts as having already been evaluated
                            function setGlobalEval( elems, refElements ) {
                            	var i = 0,
                            		l = elems.length;
                            
                            	for ( ; i &lt; l; i++ ) {
                            		dataPriv.set(
                            			elems[ i ],
                            			&quot;globalEval&quot;,
                            			!refElements || dataPriv.get( refElements[ i ], &quot;globalEval&quot; )
                            		);
                            	}
                            }
                            
                            
                            var rhtml = /&lt;|&amp;#?\w+;/;
                            
                            function buildFragment( elems, context, scripts, selection, ignored ) {
                            	var elem, tmp, tag, wrap, contains, j,
                            		fragment = context.createDocumentFragment(),
                            		nodes = [],
                            		i = 0,
                            		l = elems.length;
                            
                            	for ( ; i &lt; l; i++ ) {
                            		elem = elems[ i ];
                            
                            		if ( elem || elem === 0 ) {
                            
                            			// Add nodes directly
                            			if ( jQuery.type( elem ) === &quot;object&quot; ) {
                            
                            				// Support: Android &lt;=4.0 only, PhantomJS 1 only
                            				// push.apply(_, arraylike) throws on ancient WebKit
                            				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
                            
                            			// Convert non-html into a text node
                            			} else if ( !rhtml.test( elem ) ) {
                            				nodes.push( context.createTextNode( elem ) );
                            
                            			// Convert html into DOM nodes
                            			} else {
                            				tmp = tmp || fragment.appendChild( context.createElement( &quot;div&quot; ) );
                            
                            				// Deserialize a standard representation
                            				tag = ( rtagName.exec( elem ) || [ &quot;&quot;, &quot;&quot; ] )[ 1 ].toLowerCase();
                            				wrap = wrapMap[ tag ] || wrapMap._default;
                            				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
                            
                            				// Descend through wrappers to the right content
                            				j = wrap[ 0 ];
                            				while ( j-- ) {
                            					tmp = tmp.lastChild;
                            				}
                            
                            				// Support: Android &lt;=4.0 only, PhantomJS 1 only
                            				// push.apply(_, arraylike) throws on ancient WebKit
                            				jQuery.merge( nodes, tmp.childNodes );
                            
                            				// Remember the top-level container
                            				tmp = fragment.firstChild;
                            
                            				// Ensure the created nodes are orphaned (#12392)
                            				tmp.textContent = &quot;&quot;;
                            			}
                            		}
                            	}
                            
                            	// Remove wrapper from fragment
                            	fragment.textContent = &quot;&quot;;
                            
                            	i = 0;
                            	while ( ( elem = nodes[ i++ ] ) ) {
                            
                            		// Skip elements already in the context collection (trac-4087)
                            		if ( selection &amp;&amp; jQuery.inArray( elem, selection ) &gt; -1 ) {
                            			if ( ignored ) {
                            				ignored.push( elem );
                            			}
                            			continue;
                            		}
                            
                            		contains = jQuery.contains( elem.ownerDocument, elem );
                            
                            		// Append to fragment
                            		tmp = getAll( fragment.appendChild( elem ), &quot;script&quot; );
                            
                            		// Preserve script evaluation history
                            		if ( contains ) {
                            			setGlobalEval( tmp );
                            		}
                            
                            		// Capture executables
                            		if ( scripts ) {
                            			j = 0;
                            			while ( ( elem = tmp[ j++ ] ) ) {
                            				if ( rscriptType.test( elem.type || &quot;&quot; ) ) {
                            					scripts.push( elem );
                            				}
                            			}
                            		}
                            	}
                            
                            	return fragment;
                            }
                            
                            
                            ( function() {
                            	var fragment = document.createDocumentFragment(),
                            		div = fragment.appendChild( document.createElement( &quot;div&quot; ) ),
                            		input = document.createElement( &quot;input&quot; );
                            
                            	// Support: Android 4.0 - 4.3 only
                            	// Check state lost if the name is set (#11217)
                            	// Support: Windows Web Apps (WWA)
                            	// &#x60;name&#x60; and &#x60;type&#x60; must use .setAttribute for WWA (#14901)
                            	input.setAttribute( &quot;type&quot;, &quot;radio&quot; );
                            	input.setAttribute( &quot;checked&quot;, &quot;checked&quot; );
                            	input.setAttribute( &quot;name&quot;, &quot;t&quot; );
                            
                            	div.appendChild( input );
                            
                            	// Support: Android &lt;=4.1 only
                            	// Older WebKit doesn&#x27;t clone checked state correctly in fragments
                            	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
                            
                            	// Support: IE &lt;=11 only
                            	// Make sure textarea (and checkbox) defaultValue is properly cloned
                            	div.innerHTML = &quot;&lt;textarea&gt;x&lt;/textarea&gt;&quot;;
                            	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
                            } )();
                            var documentElement = document.documentElement;
                            
                            
                            
                            var
                            	rkeyEvent = /^key/,
                            	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
                            	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
                            
                            function returnTrue() {
                            	return true;
                            }
                            
                            function returnFalse() {
                            	return false;
                            }
                            
                            // Support: IE &lt;=9 only
                            // See #13393 for more info
                            function safeActiveElement() {
                            	try {
                            		return document.activeElement;
                            	} catch ( err ) { }
                            }
                            
                            function on( elem, types, selector, data, fn, one ) {
                            	var origFn, type;
                            
                            	// Types can be a map of types/handlers
                            	if ( typeof types === &quot;object&quot; ) {
                            
                            		// ( types-Object, selector, data )
                            		if ( typeof selector !== &quot;string&quot; ) {
                            
                            			// ( types-Object, data )
                            			data = data || selector;
                            			selector = undefined;
                            		}
                            		for ( type in types ) {
                            			on( elem, type, selector, data, types[ type ], one );
                            		}
                            		return elem;
                            	}
                            
                            	if ( data == null &amp;&amp; fn == null ) {
                            
                            		// ( types, fn )
                            		fn = selector;
                            		data = selector = undefined;
                            	} else if ( fn == null ) {
                            		if ( typeof selector === &quot;string&quot; ) {
                            
                            			// ( types, selector, fn )
                            			fn = data;
                            			data = undefined;
                            		} else {
                            
                            			// ( types, data, fn )
                            			fn = data;
                            			data = selector;
                            			selector = undefined;
                            		}
                            	}
                            	if ( fn === false ) {
                            		fn = returnFalse;
                            	} else if ( !fn ) {
                            		return elem;
                            	}
                            
                            	if ( one === 1 ) {
                            		origFn = fn;
                            		fn = function( event ) {
                            
                            			// Can use an empty set, since event contains the info
                            			jQuery().off( event );
                            			return origFn.apply( this, arguments );
                            		};
                            
                            		// Use same guid so caller can remove using origFn
                            		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
                            	}
                            	return elem.each( function() {
                            		jQuery.event.add( this, types, fn, data, selector );
                            	} );
                            }
                            
                            /*
                             * Helper functions for managing events -- not part of the public interface.
                             * Props to Dean Edwards&#x27; addEvent library for many of the ideas.
                             */
                            jQuery.event = {
                            
                            	global: {},
                            
                            	add: function( elem, types, handler, data, selector ) {
                            
                            		var handleObjIn, eventHandle, tmp,
                            			events, t, handleObj,
                            			special, handlers, type, namespaces, origType,
                            			elemData = dataPriv.get( elem );
                            
                            		// Don&#x27;t attach events to noData or text/comment nodes (but allow plain objects)
                            		if ( !elemData ) {
                            			return;
                            		}
                            
                            		// Caller can pass in an object of custom data in lieu of the handler
                            		if ( handler.handler ) {
                            			handleObjIn = handler;
                            			handler = handleObjIn.handler;
                            			selector = handleObjIn.selector;
                            		}
                            
                            		// Ensure that invalid selectors throw exceptions at attach time
                            		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
                            		if ( selector ) {
                            			jQuery.find.matchesSelector( documentElement, selector );
                            		}
                            
                            		// Make sure that the handler has a unique ID, used to find/remove it later
                            		if ( !handler.guid ) {
                            			handler.guid = jQuery.guid++;
                            		}
                            
                            		// Init the element&#x27;s event structure and main handler, if this is the first
                            		if ( !( events = elemData.events ) ) {
                            			events = elemData.events = {};
                            		}
                            		if ( !( eventHandle = elemData.handle ) ) {
                            			eventHandle = elemData.handle = function( e ) {
                            
                            				// Discard the second event of a jQuery.event.trigger() and
                            				// when an event is called after a page has unloaded
                            				return typeof jQuery !== &quot;undefined&quot; &amp;&amp; jQuery.event.triggered !== e.type ?
                            					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
                            			};
                            		}
                            
                            		// Handle multiple events separated by a space
                            		types = ( types || &quot;&quot; ).match( rnothtmlwhite ) || [ &quot;&quot; ];
                            		t = types.length;
                            		while ( t-- ) {
                            			tmp = rtypenamespace.exec( types[ t ] ) || [];
                            			type = origType = tmp[ 1 ];
                            			namespaces = ( tmp[ 2 ] || &quot;&quot; ).split( &quot;.&quot; ).sort();
                            
                            			// There *must* be a type, no attaching namespace-only handlers
                            			if ( !type ) {
                            				continue;
                            			}
                            
                            			// If event changes its type, use the special event handlers for the changed type
                            			special = jQuery.event.special[ type ] || {};
                            
                            			// If selector defined, determine special event api type, otherwise given type
                            			type = ( selector ? special.delegateType : special.bindType ) || type;
                            
                            			// Update special based on newly reset type
                            			special = jQuery.event.special[ type ] || {};
                            
                            			// handleObj is passed to all event handlers
                            			handleObj = jQuery.extend( {
                            				type: type,
                            				origType: origType,
                            				data: data,
                            				handler: handler,
                            				guid: handler.guid,
                            				selector: selector,
                            				needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),
                            				namespace: namespaces.join( &quot;.&quot; )
                            			}, handleObjIn );
                            
                            			// Init the event handler queue if we&#x27;re the first
                            			if ( !( handlers = events[ type ] ) ) {
                            				handlers = events[ type ] = [];
                            				handlers.delegateCount = 0;
                            
                            				// Only use addEventListener if the special events handler returns false
                            				if ( !special.setup ||
                            					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                            
                            					if ( elem.addEventListener ) {
                            						elem.addEventListener( type, eventHandle );
                            					}
                            				}
                            			}
                            
                            			if ( special.add ) {
                            				special.add.call( elem, handleObj );
                            
                            				if ( !handleObj.handler.guid ) {
                            					handleObj.handler.guid = handler.guid;
                            				}
                            			}
                            
                            			// Add to the element&#x27;s handler list, delegates in front
                            			if ( selector ) {
                            				handlers.splice( handlers.delegateCount++, 0, handleObj );
                            			} else {
                            				handlers.push( handleObj );
                            			}
                            
                            			// Keep track of which events have ever been used, for event optimization
                            			jQuery.event.global[ type ] = true;
                            		}
                            
                            	},
                            
                            	// Detach an event or set of events from an element
                            	remove: function( elem, types, handler, selector, mappedTypes ) {
                            
                            		var j, origCount, tmp,
                            			events, t, handleObj,
                            			special, handlers, type, namespaces, origType,
                            			elemData = dataPriv.hasData( elem ) &amp;&amp; dataPriv.get( elem );
                            
                            		if ( !elemData || !( events = elemData.events ) ) {
                            			return;
                            		}
                            
                            		// Once for each type.namespace in types; type may be omitted
                            		types = ( types || &quot;&quot; ).match( rnothtmlwhite ) || [ &quot;&quot; ];
                            		t = types.length;
                            		while ( t-- ) {
                            			tmp = rtypenamespace.exec( types[ t ] ) || [];
                            			type = origType = tmp[ 1 ];
                            			namespaces = ( tmp[ 2 ] || &quot;&quot; ).split( &quot;.&quot; ).sort();
                            
                            			// Unbind all events (on this namespace, if provided) for the element
                            			if ( !type ) {
                            				for ( type in events ) {
                            					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                            				}
                            				continue;
                            			}
                            
                            			special = jQuery.event.special[ type ] || {};
                            			type = ( selector ? special.delegateType : special.bindType ) || type;
                            			handlers = events[ type ] || [];
                            			tmp = tmp[ 2 ] &amp;&amp;
                            				new RegExp( &quot;(^|\\.)&quot; + namespaces.join( &quot;\\.(?:.*\\.|)&quot; ) + &quot;(\\.|$)&quot; );
                            
                            			// Remove matching events
                            			origCount = j = handlers.length;
                            			while ( j-- ) {
                            				handleObj = handlers[ j ];
                            
                            				if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;
                            					( !handler || handler.guid === handleObj.guid ) &amp;&amp;
                            					( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;
                            					( !selector || selector === handleObj.selector ||
                            						selector === &quot;**&quot; &amp;&amp; handleObj.selector ) ) {
                            					handlers.splice( j, 1 );
                            
                            					if ( handleObj.selector ) {
                            						handlers.delegateCount--;
                            					}
                            					if ( special.remove ) {
                            						special.remove.call( elem, handleObj );
                            					}
                            				}
                            			}
                            
                            			// Remove generic event handler if we removed something and no more handlers exist
                            			// (avoids potential for endless recursion during removal of special event handlers)
                            			if ( origCount &amp;&amp; !handlers.length ) {
                            				if ( !special.teardown ||
                            					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
                            
                            					jQuery.removeEvent( elem, type, elemData.handle );
                            				}
                            
                            				delete events[ type ];
                            			}
                            		}
                            
                            		// Remove data and the expando if it&#x27;s no longer used
                            		if ( jQuery.isEmptyObject( events ) ) {
                            			dataPriv.remove( elem, &quot;handle events&quot; );
                            		}
                            	},
                            
                            	dispatch: function( nativeEvent ) {
                            
                            		// Make a writable jQuery.Event from the native event object
                            		var event = jQuery.event.fix( nativeEvent );
                            
                            		var i, j, ret, matched, handleObj, handlerQueue,
                            			args = new Array( arguments.length ),
                            			handlers = ( dataPriv.get( this, &quot;events&quot; ) || {} )[ event.type ] || [],
                            			special = jQuery.event.special[ event.type ] || {};
                            
                            		// Use the fix-ed jQuery.Event rather than the (read-only) native event
                            		args[ 0 ] = event;
                            
                            		for ( i = 1; i &lt; arguments.length; i++ ) {
                            			args[ i ] = arguments[ i ];
                            		}
                            
                            		event.delegateTarget = this;
                            
                            		// Call the preDispatch hook for the mapped type, and let it bail if desired
                            		if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) {
                            			return;
                            		}
                            
                            		// Determine handlers
                            		handlerQueue = jQuery.event.handlers.call( this, event, handlers );
                            
                            		// Run delegates first; they may want to stop propagation beneath us
                            		i = 0;
                            		while ( ( matched = handlerQueue[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) {
                            			event.currentTarget = matched.elem;
                            
                            			j = 0;
                            			while ( ( handleObj = matched.handlers[ j++ ] ) &amp;&amp;
                            				!event.isImmediatePropagationStopped() ) {
                            
                            				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
                            				// a subset or equal to those in the bound event (both can have no namespace).
                            				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
                            
                            					event.handleObj = handleObj;
                            					event.data = handleObj.data;
                            
                            					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
                            						handleObj.handler ).apply( matched.elem, args );
                            
                            					if ( ret !== undefined ) {
                            						if ( ( event.result = ret ) === false ) {
                            							event.preventDefault();
                            							event.stopPropagation();
                            						}
                            					}
                            				}
                            			}
                            		}
                            
                            		// Call the postDispatch hook for the mapped type
                            		if ( special.postDispatch ) {
                            			special.postDispatch.call( this, event );
                            		}
                            
                            		return event.result;
                            	},
                            
                            	handlers: function( event, handlers ) {
                            		var i, handleObj, sel, matchedHandlers, matchedSelectors,
                            			handlerQueue = [],
                            			delegateCount = handlers.delegateCount,
                            			cur = event.target;
                            
                            		// Find delegate handlers
                            		if ( delegateCount &amp;&amp;
                            
                            			// Support: IE &lt;=9
                            			// Black-hole SVG &lt;use&gt; instance trees (trac-13180)
                            			cur.nodeType &amp;&amp;
                            
                            			// Support: Firefox &lt;=42
                            			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
                            			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
                            			// Support: IE 11 only
                            			// ...but not arrow key &quot;clicks&quot; of radio inputs, which can have &#x60;button&#x60; -1 (gh-2343)
                            			!( event.type === &quot;click&quot; &amp;&amp; event.button &gt;= 1 ) ) {
                            
                            			for ( ; cur !== this; cur = cur.parentNode || this ) {
                            
                            				// Don&#x27;t check non-elements (#13208)
                            				// Don&#x27;t process clicks on disabled elements (#6911, #8165, #11382, #11764)
                            				if ( cur.nodeType === 1 &amp;&amp; !( event.type === &quot;click&quot; &amp;&amp; cur.disabled === true ) ) {
                            					matchedHandlers = [];
                            					matchedSelectors = {};
                            					for ( i = 0; i &lt; delegateCount; i++ ) {
                            						handleObj = handlers[ i ];
                            
                            						// Don&#x27;t conflict with Object.prototype properties (#13203)
                            						sel = handleObj.selector + &quot; &quot;;
                            
                            						if ( matchedSelectors[ sel ] === undefined ) {
                            							matchedSelectors[ sel ] = handleObj.needsContext ?
                            								jQuery( sel, this ).index( cur ) &gt; -1 :
                            								jQuery.find( sel, this, null, [ cur ] ).length;
                            						}
                            						if ( matchedSelectors[ sel ] ) {
                            							matchedHandlers.push( handleObj );
                            						}
                            					}
                            					if ( matchedHandlers.length ) {
                            						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
                            					}
                            				}
                            			}
                            		}
                            
                            		// Add the remaining (directly-bound) handlers
                            		cur = this;
                            		if ( delegateCount &lt; handlers.length ) {
                            			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
                            		}
                            
                            		return handlerQueue;
                            	},
                            
                            	addProp: function( name, hook ) {
                            		Object.defineProperty( jQuery.Event.prototype, name, {
                            			enumerable: true,
                            			configurable: true,
                            
                            			get: jQuery.isFunction( hook ) ?
                            				function() {
                            					if ( this.originalEvent ) {
                            							return hook( this.originalEvent );
                            					}
                            				} :
                            				function() {
                            					if ( this.originalEvent ) {
                            							return this.originalEvent[ name ];
                            					}
                            				},
                            
                            			set: function( value ) {
                            				Object.defineProperty( this, name, {
                            					enumerable: true,
                            					configurable: true,
                            					writable: true,
                            					value: value
                            				} );
                            			}
                            		} );
                            	},
                            
                            	fix: function( originalEvent ) {
                            		return originalEvent[ jQuery.expando ] ?
                            			originalEvent :
                            			new jQuery.Event( originalEvent );
                            	},
                            
                            	special: {
                            		load: {
                            
                            			// Prevent triggered image.load events from bubbling to window.load
                            			noBubble: true
                            		},
                            		focus: {
                            
                            			// Fire native event if possible so blur/focus sequence is correct
                            			trigger: function() {
                            				if ( this !== safeActiveElement() &amp;&amp; this.focus ) {
                            					this.focus();
                            					return false;
                            				}
                            			},
                            			delegateType: &quot;focusin&quot;
                            		},
                            		blur: {
                            			trigger: function() {
                            				if ( this === safeActiveElement() &amp;&amp; this.blur ) {
                            					this.blur();
                            					return false;
                            				}
                            			},
                            			delegateType: &quot;focusout&quot;
                            		},
                            		click: {
                            
                            			// For checkable types, fire native event so checked state will be right
                            			trigger: function() {
                            				if ( rcheckableType.test( this.type ) &amp;&amp;
                            					this.click &amp;&amp; nodeName( this, &quot;input&quot; ) ) {
                            
                            					this.click();
                            					return false;
                            				}
                            			},
                            
                            			// For cross-browser consistency, don&#x27;t fire native .click() on links
                            			_default: function( event ) {
                            				return nodeName( event.target, &quot;a&quot; );
                            			}
                            		},
                            
                            		beforeunload: {
                            			postDispatch: function( event ) {
                            
                            				// Support: Firefox 20+
                            				// Firefox doesn&#x27;t alert if the returnValue field is not set.
                            				if ( event.result !== undefined &amp;&amp; event.originalEvent ) {
                            					event.originalEvent.returnValue = event.result;
                            				}
                            			}
                            		}
                            	}
                            };
                            
                            jQuery.removeEvent = function( elem, type, handle ) {
                            
                            	// This &quot;if&quot; is needed for plain objects
                            	if ( elem.removeEventListener ) {
                            		elem.removeEventListener( type, handle );
                            	}
                            };
                            
                            jQuery.Event = function( src, props ) {
                            
                            	// Allow instantiation without the &#x27;new&#x27; keyword
                            	if ( !( this instanceof jQuery.Event ) ) {
                            		return new jQuery.Event( src, props );
                            	}
                            
                            	// Event object
                            	if ( src &amp;&amp; src.type ) {
                            		this.originalEvent = src;
                            		this.type = src.type;
                            
                            		// Events bubbling up the document may have been marked as prevented
                            		// by a handler lower down the tree; reflect the correct value.
                            		this.isDefaultPrevented = src.defaultPrevented ||
                            				src.defaultPrevented === undefined &amp;&amp;
                            
                            				// Support: Android &lt;=2.3 only
                            				src.returnValue === false ?
                            			returnTrue :
                            			returnFalse;
                            
                            		// Create target properties
                            		// Support: Safari &lt;=6 - 7 only
                            		// Target should not be a text node (#504, #13143)
                            		this.target = ( src.target &amp;&amp; src.target.nodeType === 3 ) ?
                            			src.target.parentNode :
                            			src.target;
                            
                            		this.currentTarget = src.currentTarget;
                            		this.relatedTarget = src.relatedTarget;
                            
                            	// Event type
                            	} else {
                            		this.type = src;
                            	}
                            
                            	// Put explicitly provided properties onto the event object
                            	if ( props ) {
                            		jQuery.extend( this, props );
                            	}
                            
                            	// Create a timestamp if incoming event doesn&#x27;t have one
                            	this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();
                            
                            	// Mark it as fixed
                            	this[ jQuery.expando ] = true;
                            };
                            
                            // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
                            // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
                            jQuery.Event.prototype = {
                            	constructor: jQuery.Event,
                            	isDefaultPrevented: returnFalse,
                            	isPropagationStopped: returnFalse,
                            	isImmediatePropagationStopped: returnFalse,
                            	isSimulated: false,
                            
                            	preventDefault: function() {
                            		var e = this.originalEvent;
                            
                            		this.isDefaultPrevented = returnTrue;
                            
                            		if ( e &amp;&amp; !this.isSimulated ) {
                            			e.preventDefault();
                            		}
                            	},
                            	stopPropagation: function() {
                            		var e = this.originalEvent;
                            
                            		this.isPropagationStopped = returnTrue;
                            
                            		if ( e &amp;&amp; !this.isSimulated ) {
                            			e.stopPropagation();
                            		}
                            	},
                            	stopImmediatePropagation: function() {
                            		var e = this.originalEvent;
                            
                            		this.isImmediatePropagationStopped = returnTrue;
                            
                            		if ( e &amp;&amp; !this.isSimulated ) {
                            			e.stopImmediatePropagation();
                            		}
                            
                            		this.stopPropagation();
                            	}
                            };
                            
                            // Includes all common event props including KeyEvent and MouseEvent specific props
                            jQuery.each( {
                            	altKey: true,
                            	bubbles: true,
                            	cancelable: true,
                            	changedTouches: true,
                            	ctrlKey: true,
                            	detail: true,
                            	eventPhase: true,
                            	metaKey: true,
                            	pageX: true,
                            	pageY: true,
                            	shiftKey: true,
                            	view: true,
                            	&quot;char&quot;: true,
                            	charCode: true,
                            	key: true,
                            	keyCode: true,
                            	button: true,
                            	buttons: true,
                            	clientX: true,
                            	clientY: true,
                            	offsetX: true,
                            	offsetY: true,
                            	pointerId: true,
                            	pointerType: true,
                            	screenX: true,
                            	screenY: true,
                            	targetTouches: true,
                            	toElement: true,
                            	touches: true,
                            
                            	which: function( event ) {
                            		var button = event.button;
                            
                            		// Add which for key events
                            		if ( event.which == null &amp;&amp; rkeyEvent.test( event.type ) ) {
                            			return event.charCode != null ? event.charCode : event.keyCode;
                            		}
                            
                            		// Add which for click: 1 === left; 2 === middle; 3 === right
                            		if ( !event.which &amp;&amp; button !== undefined &amp;&amp; rmouseEvent.test( event.type ) ) {
                            			if ( button &amp; 1 ) {
                            				return 1;
                            			}
                            
                            			if ( button &amp; 2 ) {
                            				return 3;
                            			}
                            
                            			if ( button &amp; 4 ) {
                            				return 2;
                            			}
                            
                            			return 0;
                            		}
                            
                            		return event.which;
                            	}
                            }, jQuery.event.addProp );
                            
                            // Create mouseenter/leave events using mouseover/out and event-time checks
                            // so that event delegation works in jQuery.
                            // Do the same for pointerenter/pointerleave and pointerover/pointerout
                            //
                            // Support: Safari 7 only
                            // Safari sends mouseenter too often; see:
                            // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
                            // for the description of the bug (it existed in older Chrome versions as well).
                            jQuery.each( {
                            	mouseenter: &quot;mouseover&quot;,
                            	mouseleave: &quot;mouseout&quot;,
                            	pointerenter: &quot;pointerover&quot;,
                            	pointerleave: &quot;pointerout&quot;
                            }, function( orig, fix ) {
                            	jQuery.event.special[ orig ] = {
                            		delegateType: fix,
                            		bindType: fix,
                            
                            		handle: function( event ) {
                            			var ret,
                            				target = this,
                            				related = event.relatedTarget,
                            				handleObj = event.handleObj;
                            
                            			// For mouseenter/leave call the handler if related is outside the target.
                            			// NB: No relatedTarget if the mouse left/entered the browser window
                            			if ( !related || ( related !== target &amp;&amp; !jQuery.contains( target, related ) ) ) {
                            				event.type = handleObj.origType;
                            				ret = handleObj.handler.apply( this, arguments );
                            				event.type = fix;
                            			}
                            			return ret;
                            		}
                            	};
                            } );
                            
                            jQuery.fn.extend( {
                            
                            	on: function( types, selector, data, fn ) {
                            		return on( this, types, selector, data, fn );
                            	},
                            	one: function( types, selector, data, fn ) {
                            		return on( this, types, selector, data, fn, 1 );
                            	},
                            	off: function( types, selector, fn ) {
                            		var handleObj, type;
                            		if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {
                            
                            			// ( event )  dispatched jQuery.Event
                            			handleObj = types.handleObj;
                            			jQuery( types.delegateTarget ).off(
                            				handleObj.namespace ?
                            					handleObj.origType + &quot;.&quot; + handleObj.namespace :
                            					handleObj.origType,
                            				handleObj.selector,
                            				handleObj.handler
                            			);
                            			return this;
                            		}
                            		if ( typeof types === &quot;object&quot; ) {
                            
                            			// ( types-object [, selector] )
                            			for ( type in types ) {
                            				this.off( type, selector, types[ type ] );
                            			}
                            			return this;
                            		}
                            		if ( selector === false || typeof selector === &quot;function&quot; ) {
                            
                            			// ( types [, fn] )
                            			fn = selector;
                            			selector = undefined;
                            		}
                            		if ( fn === false ) {
                            			fn = returnFalse;
                            		}
                            		return this.each( function() {
                            			jQuery.event.remove( this, types, fn, selector );
                            		} );
                            	}
                            } );
                            
                            
                            var
                            
                            	/* eslint-disable max-len */
                            
                            	// See https://github.com/eslint/eslint/issues/3229
                            	rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0&gt;\x20\t\r\n\f]*)[^&gt;]*)\/&gt;/gi,
                            
                            	/* eslint-enable */
                            
                            	// Support: IE &lt;=10 - 11, Edge 12 - 13
                            	// In IE/Edge using regex groups here causes severe slowdowns.
                            	// See https://connect.microsoft.com/IE/feedback/details/1736512/
                            	rnoInnerhtml = /&lt;script|&lt;style|&lt;link/i,
                            
                            	// checked=&quot;checked&quot; or checked
                            	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
                            	rscriptTypeMasked = /^true\/(.*)/,
                            	rcleanScript = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g;
                            
                            // Prefer a tbody over its parent table for containing new rows
                            function manipulationTarget( elem, content ) {
                            	if ( nodeName( elem, &quot;table&quot; ) &amp;&amp;
                            		nodeName( content.nodeType !== 11 ? content : content.firstChild, &quot;tr&quot; ) ) {
                            
                            		return jQuery( &quot;&gt;tbody&quot;, elem )[ 0 ] || elem;
                            	}
                            
                            	return elem;
                            }
                            
                            // Replace/restore the type attribute of script elements for safe DOM manipulation
                            function disableScript( elem ) {
                            	elem.type = ( elem.getAttribute( &quot;type&quot; ) !== null ) + &quot;/&quot; + elem.type;
                            	return elem;
                            }
                            function restoreScript( elem ) {
                            	var match = rscriptTypeMasked.exec( elem.type );
                            
                            	if ( match ) {
                            		elem.type = match[ 1 ];
                            	} else {
                            		elem.removeAttribute( &quot;type&quot; );
                            	}
                            
                            	return elem;
                            }
                            
                            function cloneCopyEvent( src, dest ) {
                            	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
                            
                            	if ( dest.nodeType !== 1 ) {
                            		return;
                            	}
                            
                            	// 1. Copy private data: events, handlers, etc.
                            	if ( dataPriv.hasData( src ) ) {
                            		pdataOld = dataPriv.access( src );
                            		pdataCur = dataPriv.set( dest, pdataOld );
                            		events = pdataOld.events;
                            
                            		if ( events ) {
                            			delete pdataCur.handle;
                            			pdataCur.events = {};
                            
                            			for ( type in events ) {
                            				for ( i = 0, l = events[ type ].length; i &lt; l; i++ ) {
                            					jQuery.event.add( dest, type, events[ type ][ i ] );
                            				}
                            			}
                            		}
                            	}
                            
                            	// 2. Copy user data
                            	if ( dataUser.hasData( src ) ) {
                            		udataOld = dataUser.access( src );
                            		udataCur = jQuery.extend( {}, udataOld );
                            
                            		dataUser.set( dest, udataCur );
                            	}
                            }
                            
                            // Fix IE bugs, see support tests
                            function fixInput( src, dest ) {
                            	var nodeName = dest.nodeName.toLowerCase();
                            
                            	// Fails to persist the checked state of a cloned checkbox or radio button.
                            	if ( nodeName === &quot;input&quot; &amp;&amp; rcheckableType.test( src.type ) ) {
                            		dest.checked = src.checked;
                            
                            	// Fails to return the selected option to the default selected state when cloning options
                            	} else if ( nodeName === &quot;input&quot; || nodeName === &quot;textarea&quot; ) {
                            		dest.defaultValue = src.defaultValue;
                            	}
                            }
                            
                            function domManip( collection, args, callback, ignored ) {
                            
                            	// Flatten any nested arrays
                            	args = concat.apply( [], args );
                            
                            	var fragment, first, scripts, hasScripts, node, doc,
                            		i = 0,
                            		l = collection.length,
                            		iNoClone = l - 1,
                            		value = args[ 0 ],
                            		isFunction = jQuery.isFunction( value );
                            
                            	// We can&#x27;t cloneNode fragments that contain checked, in WebKit
                            	if ( isFunction ||
                            			( l &gt; 1 &amp;&amp; typeof value === &quot;string&quot; &amp;&amp;
                            				!support.checkClone &amp;&amp; rchecked.test( value ) ) ) {
                            		return collection.each( function( index ) {
                            			var self = collection.eq( index );
                            			if ( isFunction ) {
                            				args[ 0 ] = value.call( this, index, self.html() );
                            			}
                            			domManip( self, args, callback, ignored );
                            		} );
                            	}
                            
                            	if ( l ) {
                            		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
                            		first = fragment.firstChild;
                            
                            		if ( fragment.childNodes.length === 1 ) {
                            			fragment = first;
                            		}
                            
                            		// Require either new content or an interest in ignored elements to invoke the callback
                            		if ( first || ignored ) {
                            			scripts = jQuery.map( getAll( fragment, &quot;script&quot; ), disableScript );
                            			hasScripts = scripts.length;
                            
                            			// Use the original fragment for the last item
                            			// instead of the first because it can end up
                            			// being emptied incorrectly in certain situations (#8070).
                            			for ( ; i &lt; l; i++ ) {
                            				node = fragment;
                            
                            				if ( i !== iNoClone ) {
                            					node = jQuery.clone( node, true, true );
                            
                            					// Keep references to cloned scripts for later restoration
                            					if ( hasScripts ) {
                            
                            						// Support: Android &lt;=4.0 only, PhantomJS 1 only
                            						// push.apply(_, arraylike) throws on ancient WebKit
                            						jQuery.merge( scripts, getAll( node, &quot;script&quot; ) );
                            					}
                            				}
                            
                            				callback.call( collection[ i ], node, i );
                            			}
                            
                            			if ( hasScripts ) {
                            				doc = scripts[ scripts.length - 1 ].ownerDocument;
                            
                            				// Reenable scripts
                            				jQuery.map( scripts, restoreScript );
                            
                            				// Evaluate executable scripts on first document insertion
                            				for ( i = 0; i &lt; hasScripts; i++ ) {
                            					node = scripts[ i ];
                            					if ( rscriptType.test( node.type || &quot;&quot; ) &amp;&amp;
                            						!dataPriv.access( node, &quot;globalEval&quot; ) &amp;&amp;
                            						jQuery.contains( doc, node ) ) {
                            
                            						if ( node.src ) {
                            
                            							// Optional AJAX dependency, but won&#x27;t run scripts if not present
                            							if ( jQuery._evalUrl ) {
                            								jQuery._evalUrl( node.src );
                            							}
                            						} else {
                            							DOMEval( node.textContent.replace( rcleanScript, &quot;&quot; ), doc );
                            						}
                            					}
                            				}
                            			}
                            		}
                            	}
                            
                            	return collection;
                            }
                            
                            function remove( elem, selector, keepData ) {
                            	var node,
                            		nodes = selector ? jQuery.filter( selector, elem ) : elem,
                            		i = 0;
                            
                            	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
                            		if ( !keepData &amp;&amp; node.nodeType === 1 ) {
                            			jQuery.cleanData( getAll( node ) );
                            		}
                            
                            		if ( node.parentNode ) {
                            			if ( keepData &amp;&amp; jQuery.contains( node.ownerDocument, node ) ) {
                            				setGlobalEval( getAll( node, &quot;script&quot; ) );
                            			}
                            			node.parentNode.removeChild( node );
                            		}
                            	}
                            
                            	return elem;
                            }
                            
                            jQuery.extend( {
                            	htmlPrefilter: function( html ) {
                            		return html.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; );
                            	},
                            
                            	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
                            		var i, l, srcElements, destElements,
                            			clone = elem.cloneNode( true ),
                            			inPage = jQuery.contains( elem.ownerDocument, elem );
                            
                            		// Fix IE cloning issues
                            		if ( !support.noCloneChecked &amp;&amp; ( elem.nodeType === 1 || elem.nodeType === 11 ) &amp;&amp;
                            				!jQuery.isXMLDoc( elem ) ) {
                            
                            			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                            			destElements = getAll( clone );
                            			srcElements = getAll( elem );
                            
                            			for ( i = 0, l = srcElements.length; i &lt; l; i++ ) {
                            				fixInput( srcElements[ i ], destElements[ i ] );
                            			}
                            		}
                            
                            		// Copy the events from the original to the clone
                            		if ( dataAndEvents ) {
                            			if ( deepDataAndEvents ) {
                            				srcElements = srcElements || getAll( elem );
                            				destElements = destElements || getAll( clone );
                            
                            				for ( i = 0, l = srcElements.length; i &lt; l; i++ ) {
                            					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
                            				}
                            			} else {
                            				cloneCopyEvent( elem, clone );
                            			}
                            		}
                            
                            		// Preserve script evaluation history
                            		destElements = getAll( clone, &quot;script&quot; );
                            		if ( destElements.length &gt; 0 ) {
                            			setGlobalEval( destElements, !inPage &amp;&amp; getAll( elem, &quot;script&quot; ) );
                            		}
                            
                            		// Return the cloned set
                            		return clone;
                            	},
                            
                            	cleanData: function( elems ) {
                            		var data, elem, type,
                            			special = jQuery.event.special,
                            			i = 0;
                            
                            		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
                            			if ( acceptData( elem ) ) {
                            				if ( ( data = elem[ dataPriv.expando ] ) ) {
                            					if ( data.events ) {
                            						for ( type in data.events ) {
                            							if ( special[ type ] ) {
                            								jQuery.event.remove( elem, type );
                            
                            							// This is a shortcut to avoid jQuery.event.remove&#x27;s overhead
                            							} else {
                            								jQuery.removeEvent( elem, type, data.handle );
                            							}
                            						}
                            					}
                            
                            					// Support: Chrome &lt;=35 - 45+
                            					// Assign undefined instead of using delete, see Data#remove
                            					elem[ dataPriv.expando ] = undefined;
                            				}
                            				if ( elem[ dataUser.expando ] ) {
                            
                            					// Support: Chrome &lt;=35 - 45+
                            					// Assign undefined instead of using delete, see Data#remove
                            					elem[ dataUser.expando ] = undefined;
                            				}
                            			}
                            		}
                            	}
                            } );
                            
                            jQuery.fn.extend( {
                            	detach: function( selector ) {
                            		return remove( this, selector, true );
                            	},
                            
                            	remove: function( selector ) {
                            		return remove( this, selector );
                            	},
                            
                            	text: function( value ) {
                            		return access( this, function( value ) {
                            			return value === undefined ?
                            				jQuery.text( this ) :
                            				this.empty().each( function() {
                            					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                            						this.textContent = value;
                            					}
                            				} );
                            		}, null, value, arguments.length );
                            	},
                            
                            	append: function() {
                            		return domManip( this, arguments, function( elem ) {
                            			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                            				var target = manipulationTarget( this, elem );
                            				target.appendChild( elem );
                            			}
                            		} );
                            	},
                            
                            	prepend: function() {
                            		return domManip( this, arguments, function( elem ) {
                            			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                            				var target = manipulationTarget( this, elem );
                            				target.insertBefore( elem, target.firstChild );
                            			}
                            		} );
                            	},
                            
                            	before: function() {
                            		return domManip( this, arguments, function( elem ) {
                            			if ( this.parentNode ) {
                            				this.parentNode.insertBefore( elem, this );
                            			}
                            		} );
                            	},
                            
                            	after: function() {
                            		return domManip( this, arguments, function( elem ) {
                            			if ( this.parentNode ) {
                            				this.parentNode.insertBefore( elem, this.nextSibling );
                            			}
                            		} );
                            	},
                            
                            	empty: function() {
                            		var elem,
                            			i = 0;
                            
                            		for ( ; ( elem = this[ i ] ) != null; i++ ) {
                            			if ( elem.nodeType === 1 ) {
                            
                            				// Prevent memory leaks
                            				jQuery.cleanData( getAll( elem, false ) );
                            
                            				// Remove any remaining nodes
                            				elem.textContent = &quot;&quot;;
                            			}
                            		}
                            
                            		return this;
                            	},
                            
                            	clone: function( dataAndEvents, deepDataAndEvents ) {
                            		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                            		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
                            
                            		return this.map( function() {
                            			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
                            		} );
                            	},
                            
                            	html: function( value ) {
                            		return access( this, function( value ) {
                            			var elem = this[ 0 ] || {},
                            				i = 0,
                            				l = this.length;
                            
                            			if ( value === undefined &amp;&amp; elem.nodeType === 1 ) {
                            				return elem.innerHTML;
                            			}
                            
                            			// See if we can take a shortcut and just use innerHTML
                            			if ( typeof value === &quot;string&quot; &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;
                            				!wrapMap[ ( rtagName.exec( value ) || [ &quot;&quot;, &quot;&quot; ] )[ 1 ].toLowerCase() ] ) {
                            
                            				value = jQuery.htmlPrefilter( value );
                            
                            				try {
                            					for ( ; i &lt; l; i++ ) {
                            						elem = this[ i ] || {};
                            
                            						// Remove element nodes and prevent memory leaks
                            						if ( elem.nodeType === 1 ) {
                            							jQuery.cleanData( getAll( elem, false ) );
                            							elem.innerHTML = value;
                            						}
                            					}
                            
                            					elem = 0;
                            
                            				// If using innerHTML throws an exception, use the fallback method
                            				} catch ( e ) {}
                            			}
                            
                            			if ( elem ) {
                            				this.empty().append( value );
                            			}
                            		}, null, value, arguments.length );
                            	},
                            
                            	replaceWith: function() {
                            		var ignored = [];
                            
                            		// Make the changes, replacing each non-ignored context element with the new content
                            		return domManip( this, arguments, function( elem ) {
                            			var parent = this.parentNode;
                            
                            			if ( jQuery.inArray( this, ignored ) &lt; 0 ) {
                            				jQuery.cleanData( getAll( this ) );
                            				if ( parent ) {
                            					parent.replaceChild( elem, this );
                            				}
                            			}
                            
                            		// Force callback invocation
                            		}, ignored );
                            	}
                            } );
                            
                            jQuery.each( {
                            	appendTo: &quot;append&quot;,
                            	prependTo: &quot;prepend&quot;,
                            	insertBefore: &quot;before&quot;,
                            	insertAfter: &quot;after&quot;,
                            	replaceAll: &quot;replaceWith&quot;
                            }, function( name, original ) {
                            	jQuery.fn[ name ] = function( selector ) {
                            		var elems,
                            			ret = [],
                            			insert = jQuery( selector ),
                            			last = insert.length - 1,
                            			i = 0;
                            
                            		for ( ; i &lt;= last; i++ ) {
                            			elems = i === last ? this : this.clone( true );
                            			jQuery( insert[ i ] )[ original ]( elems );
                            
                            			// Support: Android &lt;=4.0 only, PhantomJS 1 only
                            			// .get() because push.apply(_, arraylike) throws on ancient WebKit
                            			push.apply( ret, elems.get() );
                            		}
                            
                            		return this.pushStack( ret );
                            	};
                            } );
                            var rmargin = ( /^margin/ );
                            
                            var rnumnonpx = new RegExp( &quot;^(&quot; + pnum + &quot;)(?!px)[a-z%]+$&quot;, &quot;i&quot; );
                            
                            var getStyles = function( elem ) {
                            
                            		// Support: IE &lt;=11 only, Firefox &lt;=30 (#15098, #14150)
                            		// IE throws on elements created in popups
                            		// FF meanwhile throws on frame elements through &quot;defaultView.getComputedStyle&quot;
                            		var view = elem.ownerDocument.defaultView;
                            
                            		if ( !view || !view.opener ) {
                            			view = window;
                            		}
                            
                            		return view.getComputedStyle( elem );
                            	};
                            
                            
                            
                            ( function() {
                            
                            	// Executing both pixelPosition &amp; boxSizingReliable tests require only one layout
                            	// so they&#x27;re executed at the same time to save the second computation.
                            	function computeStyleTests() {
                            
                            		// This is a singleton, we need to execute it only once
                            		if ( !div ) {
                            			return;
                            		}
                            
                            		div.style.cssText =
                            			&quot;box-sizing:border-box;&quot; +
                            			&quot;position:relative;display:block;&quot; +
                            			&quot;margin:auto;border:1px;padding:1px;&quot; +
                            			&quot;top:1%;width:50%&quot;;
                            		div.innerHTML = &quot;&quot;;
                            		documentElement.appendChild( container );
                            
                            		var divStyle = window.getComputedStyle( div );
                            		pixelPositionVal = divStyle.top !== &quot;1%&quot;;
                            
                            		// Support: Android 4.0 - 4.3 only, Firefox &lt;=3 - 44
                            		reliableMarginLeftVal = divStyle.marginLeft === &quot;2px&quot;;
                            		boxSizingReliableVal = divStyle.width === &quot;4px&quot;;
                            
                            		// Support: Android 4.0 - 4.3 only
                            		// Some styles come back with percentage values, even though they shouldn&#x27;t
                            		div.style.marginRight = &quot;50%&quot;;
                            		pixelMarginRightVal = divStyle.marginRight === &quot;4px&quot;;
                            
                            		documentElement.removeChild( container );
                            
                            		// Nullify the div so it wouldn&#x27;t be stored in the memory and
                            		// it will also be a sign that checks already performed
                            		div = null;
                            	}
                            
                            	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
                            		container = document.createElement( &quot;div&quot; ),
                            		div = document.createElement( &quot;div&quot; );
                            
                            	// Finish early in limited (non-browser) environments
                            	if ( !div.style ) {
                            		return;
                            	}
                            
                            	// Support: IE &lt;=9 - 11 only
                            	// Style of cloned element affects source element cloned (#8908)
                            	div.style.backgroundClip = &quot;content-box&quot;;
                            	div.cloneNode( true ).style.backgroundClip = &quot;&quot;;
                            	support.clearCloneStyle = div.style.backgroundClip === &quot;content-box&quot;;
                            
                            	container.style.cssText = &quot;border:0;width:8px;height:0;top:0;left:-9999px;&quot; +
                            		&quot;padding:0;margin-top:1px;position:absolute&quot;;
                            	container.appendChild( div );
                            
                            	jQuery.extend( support, {
                            		pixelPosition: function() {
                            			computeStyleTests();
                            			return pixelPositionVal;
                            		},
                            		boxSizingReliable: function() {
                            			computeStyleTests();
                            			return boxSizingReliableVal;
                            		},
                            		pixelMarginRight: function() {
                            			computeStyleTests();
                            			return pixelMarginRightVal;
                            		},
                            		reliableMarginLeft: function() {
                            			computeStyleTests();
                            			return reliableMarginLeftVal;
                            		}
                            	} );
                            } )();
                            
                            
                            function curCSS( elem, name, computed ) {
                            	var width, minWidth, maxWidth, ret,
                            		style = elem.style;
                            
                            	computed = computed || getStyles( elem );
                            
                            	// getPropertyValue is needed for:
                            	//   .css(&#x27;filter&#x27;) (IE 9 only, #12537)
                            	//   .css(&#x27;--customProperty) (#3144)
                            	if ( computed ) {
                            		ret = computed.getPropertyValue( name ) || computed[ name ];
                            
                            		if ( ret === &quot;&quot; &amp;&amp; !jQuery.contains( elem.ownerDocument, elem ) ) {
                            			ret = jQuery.style( elem, name );
                            		}
                            
                            		// A tribute to the &quot;awesome hack by Dean Edwards&quot;
                            		// Android Browser returns percentage for some values,
                            		// but width seems to be reliably pixels.
                            		// This is against the CSSOM draft spec:
                            		// https://drafts.csswg.org/cssom/#resolved-values
                            		if ( !support.pixelMarginRight() &amp;&amp; rnumnonpx.test( ret ) &amp;&amp; rmargin.test( name ) ) {
                            
                            			// Remember the original values
                            			width = style.width;
                            			minWidth = style.minWidth;
                            			maxWidth = style.maxWidth;
                            
                            			// Put in the new values to get a computed value out
                            			style.minWidth = style.maxWidth = style.width = ret;
                            			ret = computed.width;
                            
                            			// Revert the changed values
                            			style.width = width;
                            			style.minWidth = minWidth;
                            			style.maxWidth = maxWidth;
                            		}
                            	}
                            
                            	return ret !== undefined ?
                            
                            		// Support: IE &lt;=9 - 11 only
                            		// IE returns zIndex value as an integer.
                            		ret + &quot;&quot; :
                            		ret;
                            }
                            
                            
                            function addGetHookIf( conditionFn, hookFn ) {
                            
                            	// Define the hook, we&#x27;ll check on the first run if it&#x27;s really needed.
                            	return {
                            		get: function() {
                            			if ( conditionFn() ) {
                            
                            				// Hook not needed (or it&#x27;s not possible to use it due
                            				// to missing dependency), remove it.
                            				delete this.get;
                            				return;
                            			}
                            
                            			// Hook needed; redefine it so that the support test is not executed again.
                            			return ( this.get = hookFn ).apply( this, arguments );
                            		}
                            	};
                            }
                            
                            
                            var
                            
                            	// Swappable if display is none or starts with table
                            	// except &quot;table&quot;, &quot;table-cell&quot;, or &quot;table-caption&quot;
                            	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
                            	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
                            	rcustomProp = /^--/,
                            	cssShow = { position: &quot;absolute&quot;, visibility: &quot;hidden&quot;, display: &quot;block&quot; },
                            	cssNormalTransform = {
                            		letterSpacing: &quot;0&quot;,
                            		fontWeight: &quot;400&quot;
                            	},
                            
                            	cssPrefixes = [ &quot;Webkit&quot;, &quot;Moz&quot;, &quot;ms&quot; ],
                            	emptyStyle = document.createElement( &quot;div&quot; ).style;
                            
                            // Return a css property mapped to a potentially vendor prefixed property
                            function vendorPropName( name ) {
                            
                            	// Shortcut for names that are not vendor prefixed
                            	if ( name in emptyStyle ) {
                            		return name;
                            	}
                            
                            	// Check for vendor prefixed names
                            	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
                            		i = cssPrefixes.length;
                            
                            	while ( i-- ) {
                            		name = cssPrefixes[ i ] + capName;
                            		if ( name in emptyStyle ) {
                            			return name;
                            		}
                            	}
                            }
                            
                            // Return a property mapped along what jQuery.cssProps suggests or to
                            // a vendor prefixed property.
                            function finalPropName( name ) {
                            	var ret = jQuery.cssProps[ name ];
                            	if ( !ret ) {
                            		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
                            	}
                            	return ret;
                            }
                            
                            function setPositiveNumber( elem, value, subtract ) {
                            
                            	// Any relative (+/-) values have already been
                            	// normalized at this point
                            	var matches = rcssNum.exec( value );
                            	return matches ?
                            
                            		// Guard against undefined &quot;subtract&quot;, e.g., when used as in cssHooks
                            		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || &quot;px&quot; ) :
                            		value;
                            }
                            
                            function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
                            	var i,
                            		val = 0;
                            
                            	// If we already have the right measurement, avoid augmentation
                            	if ( extra === ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ) ) {
                            		i = 4;
                            
                            	// Otherwise initialize for horizontal or vertical properties
                            	} else {
                            		i = name === &quot;width&quot; ? 1 : 0;
                            	}
                            
                            	for ( ; i &lt; 4; i += 2 ) {
                            
                            		// Both box models exclude margin, so add it if we want it
                            		if ( extra === &quot;margin&quot; ) {
                            			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
                            		}
                            
                            		if ( isBorderBox ) {
                            
                            			// border-box includes padding, so remove it if we want content
                            			if ( extra === &quot;content&quot; ) {
                            				val -= jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );
                            			}
                            
                            			// At this point, extra isn&#x27;t border nor margin, so remove border
                            			if ( extra !== &quot;margin&quot; ) {
                            				val -= jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
                            			}
                            		} else {
                            
                            			// At this point, extra isn&#x27;t content, so add padding
                            			val += jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );
                            
                            			// At this point, extra isn&#x27;t content nor padding, so add border
                            			if ( extra !== &quot;padding&quot; ) {
                            				val += jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
                            			}
                            		}
                            	}
                            
                            	return val;
                            }
                            
                            function getWidthOrHeight( elem, name, extra ) {
                            
                            	// Start with computed style
                            	var valueIsBorderBox,
                            		styles = getStyles( elem ),
                            		val = curCSS( elem, name, styles ),
                            		isBorderBox = jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;;
                            
                            	// Computed unit is not pixels. Stop here and return.
                            	if ( rnumnonpx.test( val ) ) {
                            		return val;
                            	}
                            
                            	// Check for style in case a browser which returns unreliable values
                            	// for getComputedStyle silently falls back to the reliable elem.style
                            	valueIsBorderBox = isBorderBox &amp;&amp;
                            		( support.boxSizingReliable() || val === elem.style[ name ] );
                            
                            	// Normalize &quot;&quot;, auto, and prepare for extra
                            	val = parseFloat( val ) || 0;
                            
                            	// Use the active box-sizing model to add/subtract irrelevant styles
                            	return ( val +
                            		augmentWidthOrHeight(
                            			elem,
                            			name,
                            			extra || ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ),
                            			valueIsBorderBox,
                            			styles
                            		)
                            	) + &quot;px&quot;;
                            }
                            
                            jQuery.extend( {
                            
                            	// Add in style property hooks for overriding the default
                            	// behavior of getting and setting a style property
                            	cssHooks: {
                            		opacity: {
                            			get: function( elem, computed ) {
                            				if ( computed ) {
                            
                            					// We should always get a number back from opacity
                            					var ret = curCSS( elem, &quot;opacity&quot; );
                            					return ret === &quot;&quot; ? &quot;1&quot; : ret;
                            				}
                            			}
                            		}
                            	},
                            
                            	// Don&#x27;t automatically add &quot;px&quot; to these possibly-unitless properties
                            	cssNumber: {
                            		&quot;animationIterationCount&quot;: true,
                            		&quot;columnCount&quot;: true,
                            		&quot;fillOpacity&quot;: true,
                            		&quot;flexGrow&quot;: true,
                            		&quot;flexShrink&quot;: true,
                            		&quot;fontWeight&quot;: true,
                            		&quot;lineHeight&quot;: true,
                            		&quot;opacity&quot;: true,
                            		&quot;order&quot;: true,
                            		&quot;orphans&quot;: true,
                            		&quot;widows&quot;: true,
                            		&quot;zIndex&quot;: true,
                            		&quot;zoom&quot;: true
                            	},
                            
                            	// Add in properties whose names you wish to fix before
                            	// setting or getting the value
                            	cssProps: {
                            		&quot;float&quot;: &quot;cssFloat&quot;
                            	},
                            
                            	// Get and set the style property on a DOM Node
                            	style: function( elem, name, value, extra ) {
                            
                            		// Don&#x27;t set styles on text and comment nodes
                            		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                            			return;
                            		}
                            
                            		// Make sure that we&#x27;re working with the right name
                            		var ret, type, hooks,
                            			origName = jQuery.camelCase( name ),
                            			isCustomProp = rcustomProp.test( name ),
                            			style = elem.style;
                            
                            		// Make sure that we&#x27;re working with the right name. We don&#x27;t
                            		// want to query the value if it is a CSS custom property
                            		// since they are user-defined.
                            		if ( !isCustomProp ) {
                            			name = finalPropName( origName );
                            		}
                            
                            		// Gets hook for the prefixed version, then unprefixed version
                            		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
                            
                            		// Check if we&#x27;re setting a value
                            		if ( value !== undefined ) {
                            			type = typeof value;
                            
                            			// Convert &quot;+=&quot; or &quot;-=&quot; to relative numbers (#7345)
                            			if ( type === &quot;string&quot; &amp;&amp; ( ret = rcssNum.exec( value ) ) &amp;&amp; ret[ 1 ] ) {
                            				value = adjustCSS( elem, name, ret );
                            
                            				// Fixes bug #9237
                            				type = &quot;number&quot;;
                            			}
                            
                            			// Make sure that null and NaN values aren&#x27;t set (#7116)
                            			if ( value == null || value !== value ) {
                            				return;
                            			}
                            
                            			// If a number was passed in, add the unit (except for certain CSS properties)
                            			if ( type === &quot;number&quot; ) {
                            				value += ret &amp;&amp; ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? &quot;&quot; : &quot;px&quot; );
                            			}
                            
                            			// background-* props affect original clone&#x27;s values
                            			if ( !support.clearCloneStyle &amp;&amp; value === &quot;&quot; &amp;&amp; name.indexOf( &quot;background&quot; ) === 0 ) {
                            				style[ name ] = &quot;inherit&quot;;
                            			}
                            
                            			// If a hook was provided, use that value, otherwise just set the specified value
                            			if ( !hooks || !( &quot;set&quot; in hooks ) ||
                            				( value = hooks.set( elem, value, extra ) ) !== undefined ) {
                            
                            				if ( isCustomProp ) {
                            					style.setProperty( name, value );
                            				} else {
                            					style[ name ] = value;
                            				}
                            			}
                            
                            		} else {
                            
                            			// If a hook was provided get the non-computed value from there
                            			if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp;
                            				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
                            
                            				return ret;
                            			}
                            
                            			// Otherwise just get the value from the style object
                            			return style[ name ];
                            		}
                            	},
                            
                            	css: function( elem, name, extra, styles ) {
                            		var val, num, hooks,
                            			origName = jQuery.camelCase( name ),
                            			isCustomProp = rcustomProp.test( name );
                            
                            		// Make sure that we&#x27;re working with the right name. We don&#x27;t
                            		// want to modify the value if it is a CSS custom property
                            		// since they are user-defined.
                            		if ( !isCustomProp ) {
                            			name = finalPropName( origName );
                            		}
                            
                            		// Try prefixed name followed by the unprefixed name
                            		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
                            
                            		// If a hook was provided get the computed value from there
                            		if ( hooks &amp;&amp; &quot;get&quot; in hooks ) {
                            			val = hooks.get( elem, true, extra );
                            		}
                            
                            		// Otherwise, if a way to get the computed value exists, use that
                            		if ( val === undefined ) {
                            			val = curCSS( elem, name, styles );
                            		}
                            
                            		// Convert &quot;normal&quot; to computed value
                            		if ( val === &quot;normal&quot; &amp;&amp; name in cssNormalTransform ) {
                            			val = cssNormalTransform[ name ];
                            		}
                            
                            		// Make numeric if forced or a qualifier was provided and val looks numeric
                            		if ( extra === &quot;&quot; || extra ) {
                            			num = parseFloat( val );
                            			return extra === true || isFinite( num ) ? num || 0 : val;
                            		}
                            
                            		return val;
                            	}
                            } );
                            
                            jQuery.each( [ &quot;height&quot;, &quot;width&quot; ], function( i, name ) {
                            	jQuery.cssHooks[ name ] = {
                            		get: function( elem, computed, extra ) {
                            			if ( computed ) {
                            
                            				// Certain elements can have dimension info if we invisibly show them
                            				// but it must have a current display style that would benefit
                            				return rdisplayswap.test( jQuery.css( elem, &quot;display&quot; ) ) &amp;&amp;
                            
                            					// Support: Safari 8+
                            					// Table columns in Safari have non-zero offsetWidth &amp; zero
                            					// getBoundingClientRect().width unless display is changed.
                            					// Support: IE &lt;=11 only
                            					// Running getBoundingClientRect on a disconnected node
                            					// in IE throws an error.
                            					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
                            						swap( elem, cssShow, function() {
                            							return getWidthOrHeight( elem, name, extra );
                            						} ) :
                            						getWidthOrHeight( elem, name, extra );
                            			}
                            		},
                            
                            		set: function( elem, value, extra ) {
                            			var matches,
                            				styles = extra &amp;&amp; getStyles( elem ),
                            				subtract = extra &amp;&amp; augmentWidthOrHeight(
                            					elem,
                            					name,
                            					extra,
                            					jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;,
                            					styles
                            				);
                            
                            			// Convert to pixels if value adjustment is needed
                            			if ( subtract &amp;&amp; ( matches = rcssNum.exec( value ) ) &amp;&amp;
                            				( matches[ 3 ] || &quot;px&quot; ) !== &quot;px&quot; ) {
                            
                            				elem.style[ name ] = value;
                            				value = jQuery.css( elem, name );
                            			}
                            
                            			return setPositiveNumber( elem, value, subtract );
                            		}
                            	};
                            } );
                            
                            jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
                            	function( elem, computed ) {
                            		if ( computed ) {
                            			return ( parseFloat( curCSS( elem, &quot;marginLeft&quot; ) ) ||
                            				elem.getBoundingClientRect().left -
                            					swap( elem, { marginLeft: 0 }, function() {
                            						return elem.getBoundingClientRect().left;
                            					} )
                            				) + &quot;px&quot;;
                            		}
                            	}
                            );
                            
                            // These hooks are used by animate to expand properties
                            jQuery.each( {
                            	margin: &quot;&quot;,
                            	padding: &quot;&quot;,
                            	border: &quot;Width&quot;
                            }, function( prefix, suffix ) {
                            	jQuery.cssHooks[ prefix + suffix ] = {
                            		expand: function( value ) {
                            			var i = 0,
                            				expanded = {},
                            
                            				// Assumes a single number if not a string
                            				parts = typeof value === &quot;string&quot; ? value.split( &quot; &quot; ) : [ value ];
                            
                            			for ( ; i &lt; 4; i++ ) {
                            				expanded[ prefix + cssExpand[ i ] + suffix ] =
                            					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                            			}
                            
                            			return expanded;
                            		}
                            	};
                            
                            	if ( !rmargin.test( prefix ) ) {
                            		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
                            	}
                            } );
                            
                            jQuery.fn.extend( {
                            	css: function( name, value ) {
                            		return access( this, function( elem, name, value ) {
                            			var styles, len,
                            				map = {},
                            				i = 0;
                            
                            			if ( Array.isArray( name ) ) {
                            				styles = getStyles( elem );
                            				len = name.length;
                            
                            				for ( ; i &lt; len; i++ ) {
                            					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                            				}
                            
                            				return map;
                            			}
                            
                            			return value !== undefined ?
                            				jQuery.style( elem, name, value ) :
                            				jQuery.css( elem, name );
                            		}, name, value, arguments.length &gt; 1 );
                            	}
                            } );
                            
                            
                            function Tween( elem, options, prop, end, easing ) {
                            	return new Tween.prototype.init( elem, options, prop, end, easing );
                            }
                            jQuery.Tween = Tween;
                            
                            Tween.prototype = {
                            	constructor: Tween,
                            	init: function( elem, options, prop, end, easing, unit ) {
                            		this.elem = elem;
                            		this.prop = prop;
                            		this.easing = easing || jQuery.easing._default;
                            		this.options = options;
                            		this.start = this.now = this.cur();
                            		this.end = end;
                            		this.unit = unit || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; );
                            	},
                            	cur: function() {
                            		var hooks = Tween.propHooks[ this.prop ];
                            
                            		return hooks &amp;&amp; hooks.get ?
                            			hooks.get( this ) :
                            			Tween.propHooks._default.get( this );
                            	},
                            	run: function( percent ) {
                            		var eased,
                            			hooks = Tween.propHooks[ this.prop ];
                            
                            		if ( this.options.duration ) {
                            			this.pos = eased = jQuery.easing[ this.easing ](
                            				percent, this.options.duration * percent, 0, 1, this.options.duration
                            			);
                            		} else {
                            			this.pos = eased = percent;
                            		}
                            		this.now = ( this.end - this.start ) * eased + this.start;
                            
                            		if ( this.options.step ) {
                            			this.options.step.call( this.elem, this.now, this );
                            		}
                            
                            		if ( hooks &amp;&amp; hooks.set ) {
                            			hooks.set( this );
                            		} else {
                            			Tween.propHooks._default.set( this );
                            		}
                            		return this;
                            	}
                            };
                            
                            Tween.prototype.init.prototype = Tween.prototype;
                            
                            Tween.propHooks = {
                            	_default: {
                            		get: function( tween ) {
                            			var result;
                            
                            			// Use a property on the element directly when it is not a DOM element,
                            			// or when there is no matching style property that exists.
                            			if ( tween.elem.nodeType !== 1 ||
                            				tween.elem[ tween.prop ] != null &amp;&amp; tween.elem.style[ tween.prop ] == null ) {
                            				return tween.elem[ tween.prop ];
                            			}
                            
                            			// Passing an empty string as a 3rd parameter to .css will automatically
                            			// attempt a parseFloat and fallback to a string if the parse fails.
                            			// Simple values such as &quot;10px&quot; are parsed to Float;
                            			// complex values such as &quot;rotate(1rad)&quot; are returned as-is.
                            			result = jQuery.css( tween.elem, tween.prop, &quot;&quot; );
                            
                            			// Empty strings, null, undefined and &quot;auto&quot; are converted to 0.
                            			return !result || result === &quot;auto&quot; ? 0 : result;
                            		},
                            		set: function( tween ) {
                            
                            			// Use step hook for back compat.
                            			// Use cssHook if its there.
                            			// Use .style if available and use plain properties where available.
                            			if ( jQuery.fx.step[ tween.prop ] ) {
                            				jQuery.fx.step[ tween.prop ]( tween );
                            			} else if ( tween.elem.nodeType === 1 &amp;&amp;
                            				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
                            					jQuery.cssHooks[ tween.prop ] ) ) {
                            				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
                            			} else {
                            				tween.elem[ tween.prop ] = tween.now;
                            			}
                            		}
                            	}
                            };
                            
                            // Support: IE &lt;=9 only
                            // Panic based approach to setting things on disconnected nodes
                            Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                            	set: function( tween ) {
                            		if ( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) {
                            			tween.elem[ tween.prop ] = tween.now;
                            		}
                            	}
                            };
                            
                            jQuery.easing = {
                            	linear: function( p ) {
                            		return p;
                            	},
                            	swing: function( p ) {
                            		return 0.5 - Math.cos( p * Math.PI ) / 2;
                            	},
                            	_default: &quot;swing&quot;
                            };
                            
                            jQuery.fx = Tween.prototype.init;
                            
                            // Back compat &lt;1.8 extension point
                            jQuery.fx.step = {};
                            
                            
                            
                            
                            var
                            	fxNow, inProgress,
                            	rfxtypes = /^(?:toggle|show|hide)$/,
                            	rrun = /queueHooks$/;
                            
                            function schedule() {
                            	if ( inProgress ) {
                            		if ( document.hidden === false &amp;&amp; window.requestAnimationFrame ) {
                            			window.requestAnimationFrame( schedule );
                            		} else {
                            			window.setTimeout( schedule, jQuery.fx.interval );
                            		}
                            
                            		jQuery.fx.tick();
                            	}
                            }
                            
                            // Animations created synchronously will run synchronously
                            function createFxNow() {
                            	window.setTimeout( function() {
                            		fxNow = undefined;
                            	} );
                            	return ( fxNow = jQuery.now() );
                            }
                            
                            // Generate parameters to create a standard animation
                            function genFx( type, includeWidth ) {
                            	var which,
                            		i = 0,
                            		attrs = { height: type };
                            
                            	// If we include width, step value is 1 to do all cssExpand values,
                            	// otherwise step value is 2 to skip over Left and Right
                            	includeWidth = includeWidth ? 1 : 0;
                            	for ( ; i &lt; 4; i += 2 - includeWidth ) {
                            		which = cssExpand[ i ];
                            		attrs[ &quot;margin&quot; + which ] = attrs[ &quot;padding&quot; + which ] = type;
                            	}
                            
                            	if ( includeWidth ) {
                            		attrs.opacity = attrs.width = type;
                            	}
                            
                            	return attrs;
                            }
                            
                            function createTween( value, prop, animation ) {
                            	var tween,
                            		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ &quot;*&quot; ] ),
                            		index = 0,
                            		length = collection.length;
                            	for ( ; index &lt; length; index++ ) {
                            		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
                            
                            			// We&#x27;re done with this property
                            			return tween;
                            		}
                            	}
                            }
                            
                            function defaultPrefilter( elem, props, opts ) {
                            	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
                            		isBox = &quot;width&quot; in props || &quot;height&quot; in props,
                            		anim = this,
                            		orig = {},
                            		style = elem.style,
                            		hidden = elem.nodeType &amp;&amp; isHiddenWithinTree( elem ),
                            		dataShow = dataPriv.get( elem, &quot;fxshow&quot; );
                            
                            	// Queue-skipping animations hijack the fx hooks
                            	if ( !opts.queue ) {
                            		hooks = jQuery._queueHooks( elem, &quot;fx&quot; );
                            		if ( hooks.unqueued == null ) {
                            			hooks.unqueued = 0;
                            			oldfire = hooks.empty.fire;
                            			hooks.empty.fire = function() {
                            				if ( !hooks.unqueued ) {
                            					oldfire();
                            				}
                            			};
                            		}
                            		hooks.unqueued++;
                            
                            		anim.always( function() {
                            
                            			// Ensure the complete handler is called before this completes
                            			anim.always( function() {
                            				hooks.unqueued--;
                            				if ( !jQuery.queue( elem, &quot;fx&quot; ).length ) {
                            					hooks.empty.fire();
                            				}
                            			} );
                            		} );
                            	}
                            
                            	// Detect show/hide animations
                            	for ( prop in props ) {
                            		value = props[ prop ];
                            		if ( rfxtypes.test( value ) ) {
                            			delete props[ prop ];
                            			toggle = toggle || value === &quot;toggle&quot;;
                            			if ( value === ( hidden ? &quot;hide&quot; : &quot;show&quot; ) ) {
                            
                            				// Pretend to be hidden if this is a &quot;show&quot; and
                            				// there is still data from a stopped show/hide
                            				if ( value === &quot;show&quot; &amp;&amp; dataShow &amp;&amp; dataShow[ prop ] !== undefined ) {
                            					hidden = true;
                            
                            				// Ignore all other no-op show/hide data
                            				} else {
                            					continue;
                            				}
                            			}
                            			orig[ prop ] = dataShow &amp;&amp; dataShow[ prop ] || jQuery.style( elem, prop );
                            		}
                            	}
                            
                            	// Bail out if this is a no-op like .hide().hide()
                            	propTween = !jQuery.isEmptyObject( props );
                            	if ( !propTween &amp;&amp; jQuery.isEmptyObject( orig ) ) {
                            		return;
                            	}
                            
                            	// Restrict &quot;overflow&quot; and &quot;display&quot; styles during box animations
                            	if ( isBox &amp;&amp; elem.nodeType === 1 ) {
                            
                            		// Support: IE &lt;=9 - 11, Edge 12 - 13
                            		// Record all 3 overflow attributes because IE does not infer the shorthand
                            		// from identically-valued overflowX and overflowY
                            		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
                            
                            		// Identify a display type, preferring old show/hide data over the CSS cascade
                            		restoreDisplay = dataShow &amp;&amp; dataShow.display;
                            		if ( restoreDisplay == null ) {
                            			restoreDisplay = dataPriv.get( elem, &quot;display&quot; );
                            		}
                            		display = jQuery.css( elem, &quot;display&quot; );
                            		if ( display === &quot;none&quot; ) {
                            			if ( restoreDisplay ) {
                            				display = restoreDisplay;
                            			} else {
                            
                            				// Get nonempty value(s) by temporarily forcing visibility
                            				showHide( [ elem ], true );
                            				restoreDisplay = elem.style.display || restoreDisplay;
                            				display = jQuery.css( elem, &quot;display&quot; );
                            				showHide( [ elem ] );
                            			}
                            		}
                            
                            		// Animate inline elements as inline-block
                            		if ( display === &quot;inline&quot; || display === &quot;inline-block&quot; &amp;&amp; restoreDisplay != null ) {
                            			if ( jQuery.css( elem, &quot;float&quot; ) === &quot;none&quot; ) {
                            
                            				// Restore the original display value at the end of pure show/hide animations
                            				if ( !propTween ) {
                            					anim.done( function() {
                            						style.display = restoreDisplay;
                            					} );
                            					if ( restoreDisplay == null ) {
                            						display = style.display;
                            						restoreDisplay = display === &quot;none&quot; ? &quot;&quot; : display;
                            					}
                            				}
                            				style.display = &quot;inline-block&quot;;
                            			}
                            		}
                            	}
                            
                            	if ( opts.overflow ) {
                            		style.overflow = &quot;hidden&quot;;
                            		anim.always( function() {
                            			style.overflow = opts.overflow[ 0 ];
                            			style.overflowX = opts.overflow[ 1 ];
                            			style.overflowY = opts.overflow[ 2 ];
                            		} );
                            	}
                            
                            	// Implement show/hide animations
                            	propTween = false;
                            	for ( prop in orig ) {
                            
                            		// General show/hide setup for this element animation
                            		if ( !propTween ) {
                            			if ( dataShow ) {
                            				if ( &quot;hidden&quot; in dataShow ) {
                            					hidden = dataShow.hidden;
                            				}
                            			} else {
                            				dataShow = dataPriv.access( elem, &quot;fxshow&quot;, { display: restoreDisplay } );
                            			}
                            
                            			// Store hidden/visible for toggle so &#x60;.stop().toggle()&#x60; &quot;reverses&quot;
                            			if ( toggle ) {
                            				dataShow.hidden = !hidden;
                            			}
                            
                            			// Show elements before animating them
                            			if ( hidden ) {
                            				showHide( [ elem ], true );
                            			}
                            
                            			/* eslint-disable no-loop-func */
                            
                            			anim.done( function() {
                            
                            			/* eslint-enable no-loop-func */
                            
                            				// The final step of a &quot;hide&quot; animation is actually hiding the element
                            				if ( !hidden ) {
                            					showHide( [ elem ] );
                            				}
                            				dataPriv.remove( elem, &quot;fxshow&quot; );
                            				for ( prop in orig ) {
                            					jQuery.style( elem, prop, orig[ prop ] );
                            				}
                            			} );
                            		}
                            
                            		// Per-property setup
                            		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
                            		if ( !( prop in dataShow ) ) {
                            			dataShow[ prop ] = propTween.start;
                            			if ( hidden ) {
                            				propTween.end = propTween.start;
                            				propTween.start = 0;
                            			}
                            		}
                            	}
                            }
                            
                            function propFilter( props, specialEasing ) {
                            	var index, name, easing, value, hooks;
                            
                            	// camelCase, specialEasing and expand cssHook pass
                            	for ( index in props ) {
                            		name = jQuery.camelCase( index );
                            		easing = specialEasing[ name ];
                            		value = props[ index ];
                            		if ( Array.isArray( value ) ) {
                            			easing = value[ 1 ];
                            			value = props[ index ] = value[ 0 ];
                            		}
                            
                            		if ( index !== name ) {
                            			props[ name ] = value;
                            			delete props[ index ];
                            		}
                            
                            		hooks = jQuery.cssHooks[ name ];
                            		if ( hooks &amp;&amp; &quot;expand&quot; in hooks ) {
                            			value = hooks.expand( value );
                            			delete props[ name ];
                            
                            			// Not quite $.extend, this won&#x27;t overwrite existing keys.
                            			// Reusing &#x27;index&#x27; because we have the correct &quot;name&quot;
                            			for ( index in value ) {
                            				if ( !( index in props ) ) {
                            					props[ index ] = value[ index ];
                            					specialEasing[ index ] = easing;
                            				}
                            			}
                            		} else {
                            			specialEasing[ name ] = easing;
                            		}
                            	}
                            }
                            
                            function Animation( elem, properties, options ) {
                            	var result,
                            		stopped,
                            		index = 0,
                            		length = Animation.prefilters.length,
                            		deferred = jQuery.Deferred().always( function() {
                            
                            			// Don&#x27;t match elem in the :animated selector
                            			delete tick.elem;
                            		} ),
                            		tick = function() {
                            			if ( stopped ) {
                            				return false;
                            			}
                            			var currentTime = fxNow || createFxNow(),
                            				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
                            
                            				// Support: Android 2.3 only
                            				// Archaic crash bug won&#x27;t allow us to use &#x60;1 - ( 0.5 || 0 )&#x60; (#12497)
                            				temp = remaining / animation.duration || 0,
                            				percent = 1 - temp,
                            				index = 0,
                            				length = animation.tweens.length;
                            
                            			for ( ; index &lt; length; index++ ) {
                            				animation.tweens[ index ].run( percent );
                            			}
                            
                            			deferred.notifyWith( elem, [ animation, percent, remaining ] );
                            
                            			// If there&#x27;s more to do, yield
                            			if ( percent &lt; 1 &amp;&amp; length ) {
                            				return remaining;
                            			}
                            
                            			// If this was an empty animation, synthesize a final progress notification
                            			if ( !length ) {
                            				deferred.notifyWith( elem, [ animation, 1, 0 ] );
                            			}
                            
                            			// Resolve the animation and report its conclusion
                            			deferred.resolveWith( elem, [ animation ] );
                            			return false;
                            		},
                            		animation = deferred.promise( {
                            			elem: elem,
                            			props: jQuery.extend( {}, properties ),
                            			opts: jQuery.extend( true, {
                            				specialEasing: {},
                            				easing: jQuery.easing._default
                            			}, options ),
                            			originalProperties: properties,
                            			originalOptions: options,
                            			startTime: fxNow || createFxNow(),
                            			duration: options.duration,
                            			tweens: [],
                            			createTween: function( prop, end ) {
                            				var tween = jQuery.Tween( elem, animation.opts, prop, end,
                            						animation.opts.specialEasing[ prop ] || animation.opts.easing );
                            				animation.tweens.push( tween );
                            				return tween;
                            			},
                            			stop: function( gotoEnd ) {
                            				var index = 0,
                            
                            					// If we are going to the end, we want to run all the tweens
                            					// otherwise we skip this part
                            					length = gotoEnd ? animation.tweens.length : 0;
                            				if ( stopped ) {
                            					return this;
                            				}
                            				stopped = true;
                            				for ( ; index &lt; length; index++ ) {
                            					animation.tweens[ index ].run( 1 );
                            				}
                            
                            				// Resolve when we played the last frame; otherwise, reject
                            				if ( gotoEnd ) {
                            					deferred.notifyWith( elem, [ animation, 1, 0 ] );
                            					deferred.resolveWith( elem, [ animation, gotoEnd ] );
                            				} else {
                            					deferred.rejectWith( elem, [ animation, gotoEnd ] );
                            				}
                            				return this;
                            			}
                            		} ),
                            		props = animation.props;
                            
                            	propFilter( props, animation.opts.specialEasing );
                            
                            	for ( ; index &lt; length; index++ ) {
                            		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
                            		if ( result ) {
                            			if ( jQuery.isFunction( result.stop ) ) {
                            				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
                            					jQuery.proxy( result.stop, result );
                            			}
                            			return result;
                            		}
                            	}
                            
                            	jQuery.map( props, createTween, animation );
                            
                            	if ( jQuery.isFunction( animation.opts.start ) ) {
                            		animation.opts.start.call( elem, animation );
                            	}
                            
                            	// Attach callbacks from options
                            	animation
                            		.progress( animation.opts.progress )
                            		.done( animation.opts.done, animation.opts.complete )
                            		.fail( animation.opts.fail )
                            		.always( animation.opts.always );
                            
                            	jQuery.fx.timer(
                            		jQuery.extend( tick, {
                            			elem: elem,
                            			anim: animation,
                            			queue: animation.opts.queue
                            		} )
                            	);
                            
                            	return animation;
                            }
                            
                            jQuery.Animation = jQuery.extend( Animation, {
                            
                            	tweeners: {
                            		&quot;*&quot;: [ function( prop, value ) {
                            			var tween = this.createTween( prop, value );
                            			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
                            			return tween;
                            		} ]
                            	},
                            
                            	tweener: function( props, callback ) {
                            		if ( jQuery.isFunction( props ) ) {
                            			callback = props;
                            			props = [ &quot;*&quot; ];
                            		} else {
                            			props = props.match( rnothtmlwhite );
                            		}
                            
                            		var prop,
                            			index = 0,
                            			length = props.length;
                            
                            		for ( ; index &lt; length; index++ ) {
                            			prop = props[ index ];
                            			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
                            			Animation.tweeners[ prop ].unshift( callback );
                            		}
                            	},
                            
                            	prefilters: [ defaultPrefilter ],
                            
                            	prefilter: function( callback, prepend ) {
                            		if ( prepend ) {
                            			Animation.prefilters.unshift( callback );
                            		} else {
                            			Animation.prefilters.push( callback );
                            		}
                            	}
                            } );
                            
                            jQuery.speed = function( speed, easing, fn ) {
                            	var opt = speed &amp;&amp; typeof speed === &quot;object&quot; ? jQuery.extend( {}, speed ) : {
                            		complete: fn || !fn &amp;&amp; easing ||
                            			jQuery.isFunction( speed ) &amp;&amp; speed,
                            		duration: speed,
                            		easing: fn &amp;&amp; easing || easing &amp;&amp; !jQuery.isFunction( easing ) &amp;&amp; easing
                            	};
                            
                            	// Go to the end state if fx are off
                            	if ( jQuery.fx.off ) {
                            		opt.duration = 0;
                            
                            	} else {
                            		if ( typeof opt.duration !== &quot;number&quot; ) {
                            			if ( opt.duration in jQuery.fx.speeds ) {
                            				opt.duration = jQuery.fx.speeds[ opt.duration ];
                            
                            			} else {
                            				opt.duration = jQuery.fx.speeds._default;
                            			}
                            		}
                            	}
                            
                            	// Normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot;
                            	if ( opt.queue == null || opt.queue === true ) {
                            		opt.queue = &quot;fx&quot;;
                            	}
                            
                            	// Queueing
                            	opt.old = opt.complete;
                            
                            	opt.complete = function() {
                            		if ( jQuery.isFunction( opt.old ) ) {
                            			opt.old.call( this );
                            		}
                            
                            		if ( opt.queue ) {
                            			jQuery.dequeue( this, opt.queue );
                            		}
                            	};
                            
                            	return opt;
                            };
                            
                            jQuery.fn.extend( {
                            	fadeTo: function( speed, to, easing, callback ) {
                            
                            		// Show any hidden elements after setting opacity to 0
                            		return this.filter( isHiddenWithinTree ).css( &quot;opacity&quot;, 0 ).show()
                            
                            			// Animate to the value specified
                            			.end().animate( { opacity: to }, speed, easing, callback );
                            	},
                            	animate: function( prop, speed, easing, callback ) {
                            		var empty = jQuery.isEmptyObject( prop ),
                            			optall = jQuery.speed( speed, easing, callback ),
                            			doAnimation = function() {
                            
                            				// Operate on a copy of prop so per-property easing won&#x27;t be lost
                            				var anim = Animation( this, jQuery.extend( {}, prop ), optall );
                            
                            				// Empty animations, or finishing resolves immediately
                            				if ( empty || dataPriv.get( this, &quot;finish&quot; ) ) {
                            					anim.stop( true );
                            				}
                            			};
                            			doAnimation.finish = doAnimation;
                            
                            		return empty || optall.queue === false ?
                            			this.each( doAnimation ) :
                            			this.queue( optall.queue, doAnimation );
                            	},
                            	stop: function( type, clearQueue, gotoEnd ) {
                            		var stopQueue = function( hooks ) {
                            			var stop = hooks.stop;
                            			delete hooks.stop;
                            			stop( gotoEnd );
                            		};
                            
                            		if ( typeof type !== &quot;string&quot; ) {
                            			gotoEnd = clearQueue;
                            			clearQueue = type;
                            			type = undefined;
                            		}
                            		if ( clearQueue &amp;&amp; type !== false ) {
                            			this.queue( type || &quot;fx&quot;, [] );
                            		}
                            
                            		return this.each( function() {
                            			var dequeue = true,
                            				index = type != null &amp;&amp; type + &quot;queueHooks&quot;,
                            				timers = jQuery.timers,
                            				data = dataPriv.get( this );
                            
                            			if ( index ) {
                            				if ( data[ index ] &amp;&amp; data[ index ].stop ) {
                            					stopQueue( data[ index ] );
                            				}
                            			} else {
                            				for ( index in data ) {
                            					if ( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) {
                            						stopQueue( data[ index ] );
                            					}
                            				}
                            			}
                            
                            			for ( index = timers.length; index--; ) {
                            				if ( timers[ index ].elem === this &amp;&amp;
                            					( type == null || timers[ index ].queue === type ) ) {
                            
                            					timers[ index ].anim.stop( gotoEnd );
                            					dequeue = false;
                            					timers.splice( index, 1 );
                            				}
                            			}
                            
                            			// Start the next in the queue if the last step wasn&#x27;t forced.
                            			// Timers currently will call their complete callbacks, which
                            			// will dequeue but only if they were gotoEnd.
                            			if ( dequeue || !gotoEnd ) {
                            				jQuery.dequeue( this, type );
                            			}
                            		} );
                            	},
                            	finish: function( type ) {
                            		if ( type !== false ) {
                            			type = type || &quot;fx&quot;;
                            		}
                            		return this.each( function() {
                            			var index,
                            				data = dataPriv.get( this ),
                            				queue = data[ type + &quot;queue&quot; ],
                            				hooks = data[ type + &quot;queueHooks&quot; ],
                            				timers = jQuery.timers,
                            				length = queue ? queue.length : 0;
                            
                            			// Enable finishing flag on private data
                            			data.finish = true;
                            
                            			// Empty the queue first
                            			jQuery.queue( this, type, [] );
                            
                            			if ( hooks &amp;&amp; hooks.stop ) {
                            				hooks.stop.call( this, true );
                            			}
                            
                            			// Look for any active animations, and finish them
                            			for ( index = timers.length; index--; ) {
                            				if ( timers[ index ].elem === this &amp;&amp; timers[ index ].queue === type ) {
                            					timers[ index ].anim.stop( true );
                            					timers.splice( index, 1 );
                            				}
                            			}
                            
                            			// Look for any animations in the old queue and finish them
                            			for ( index = 0; index &lt; length; index++ ) {
                            				if ( queue[ index ] &amp;&amp; queue[ index ].finish ) {
                            					queue[ index ].finish.call( this );
                            				}
                            			}
                            
                            			// Turn off finishing flag
                            			delete data.finish;
                            		} );
                            	}
                            } );
                            
                            jQuery.each( [ &quot;toggle&quot;, &quot;show&quot;, &quot;hide&quot; ], function( i, name ) {
                            	var cssFn = jQuery.fn[ name ];
                            	jQuery.fn[ name ] = function( speed, easing, callback ) {
                            		return speed == null || typeof speed === &quot;boolean&quot; ?
                            			cssFn.apply( this, arguments ) :
                            			this.animate( genFx( name, true ), speed, easing, callback );
                            	};
                            } );
                            
                            // Generate shortcuts for custom animations
                            jQuery.each( {
                            	slideDown: genFx( &quot;show&quot; ),
                            	slideUp: genFx( &quot;hide&quot; ),
                            	slideToggle: genFx( &quot;toggle&quot; ),
                            	fadeIn: { opacity: &quot;show&quot; },
                            	fadeOut: { opacity: &quot;hide&quot; },
                            	fadeToggle: { opacity: &quot;toggle&quot; }
                            }, function( name, props ) {
                            	jQuery.fn[ name ] = function( speed, easing, callback ) {
                            		return this.animate( props, speed, easing, callback );
                            	};
                            } );
                            
                            jQuery.timers = [];
                            jQuery.fx.tick = function() {
                            	var timer,
                            		i = 0,
                            		timers = jQuery.timers;
                            
                            	fxNow = jQuery.now();
                            
                            	for ( ; i &lt; timers.length; i++ ) {
                            		timer = timers[ i ];
                            
                            		// Run the timer and safely remove it when done (allowing for external removal)
                            		if ( !timer() &amp;&amp; timers[ i ] === timer ) {
                            			timers.splice( i--, 1 );
                            		}
                            	}
                            
                            	if ( !timers.length ) {
                            		jQuery.fx.stop();
                            	}
                            	fxNow = undefined;
                            };
                            
                            jQuery.fx.timer = function( timer ) {
                            	jQuery.timers.push( timer );
                            	jQuery.fx.start();
                            };
                            
                            jQuery.fx.interval = 13;
                            jQuery.fx.start = function() {
                            	if ( inProgress ) {
                            		return;
                            	}
                            
                            	inProgress = true;
                            	schedule();
                            };
                            
                            jQuery.fx.stop = function() {
                            	inProgress = null;
                            };
                            
                            jQuery.fx.speeds = {
                            	slow: 600,
                            	fast: 200,
                            
                            	// Default speed
                            	_default: 400
                            };
                            
                            
                            // Based off of the plugin by Clint Helfers, with permission.
                            // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
                            jQuery.fn.delay = function( time, type ) {
                            	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
                            	type = type || &quot;fx&quot;;
                            
                            	return this.queue( type, function( next, hooks ) {
                            		var timeout = window.setTimeout( next, time );
                            		hooks.stop = function() {
                            			window.clearTimeout( timeout );
                            		};
                            	} );
                            };
                            
                            
                            ( function() {
                            	var input = document.createElement( &quot;input&quot; ),
                            		select = document.createElement( &quot;select&quot; ),
                            		opt = select.appendChild( document.createElement( &quot;option&quot; ) );
                            
                            	input.type = &quot;checkbox&quot;;
                            
                            	// Support: Android &lt;=4.3 only
                            	// Default value for a checkbox should be &quot;on&quot;
                            	support.checkOn = input.value !== &quot;&quot;;
                            
                            	// Support: IE &lt;=11 only
                            	// Must access selectedIndex to make default options select
                            	support.optSelected = opt.selected;
                            
                            	// Support: IE &lt;=11 only
                            	// An input loses its value after becoming a radio
                            	input = document.createElement( &quot;input&quot; );
                            	input.value = &quot;t&quot;;
                            	input.type = &quot;radio&quot;;
                            	support.radioValue = input.value === &quot;t&quot;;
                            } )();
                            
                            
                            var boolHook,
                            	attrHandle = jQuery.expr.attrHandle;
                            
                            jQuery.fn.extend( {
                            	attr: function( name, value ) {
                            		return access( this, jQuery.attr, name, value, arguments.length &gt; 1 );
                            	},
                            
                            	removeAttr: function( name ) {
                            		return this.each( function() {
                            			jQuery.removeAttr( this, name );
                            		} );
                            	}
                            } );
                            
                            jQuery.extend( {
                            	attr: function( elem, name, value ) {
                            		var ret, hooks,
                            			nType = elem.nodeType;
                            
                            		// Don&#x27;t get/set attributes on text, comment and attribute nodes
                            		if ( nType === 3 || nType === 8 || nType === 2 ) {
                            			return;
                            		}
                            
                            		// Fallback to prop when attributes are not supported
                            		if ( typeof elem.getAttribute === &quot;undefined&quot; ) {
                            			return jQuery.prop( elem, name, value );
                            		}
                            
                            		// Attribute hooks are determined by the lowercase version
                            		// Grab necessary hook if one is defined
                            		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                            			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
                            				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
                            		}
                            
                            		if ( value !== undefined ) {
                            			if ( value === null ) {
                            				jQuery.removeAttr( elem, name );
                            				return;
                            			}
                            
                            			if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp;
                            				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                            				return ret;
                            			}
                            
                            			elem.setAttribute( name, value + &quot;&quot; );
                            			return value;
                            		}
                            
                            		if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== null ) {
                            			return ret;
                            		}
                            
                            		ret = jQuery.find.attr( elem, name );
                            
                            		// Non-existent attributes return null, we normalize to undefined
                            		return ret == null ? undefined : ret;
                            	},
                            
                            	attrHooks: {
                            		type: {
                            			set: function( elem, value ) {
                            				if ( !support.radioValue &amp;&amp; value === &quot;radio&quot; &amp;&amp;
                            					nodeName( elem, &quot;input&quot; ) ) {
                            					var val = elem.value;
                            					elem.setAttribute( &quot;type&quot;, value );
                            					if ( val ) {
                            						elem.value = val;
                            					}
                            					return value;
                            				}
                            			}
                            		}
                            	},
                            
                            	removeAttr: function( elem, value ) {
                            		var name,
                            			i = 0,
                            
                            			// Attribute names can contain non-HTML whitespace characters
                            			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
                            			attrNames = value &amp;&amp; value.match( rnothtmlwhite );
                            
                            		if ( attrNames &amp;&amp; elem.nodeType === 1 ) {
                            			while ( ( name = attrNames[ i++ ] ) ) {
                            				elem.removeAttribute( name );
                            			}
                            		}
                            	}
                            } );
                            
                            // Hooks for boolean attributes
                            boolHook = {
                            	set: function( elem, value, name ) {
                            		if ( value === false ) {
                            
                            			// Remove boolean attributes when set to false
                            			jQuery.removeAttr( elem, name );
                            		} else {
                            			elem.setAttribute( name, name );
                            		}
                            		return name;
                            	}
                            };
                            
                            jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
                            	var getter = attrHandle[ name ] || jQuery.find.attr;
                            
                            	attrHandle[ name ] = function( elem, name, isXML ) {
                            		var ret, handle,
                            			lowercaseName = name.toLowerCase();
                            
                            		if ( !isXML ) {
                            
                            			// Avoid an infinite loop by temporarily removing this function from the getter
                            			handle = attrHandle[ lowercaseName ];
                            			attrHandle[ lowercaseName ] = ret;
                            			ret = getter( elem, name, isXML ) != null ?
                            				lowercaseName :
                            				null;
                            			attrHandle[ lowercaseName ] = handle;
                            		}
                            		return ret;
                            	};
                            } );
                            
                            
                            
                            
                            var rfocusable = /^(?:input|select|textarea|button)$/i,
                            	rclickable = /^(?:a|area)$/i;
                            
                            jQuery.fn.extend( {
                            	prop: function( name, value ) {
                            		return access( this, jQuery.prop, name, value, arguments.length &gt; 1 );
                            	},
                            
                            	removeProp: function( name ) {
                            		return this.each( function() {
                            			delete this[ jQuery.propFix[ name ] || name ];
                            		} );
                            	}
                            } );
                            
                            jQuery.extend( {
                            	prop: function( elem, name, value ) {
                            		var ret, hooks,
                            			nType = elem.nodeType;
                            
                            		// Don&#x27;t get/set properties on text, comment and attribute nodes
                            		if ( nType === 3 || nType === 8 || nType === 2 ) {
                            			return;
                            		}
                            
                            		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                            
                            			// Fix name and attach hooks
                            			name = jQuery.propFix[ name ] || name;
                            			hooks = jQuery.propHooks[ name ];
                            		}
                            
                            		if ( value !== undefined ) {
                            			if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp;
                            				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                            				return ret;
                            			}
                            
                            			return ( elem[ name ] = value );
                            		}
                            
                            		if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== null ) {
                            			return ret;
                            		}
                            
                            		return elem[ name ];
                            	},
                            
                            	propHooks: {
                            		tabIndex: {
                            			get: function( elem ) {
                            
                            				// Support: IE &lt;=9 - 11 only
                            				// elem.tabIndex doesn&#x27;t always return the
                            				// correct value when it hasn&#x27;t been explicitly set
                            				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                            				// Use proper attribute retrieval(#12072)
                            				var tabindex = jQuery.find.attr( elem, &quot;tabindex&quot; );
                            
                            				if ( tabindex ) {
                            					return parseInt( tabindex, 10 );
                            				}
                            
                            				if (
                            					rfocusable.test( elem.nodeName ) ||
                            					rclickable.test( elem.nodeName ) &amp;&amp;
                            					elem.href
                            				) {
                            					return 0;
                            				}
                            
                            				return -1;
                            			}
                            		}
                            	},
                            
                            	propFix: {
                            		&quot;for&quot;: &quot;htmlFor&quot;,
                            		&quot;class&quot;: &quot;className&quot;
                            	}
                            } );
                            
                            // Support: IE &lt;=11 only
                            // Accessing the selectedIndex property
                            // forces the browser to respect setting selected
                            // on the option
                            // The getter ensures a default option is selected
                            // when in an optgroup
                            // eslint rule &quot;no-unused-expressions&quot; is disabled for this code
                            // since it considers such accessions noop
                            if ( !support.optSelected ) {
                            	jQuery.propHooks.selected = {
                            		get: function( elem ) {
                            
                            			/* eslint no-unused-expressions: &quot;off&quot; */
                            
                            			var parent = elem.parentNode;
                            			if ( parent &amp;&amp; parent.parentNode ) {
                            				parent.parentNode.selectedIndex;
                            			}
                            			return null;
                            		},
                            		set: function( elem ) {
                            
                            			/* eslint no-unused-expressions: &quot;off&quot; */
                            
                            			var parent = elem.parentNode;
                            			if ( parent ) {
                            				parent.selectedIndex;
                            
                            				if ( parent.parentNode ) {
                            					parent.parentNode.selectedIndex;
                            				}
                            			}
                            		}
                            	};
                            }
                            
                            jQuery.each( [
                            	&quot;tabIndex&quot;,
                            	&quot;readOnly&quot;,
                            	&quot;maxLength&quot;,
                            	&quot;cellSpacing&quot;,
                            	&quot;cellPadding&quot;,
                            	&quot;rowSpan&quot;,
                            	&quot;colSpan&quot;,
                            	&quot;useMap&quot;,
                            	&quot;frameBorder&quot;,
                            	&quot;contentEditable&quot;
                            ], function() {
                            	jQuery.propFix[ this.toLowerCase() ] = this;
                            } );
                            
                            
                            
                            
                            	// Strip and collapse whitespace according to HTML spec
                            	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
                            	function stripAndCollapse( value ) {
                            		var tokens = value.match( rnothtmlwhite ) || [];
                            		return tokens.join( &quot; &quot; );
                            	}
                            
                            
                            function getClass( elem ) {
                            	return elem.getAttribute &amp;&amp; elem.getAttribute( &quot;class&quot; ) || &quot;&quot;;
                            }
                            
                            jQuery.fn.extend( {
                            	addClass: function( value ) {
                            		var classes, elem, cur, curValue, clazz, j, finalValue,
                            			i = 0;
                            
                            		if ( jQuery.isFunction( value ) ) {
                            			return this.each( function( j ) {
                            				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
                            			} );
                            		}
                            
                            		if ( typeof value === &quot;string&quot; &amp;&amp; value ) {
                            			classes = value.match( rnothtmlwhite ) || [];
                            
                            			while ( ( elem = this[ i++ ] ) ) {
                            				curValue = getClass( elem );
                            				cur = elem.nodeType === 1 &amp;&amp; ( &quot; &quot; + stripAndCollapse( curValue ) + &quot; &quot; );
                            
                            				if ( cur ) {
                            					j = 0;
                            					while ( ( clazz = classes[ j++ ] ) ) {
                            						if ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &lt; 0 ) {
                            							cur += clazz + &quot; &quot;;
                            						}
                            					}
                            
                            					// Only assign if different to avoid unneeded rendering.
                            					finalValue = stripAndCollapse( cur );
                            					if ( curValue !== finalValue ) {
                            						elem.setAttribute( &quot;class&quot;, finalValue );
                            					}
                            				}
                            			}
                            		}
                            
                            		return this;
                            	},
                            
                            	removeClass: function( value ) {
                            		var classes, elem, cur, curValue, clazz, j, finalValue,
                            			i = 0;
                            
                            		if ( jQuery.isFunction( value ) ) {
                            			return this.each( function( j ) {
                            				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
                            			} );
                            		}
                            
                            		if ( !arguments.length ) {
                            			return this.attr( &quot;class&quot;, &quot;&quot; );
                            		}
                            
                            		if ( typeof value === &quot;string&quot; &amp;&amp; value ) {
                            			classes = value.match( rnothtmlwhite ) || [];
                            
                            			while ( ( elem = this[ i++ ] ) ) {
                            				curValue = getClass( elem );
                            
                            				// This expression is here for better compressibility (see addClass)
                            				cur = elem.nodeType === 1 &amp;&amp; ( &quot; &quot; + stripAndCollapse( curValue ) + &quot; &quot; );
                            
                            				if ( cur ) {
                            					j = 0;
                            					while ( ( clazz = classes[ j++ ] ) ) {
                            
                            						// Remove *all* instances
                            						while ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &gt; -1 ) {
                            							cur = cur.replace( &quot; &quot; + clazz + &quot; &quot;, &quot; &quot; );
                            						}
                            					}
                            
                            					// Only assign if different to avoid unneeded rendering.
                            					finalValue = stripAndCollapse( cur );
                            					if ( curValue !== finalValue ) {
                            						elem.setAttribute( &quot;class&quot;, finalValue );
                            					}
                            				}
                            			}
                            		}
                            
                            		return this;
                            	},
                            
                            	toggleClass: function( value, stateVal ) {
                            		var type = typeof value;
                            
                            		if ( typeof stateVal === &quot;boolean&quot; &amp;&amp; type === &quot;string&quot; ) {
                            			return stateVal ? this.addClass( value ) : this.removeClass( value );
                            		}
                            
                            		if ( jQuery.isFunction( value ) ) {
                            			return this.each( function( i ) {
                            				jQuery( this ).toggleClass(
                            					value.call( this, i, getClass( this ), stateVal ),
                            					stateVal
                            				);
                            			} );
                            		}
                            
                            		return this.each( function() {
                            			var className, i, self, classNames;
                            
                            			if ( type === &quot;string&quot; ) {
                            
                            				// Toggle individual class names
                            				i = 0;
                            				self = jQuery( this );
                            				classNames = value.match( rnothtmlwhite ) || [];
                            
                            				while ( ( className = classNames[ i++ ] ) ) {
                            
                            					// Check each className given, space separated list
                            					if ( self.hasClass( className ) ) {
                            						self.removeClass( className );
                            					} else {
                            						self.addClass( className );
                            					}
                            				}
                            
                            			// Toggle whole class name
                            			} else if ( value === undefined || type === &quot;boolean&quot; ) {
                            				className = getClass( this );
                            				if ( className ) {
                            
                            					// Store className if set
                            					dataPriv.set( this, &quot;__className__&quot;, className );
                            				}
                            
                            				// If the element has a class name or if we&#x27;re passed &#x60;false&#x60;,
                            				// then remove the whole classname (if there was one, the above saved it).
                            				// Otherwise bring back whatever was previously saved (if anything),
                            				// falling back to the empty string if nothing was stored.
                            				if ( this.setAttribute ) {
                            					this.setAttribute( &quot;class&quot;,
                            						className || value === false ?
                            						&quot;&quot; :
                            						dataPriv.get( this, &quot;__className__&quot; ) || &quot;&quot;
                            					);
                            				}
                            			}
                            		} );
                            	},
                            
                            	hasClass: function( selector ) {
                            		var className, elem,
                            			i = 0;
                            
                            		className = &quot; &quot; + selector + &quot; &quot;;
                            		while ( ( elem = this[ i++ ] ) ) {
                            			if ( elem.nodeType === 1 &amp;&amp;
                            				( &quot; &quot; + stripAndCollapse( getClass( elem ) ) + &quot; &quot; ).indexOf( className ) &gt; -1 ) {
                            					return true;
                            			}
                            		}
                            
                            		return false;
                            	}
                            } );
                            
                            
                            
                            
                            var rreturn = /\r/g;
                            
                            jQuery.fn.extend( {
                            	val: function( value ) {
                            		var hooks, ret, isFunction,
                            			elem = this[ 0 ];
                            
                            		if ( !arguments.length ) {
                            			if ( elem ) {
                            				hooks = jQuery.valHooks[ elem.type ] ||
                            					jQuery.valHooks[ elem.nodeName.toLowerCase() ];
                            
                            				if ( hooks &amp;&amp;
                            					&quot;get&quot; in hooks &amp;&amp;
                            					( ret = hooks.get( elem, &quot;value&quot; ) ) !== undefined
                            				) {
                            					return ret;
                            				}
                            
                            				ret = elem.value;
                            
                            				// Handle most common string cases
                            				if ( typeof ret === &quot;string&quot; ) {
                            					return ret.replace( rreturn, &quot;&quot; );
                            				}
                            
                            				// Handle cases where value is null/undef or number
                            				return ret == null ? &quot;&quot; : ret;
                            			}
                            
                            			return;
                            		}
                            
                            		isFunction = jQuery.isFunction( value );
                            
                            		return this.each( function( i ) {
                            			var val;
                            
                            			if ( this.nodeType !== 1 ) {
                            				return;
                            			}
                            
                            			if ( isFunction ) {
                            				val = value.call( this, i, jQuery( this ).val() );
                            			} else {
                            				val = value;
                            			}
                            
                            			// Treat null/undefined as &quot;&quot;; convert numbers to string
                            			if ( val == null ) {
                            				val = &quot;&quot;;
                            
                            			} else if ( typeof val === &quot;number&quot; ) {
                            				val += &quot;&quot;;
                            
                            			} else if ( Array.isArray( val ) ) {
                            				val = jQuery.map( val, function( value ) {
                            					return value == null ? &quot;&quot; : value + &quot;&quot;;
                            				} );
                            			}
                            
                            			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
                            
                            			// If set returns undefined, fall back to normal setting
                            			if ( !hooks || !( &quot;set&quot; in hooks ) || hooks.set( this, val, &quot;value&quot; ) === undefined ) {
                            				this.value = val;
                            			}
                            		} );
                            	}
                            } );
                            
                            jQuery.extend( {
                            	valHooks: {
                            		option: {
                            			get: function( elem ) {
                            
                            				var val = jQuery.find.attr( elem, &quot;value&quot; );
                            				return val != null ?
                            					val :
                            
                            					// Support: IE &lt;=10 - 11 only
                            					// option.text throws exceptions (#14686, #14858)
                            					// Strip and collapse whitespace
                            					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                            					stripAndCollapse( jQuery.text( elem ) );
                            			}
                            		},
                            		select: {
                            			get: function( elem ) {
                            				var value, option, i,
                            					options = elem.options,
                            					index = elem.selectedIndex,
                            					one = elem.type === &quot;select-one&quot;,
                            					values = one ? null : [],
                            					max = one ? index + 1 : options.length;
                            
                            				if ( index &lt; 0 ) {
                            					i = max;
                            
                            				} else {
                            					i = one ? index : 0;
                            				}
                            
                            				// Loop through all the selected options
                            				for ( ; i &lt; max; i++ ) {
                            					option = options[ i ];
                            
                            					// Support: IE &lt;=9 only
                            					// IE8-9 doesn&#x27;t update selected after form reset (#2551)
                            					if ( ( option.selected || i === index ) &amp;&amp;
                            
                            							// Don&#x27;t return options that are disabled or in a disabled optgroup
                            							!option.disabled &amp;&amp;
                            							( !option.parentNode.disabled ||
                            								!nodeName( option.parentNode, &quot;optgroup&quot; ) ) ) {
                            
                            						// Get the specific value for the option
                            						value = jQuery( option ).val();
                            
                            						// We don&#x27;t need an array for one selects
                            						if ( one ) {
                            							return value;
                            						}
                            
                            						// Multi-Selects return an array
                            						values.push( value );
                            					}
                            				}
                            
                            				return values;
                            			},
                            
                            			set: function( elem, value ) {
                            				var optionSet, option,
                            					options = elem.options,
                            					values = jQuery.makeArray( value ),
                            					i = options.length;
                            
                            				while ( i-- ) {
                            					option = options[ i ];
                            
                            					/* eslint-disable no-cond-assign */
                            
                            					if ( option.selected =
                            						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) &gt; -1
                            					) {
                            						optionSet = true;
                            					}
                            
                            					/* eslint-enable no-cond-assign */
                            				}
                            
                            				// Force browsers to behave consistently when non-matching value is set
                            				if ( !optionSet ) {
                            					elem.selectedIndex = -1;
                            				}
                            				return values;
                            			}
                            		}
                            	}
                            } );
                            
                            // Radios and checkboxes getter/setter
                            jQuery.each( [ &quot;radio&quot;, &quot;checkbox&quot; ], function() {
                            	jQuery.valHooks[ this ] = {
                            		set: function( elem, value ) {
                            			if ( Array.isArray( value ) ) {
                            				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) &gt; -1 );
                            			}
                            		}
                            	};
                            	if ( !support.checkOn ) {
                            		jQuery.valHooks[ this ].get = function( elem ) {
                            			return elem.getAttribute( &quot;value&quot; ) === null ? &quot;on&quot; : elem.value;
                            		};
                            	}
                            } );
                            
                            
                            
                            
                            // Return jQuery for attributes-only inclusion
                            
                            
                            var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
                            
                            jQuery.extend( jQuery.event, {
                            
                            	trigger: function( event, data, elem, onlyHandlers ) {
                            
                            		var i, cur, tmp, bubbleType, ontype, handle, special,
                            			eventPath = [ elem || document ],
                            			type = hasOwn.call( event, &quot;type&quot; ) ? event.type : event,
                            			namespaces = hasOwn.call( event, &quot;namespace&quot; ) ? event.namespace.split( &quot;.&quot; ) : [];
                            
                            		cur = tmp = elem = elem || document;
                            
                            		// Don&#x27;t do events on text and comment nodes
                            		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                            			return;
                            		}
                            
                            		// focus/blur morphs to focusin/out; ensure we&#x27;re not firing them right now
                            		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                            			return;
                            		}
                            
                            		if ( type.indexOf( &quot;.&quot; ) &gt; -1 ) {
                            
                            			// Namespaced trigger; create a regexp to match event type in handle()
                            			namespaces = type.split( &quot;.&quot; );
                            			type = namespaces.shift();
                            			namespaces.sort();
                            		}
                            		ontype = type.indexOf( &quot;:&quot; ) &lt; 0 &amp;&amp; &quot;on&quot; + type;
                            
                            		// Caller can pass in a jQuery.Event object, Object, or just an event type string
                            		event = event[ jQuery.expando ] ?
                            			event :
                            			new jQuery.Event( type, typeof event === &quot;object&quot; &amp;&amp; event );
                            
                            		// Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)
                            		event.isTrigger = onlyHandlers ? 2 : 3;
                            		event.namespace = namespaces.join( &quot;.&quot; );
                            		event.rnamespace = event.namespace ?
                            			new RegExp( &quot;(^|\\.)&quot; + namespaces.join( &quot;\\.(?:.*\\.|)&quot; ) + &quot;(\\.|$)&quot; ) :
                            			null;
                            
                            		// Clean up the event in case it is being reused
                            		event.result = undefined;
                            		if ( !event.target ) {
                            			event.target = elem;
                            		}
                            
                            		// Clone any incoming data and prepend the event, creating the handler arg list
                            		data = data == null ?
                            			[ event ] :
                            			jQuery.makeArray( data, [ event ] );
                            
                            		// Allow special events to draw outside the lines
                            		special = jQuery.event.special[ type ] || {};
                            		if ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {
                            			return;
                            		}
                            
                            		// Determine event propagation path in advance, per W3C events spec (#9951)
                            		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                            		if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) {
                            
                            			bubbleType = special.delegateType || type;
                            			if ( !rfocusMorph.test( bubbleType + type ) ) {
                            				cur = cur.parentNode;
                            			}
                            			for ( ; cur; cur = cur.parentNode ) {
                            				eventPath.push( cur );
                            				tmp = cur;
                            			}
                            
                            			// Only add window if we got to document (e.g., not plain obj or detached DOM)
                            			if ( tmp === ( elem.ownerDocument || document ) ) {
                            				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
                            			}
                            		}
                            
                            		// Fire handlers on the event path
                            		i = 0;
                            		while ( ( cur = eventPath[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) {
                            
                            			event.type = i &gt; 1 ?
                            				bubbleType :
                            				special.bindType || type;
                            
                            			// jQuery handler
                            			handle = ( dataPriv.get( cur, &quot;events&quot; ) || {} )[ event.type ] &amp;&amp;
                            				dataPriv.get( cur, &quot;handle&quot; );
                            			if ( handle ) {
                            				handle.apply( cur, data );
                            			}
                            
                            			// Native handler
                            			handle = ontype &amp;&amp; cur[ ontype ];
                            			if ( handle &amp;&amp; handle.apply &amp;&amp; acceptData( cur ) ) {
                            				event.result = handle.apply( cur, data );
                            				if ( event.result === false ) {
                            					event.preventDefault();
                            				}
                            			}
                            		}
                            		event.type = type;
                            
                            		// If nobody prevented the default action, do it now
                            		if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {
                            
                            			if ( ( !special._default ||
                            				special._default.apply( eventPath.pop(), data ) === false ) &amp;&amp;
                            				acceptData( elem ) ) {
                            
                            				// Call a native DOM method on the target with the same name as the event.
                            				// Don&#x27;t do default actions on window, that&#x27;s where global variables be (#6170)
                            				if ( ontype &amp;&amp; jQuery.isFunction( elem[ type ] ) &amp;&amp; !jQuery.isWindow( elem ) ) {
                            
                            					// Don&#x27;t re-trigger an onFOO event when we call its FOO() method
                            					tmp = elem[ ontype ];
                            
                            					if ( tmp ) {
                            						elem[ ontype ] = null;
                            					}
                            
                            					// Prevent re-triggering of the same event, since we already bubbled it above
                            					jQuery.event.triggered = type;
                            					elem[ type ]();
                            					jQuery.event.triggered = undefined;
                            
                            					if ( tmp ) {
                            						elem[ ontype ] = tmp;
                            					}
                            				}
                            			}
                            		}
                            
                            		return event.result;
                            	},
                            
                            	// Piggyback on a donor event to simulate a different one
                            	// Used only for &#x60;focus(in | out)&#x60; events
                            	simulate: function( type, elem, event ) {
                            		var e = jQuery.extend(
                            			new jQuery.Event(),
                            			event,
                            			{
                            				type: type,
                            				isSimulated: true
                            			}
                            		);
                            
                            		jQuery.event.trigger( e, null, elem );
                            	}
                            
                            } );
                            
                            jQuery.fn.extend( {
                            
                            	trigger: function( type, data ) {
                            		return this.each( function() {
                            			jQuery.event.trigger( type, data, this );
                            		} );
                            	},
                            	triggerHandler: function( type, data ) {
                            		var elem = this[ 0 ];
                            		if ( elem ) {
                            			return jQuery.event.trigger( type, data, elem, true );
                            		}
                            	}
                            } );
                            
                            
                            jQuery.each( ( &quot;blur focus focusin focusout resize scroll click dblclick &quot; +
                            	&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +
                            	&quot;change select submit keydown keypress keyup contextmenu&quot; ).split( &quot; &quot; ),
                            	function( i, name ) {
                            
                            	// Handle event binding
                            	jQuery.fn[ name ] = function( data, fn ) {
                            		return arguments.length &gt; 0 ?
                            			this.on( name, null, data, fn ) :
                            			this.trigger( name );
                            	};
                            } );
                            
                            jQuery.fn.extend( {
                            	hover: function( fnOver, fnOut ) {
                            		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
                            	}
                            } );
                            
                            
                            
                            
                            support.focusin = &quot;onfocusin&quot; in window;
                            
                            
                            // Support: Firefox &lt;=44
                            // Firefox doesn&#x27;t have focus(in | out) events
                            // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
                            //
                            // Support: Chrome &lt;=48 - 49, Safari &lt;=9.0 - 9.1
                            // focus(in | out) events fire after focus &amp; blur events,
                            // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
                            // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
                            if ( !support.focusin ) {
                            	jQuery.each( { focus: &quot;focusin&quot;, blur: &quot;focusout&quot; }, function( orig, fix ) {
                            
                            		// Attach a single capturing handler on the document while someone wants focusin/focusout
                            		var handler = function( event ) {
                            			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
                            		};
                            
                            		jQuery.event.special[ fix ] = {
                            			setup: function() {
                            				var doc = this.ownerDocument || this,
                            					attaches = dataPriv.access( doc, fix );
                            
                            				if ( !attaches ) {
                            					doc.addEventListener( orig, handler, true );
                            				}
                            				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
                            			},
                            			teardown: function() {
                            				var doc = this.ownerDocument || this,
                            					attaches = dataPriv.access( doc, fix ) - 1;
                            
                            				if ( !attaches ) {
                            					doc.removeEventListener( orig, handler, true );
                            					dataPriv.remove( doc, fix );
                            
                            				} else {
                            					dataPriv.access( doc, fix, attaches );
                            				}
                            			}
                            		};
                            	} );
                            }
                            var location = window.location;
                            
                            var nonce = jQuery.now();
                            
                            var rquery = ( /\?/ );
                            
                            
                            
                            // Cross-browser xml parsing
                            jQuery.parseXML = function( data ) {
                            	var xml;
                            	if ( !data || typeof data !== &quot;string&quot; ) {
                            		return null;
                            	}
                            
                            	// Support: IE 9 - 11 only
                            	// IE throws on parseFromString with invalid input.
                            	try {
                            		xml = ( new window.DOMParser() ).parseFromString( data, &quot;text/xml&quot; );
                            	} catch ( e ) {
                            		xml = undefined;
                            	}
                            
                            	if ( !xml || xml.getElementsByTagName( &quot;parsererror&quot; ).length ) {
                            		jQuery.error( &quot;Invalid XML: &quot; + data );
                            	}
                            	return xml;
                            };
                            
                            
                            var
                            	rbracket = /\[\]$/,
                            	rCRLF = /\r?\n/g,
                            	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                            	rsubmittable = /^(?:input|select|textarea|keygen)/i;
                            
                            function buildParams( prefix, obj, traditional, add ) {
                            	var name;
                            
                            	if ( Array.isArray( obj ) ) {
                            
                            		// Serialize array item.
                            		jQuery.each( obj, function( i, v ) {
                            			if ( traditional || rbracket.test( prefix ) ) {
                            
                            				// Treat each array item as a scalar.
                            				add( prefix, v );
                            
                            			} else {
                            
                            				// Item is non-scalar (array or object), encode its numeric index.
                            				buildParams(
                            					prefix + &quot;[&quot; + ( typeof v === &quot;object&quot; &amp;&amp; v != null ? i : &quot;&quot; ) + &quot;]&quot;,
                            					v,
                            					traditional,
                            					add
                            				);
                            			}
                            		} );
                            
                            	} else if ( !traditional &amp;&amp; jQuery.type( obj ) === &quot;object&quot; ) {
                            
                            		// Serialize object item.
                            		for ( name in obj ) {
                            			buildParams( prefix + &quot;[&quot; + name + &quot;]&quot;, obj[ name ], traditional, add );
                            		}
                            
                            	} else {
                            
                            		// Serialize scalar item.
                            		add( prefix, obj );
                            	}
                            }
                            
                            // Serialize an array of form elements or a set of
                            // key/values into a query string
                            jQuery.param = function( a, traditional ) {
                            	var prefix,
                            		s = [],
                            		add = function( key, valueOrFunction ) {
                            
                            			// If value is a function, invoke it and use its return value
                            			var value = jQuery.isFunction( valueOrFunction ) ?
                            				valueOrFunction() :
                            				valueOrFunction;
                            
                            			s[ s.length ] = encodeURIComponent( key ) + &quot;=&quot; +
                            				encodeURIComponent( value == null ? &quot;&quot; : value );
                            		};
                            
                            	// If an array was passed in, assume that it is an array of form elements.
                            	if ( Array.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {
                            
                            		// Serialize the form elements
                            		jQuery.each( a, function() {
                            			add( this.name, this.value );
                            		} );
                            
                            	} else {
                            
                            		// If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older
                            		// did it), otherwise encode params recursively.
                            		for ( prefix in a ) {
                            			buildParams( prefix, a[ prefix ], traditional, add );
                            		}
                            	}
                            
                            	// Return the resulting serialization
                            	return s.join( &quot;&amp;&quot; );
                            };
                            
                            jQuery.fn.extend( {
                            	serialize: function() {
                            		return jQuery.param( this.serializeArray() );
                            	},
                            	serializeArray: function() {
                            		return this.map( function() {
                            
                            			// Can add propHook for &quot;elements&quot; to filter or add form elements
                            			var elements = jQuery.prop( this, &quot;elements&quot; );
                            			return elements ? jQuery.makeArray( elements ) : this;
                            		} )
                            		.filter( function() {
                            			var type = this.type;
                            
                            			// Use .is( &quot;:disabled&quot; ) so that fieldset[disabled] works
                            			return this.name &amp;&amp; !jQuery( this ).is( &quot;:disabled&quot; ) &amp;&amp;
                            				rsubmittable.test( this.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp;
                            				( this.checked || !rcheckableType.test( type ) );
                            		} )
                            		.map( function( i, elem ) {
                            			var val = jQuery( this ).val();
                            
                            			if ( val == null ) {
                            				return null;
                            			}
                            
                            			if ( Array.isArray( val ) ) {
                            				return jQuery.map( val, function( val ) {
                            					return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
                            				} );
                            			}
                            
                            			return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
                            		} ).get();
                            	}
                            } );
                            
                            
                            var
                            	r20 = /%20/g,
                            	rhash = /#.*$/,
                            	rantiCache = /([?&amp;])_=[^&amp;]*/,
                            	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
                            
                            	// #7653, #8125, #8152: local protocol detection
                            	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                            	rnoContent = /^(?:GET|HEAD)$/,
                            	rprotocol = /^\/\//,
                            
                            	/* Prefilters
                            	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
                            	 * 2) These are called:
                            	 *    - BEFORE asking for a transport
                            	 *    - AFTER param serialization (s.data is a string if s.processData is true)
                            	 * 3) key is the dataType
                            	 * 4) the catchall symbol &quot;*&quot; can be used
                            	 * 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed
                            	 */
                            	prefilters = {},
                            
                            	/* Transports bindings
                            	 * 1) key is the dataType
                            	 * 2) the catchall symbol &quot;*&quot; can be used
                            	 * 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed
                            	 */
                            	transports = {},
                            
                            	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
                            	allTypes = &quot;*/&quot;.concat( &quot;*&quot; ),
                            
                            	// Anchor tag for parsing the document origin
                            	originAnchor = document.createElement( &quot;a&quot; );
                            	originAnchor.href = location.href;
                            
                            // Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport
                            function addToPrefiltersOrTransports( structure ) {
                            
                            	// dataTypeExpression is optional and defaults to &quot;*&quot;
                            	return function( dataTypeExpression, func ) {
                            
                            		if ( typeof dataTypeExpression !== &quot;string&quot; ) {
                            			func = dataTypeExpression;
                            			dataTypeExpression = &quot;*&quot;;
                            		}
                            
                            		var dataType,
                            			i = 0,
                            			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];
                            
                            		if ( jQuery.isFunction( func ) ) {
                            
                            			// For each dataType in the dataTypeExpression
                            			while ( ( dataType = dataTypes[ i++ ] ) ) {
                            
                            				// Prepend if requested
                            				if ( dataType[ 0 ] === &quot;+&quot; ) {
                            					dataType = dataType.slice( 1 ) || &quot;*&quot;;
                            					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
                            
                            				// Otherwise append
                            				} else {
                            					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
                            				}
                            			}
                            		}
                            	};
                            }
                            
                            // Base inspection function for prefilters and transports
                            function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
                            
                            	var inspected = {},
                            		seekingTransport = ( structure === transports );
                            
                            	function inspect( dataType ) {
                            		var selected;
                            		inspected[ dataType ] = true;
                            		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
                            			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
                            			if ( typeof dataTypeOrTransport === &quot;string&quot; &amp;&amp;
                            				!seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) {
                            
                            				options.dataTypes.unshift( dataTypeOrTransport );
                            				inspect( dataTypeOrTransport );
                            				return false;
                            			} else if ( seekingTransport ) {
                            				return !( selected = dataTypeOrTransport );
                            			}
                            		} );
                            		return selected;
                            	}
                            
                            	return inspect( options.dataTypes[ 0 ] ) || !inspected[ &quot;*&quot; ] &amp;&amp; inspect( &quot;*&quot; );
                            }
                            
                            // A special extend for ajax options
                            // that takes &quot;flat&quot; options (not to be deep extended)
                            // Fixes #9887
                            function ajaxExtend( target, src ) {
                            	var key, deep,
                            		flatOptions = jQuery.ajaxSettings.flatOptions || {};
                            
                            	for ( key in src ) {
                            		if ( src[ key ] !== undefined ) {
                            			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
                            		}
                            	}
                            	if ( deep ) {
                            		jQuery.extend( true, target, deep );
                            	}
                            
                            	return target;
                            }
                            
                            /* Handles responses to an ajax request:
                             * - finds the right dataType (mediates between content-type and expected dataType)
                             * - returns the corresponding response
                             */
                            function ajaxHandleResponses( s, jqXHR, responses ) {
                            
                            	var ct, type, finalDataType, firstDataType,
                            		contents = s.contents,
                            		dataTypes = s.dataTypes;
                            
                            	// Remove auto dataType and get content-type in the process
                            	while ( dataTypes[ 0 ] === &quot;*&quot; ) {
                            		dataTypes.shift();
                            		if ( ct === undefined ) {
                            			ct = s.mimeType || jqXHR.getResponseHeader( &quot;Content-Type&quot; );
                            		}
                            	}
                            
                            	// Check if we&#x27;re dealing with a known content-type
                            	if ( ct ) {
                            		for ( type in contents ) {
                            			if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {
                            				dataTypes.unshift( type );
                            				break;
                            			}
                            		}
                            	}
                            
                            	// Check to see if we have a response for the expected dataType
                            	if ( dataTypes[ 0 ] in responses ) {
                            		finalDataType = dataTypes[ 0 ];
                            	} else {
                            
                            		// Try convertible dataTypes
                            		for ( type in responses ) {
                            			if ( !dataTypes[ 0 ] || s.converters[ type + &quot; &quot; + dataTypes[ 0 ] ] ) {
                            				finalDataType = type;
                            				break;
                            			}
                            			if ( !firstDataType ) {
                            				firstDataType = type;
                            			}
                            		}
                            
                            		// Or just use first one
                            		finalDataType = finalDataType || firstDataType;
                            	}
                            
                            	// If we found a dataType
                            	// We add the dataType to the list if needed
                            	// and return the corresponding response
                            	if ( finalDataType ) {
                            		if ( finalDataType !== dataTypes[ 0 ] ) {
                            			dataTypes.unshift( finalDataType );
                            		}
                            		return responses[ finalDataType ];
                            	}
                            }
                            
                            /* Chain conversions given the request and the original response
                             * Also sets the responseXXX fields on the jqXHR instance
                             */
                            function ajaxConvert( s, response, jqXHR, isSuccess ) {
                            	var conv2, current, conv, tmp, prev,
                            		converters = {},
                            
                            		// Work with a copy of dataTypes in case we need to modify it for conversion
                            		dataTypes = s.dataTypes.slice();
                            
                            	// Create converters map with lowercased keys
                            	if ( dataTypes[ 1 ] ) {
                            		for ( conv in s.converters ) {
                            			converters[ conv.toLowerCase() ] = s.converters[ conv ];
                            		}
                            	}
                            
                            	current = dataTypes.shift();
                            
                            	// Convert to each sequential dataType
                            	while ( current ) {
                            
                            		if ( s.responseFields[ current ] ) {
                            			jqXHR[ s.responseFields[ current ] ] = response;
                            		}
                            
                            		// Apply the dataFilter if provided
                            		if ( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) {
                            			response = s.dataFilter( response, s.dataType );
                            		}
                            
                            		prev = current;
                            		current = dataTypes.shift();
                            
                            		if ( current ) {
                            
                            			// There&#x27;s only work to do if current dataType is non-auto
                            			if ( current === &quot;*&quot; ) {
                            
                            				current = prev;
                            
                            			// Convert response if prev dataType is non-auto and differs from current
                            			} else if ( prev !== &quot;*&quot; &amp;&amp; prev !== current ) {
                            
                            				// Seek a direct converter
                            				conv = converters[ prev + &quot; &quot; + current ] || converters[ &quot;* &quot; + current ];
                            
                            				// If none found, seek a pair
                            				if ( !conv ) {
                            					for ( conv2 in converters ) {
                            
                            						// If conv2 outputs current
                            						tmp = conv2.split( &quot; &quot; );
                            						if ( tmp[ 1 ] === current ) {
                            
                            							// If prev can be converted to accepted input
                            							conv = converters[ prev + &quot; &quot; + tmp[ 0 ] ] ||
                            								converters[ &quot;* &quot; + tmp[ 0 ] ];
                            							if ( conv ) {
                            
                            								// Condense equivalence converters
                            								if ( conv === true ) {
                            									conv = converters[ conv2 ];
                            
                            								// Otherwise, insert the intermediate dataType
                            								} else if ( converters[ conv2 ] !== true ) {
                            									current = tmp[ 0 ];
                            									dataTypes.unshift( tmp[ 1 ] );
                            								}
                            								break;
                            							}
                            						}
                            					}
                            				}
                            
                            				// Apply converter (if not an equivalence)
                            				if ( conv !== true ) {
                            
                            					// Unless errors are allowed to bubble, catch and return them
                            					if ( conv &amp;&amp; s.throws ) {
                            						response = conv( response );
                            					} else {
                            						try {
                            							response = conv( response );
                            						} catch ( e ) {
                            							return {
                            								state: &quot;parsererror&quot;,
                            								error: conv ? e : &quot;No conversion from &quot; + prev + &quot; to &quot; + current
                            							};
                            						}
                            					}
                            				}
                            			}
                            		}
                            	}
                            
                            	return { state: &quot;success&quot;, data: response };
                            }
                            
                            jQuery.extend( {
                            
                            	// Counter for holding the number of active queries
                            	active: 0,
                            
                            	// Last-Modified header cache for next request
                            	lastModified: {},
                            	etag: {},
                            
                            	ajaxSettings: {
                            		url: location.href,
                            		type: &quot;GET&quot;,
                            		isLocal: rlocalProtocol.test( location.protocol ),
                            		global: true,
                            		processData: true,
                            		async: true,
                            		contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,
                            
                            		/*
                            		timeout: 0,
                            		data: null,
                            		dataType: null,
                            		username: null,
                            		password: null,
                            		cache: null,
                            		throws: false,
                            		traditional: false,
                            		headers: {},
                            		*/
                            
                            		accepts: {
                            			&quot;*&quot;: allTypes,
                            			text: &quot;text/plain&quot;,
                            			html: &quot;text/html&quot;,
                            			xml: &quot;application/xml, text/xml&quot;,
                            			json: &quot;application/json, text/javascript&quot;
                            		},
                            
                            		contents: {
                            			xml: /\bxml\b/,
                            			html: /\bhtml/,
                            			json: /\bjson\b/
                            		},
                            
                            		responseFields: {
                            			xml: &quot;responseXML&quot;,
                            			text: &quot;responseText&quot;,
                            			json: &quot;responseJSON&quot;
                            		},
                            
                            		// Data converters
                            		// Keys separate source (or catchall &quot;*&quot;) and destination types with a single space
                            		converters: {
                            
                            			// Convert anything to text
                            			&quot;* text&quot;: String,
                            
                            			// Text to html (true = no transformation)
                            			&quot;text html&quot;: true,
                            
                            			// Evaluate text as a json expression
                            			&quot;text json&quot;: JSON.parse,
                            
                            			// Parse text as xml
                            			&quot;text xml&quot;: jQuery.parseXML
                            		},
                            
                            		// For options that shouldn&#x27;t be deep extended:
                            		// you can add your own custom options here if
                            		// and when you create one that shouldn&#x27;t be
                            		// deep extended (see ajaxExtend)
                            		flatOptions: {
                            			url: true,
                            			context: true
                            		}
                            	},
                            
                            	// Creates a full fledged settings object into target
                            	// with both ajaxSettings and settings fields.
                            	// If target is omitted, writes into ajaxSettings.
                            	ajaxSetup: function( target, settings ) {
                            		return settings ?
                            
                            			// Building a settings object
                            			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
                            
                            			// Extending ajaxSettings
                            			ajaxExtend( jQuery.ajaxSettings, target );
                            	},
                            
                            	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
                            	ajaxTransport: addToPrefiltersOrTransports( transports ),
                            
                            	// Main method
                            	ajax: function( url, options ) {
                            
                            		// If url is an object, simulate pre-1.5 signature
                            		if ( typeof url === &quot;object&quot; ) {
                            			options = url;
                            			url = undefined;
                            		}
                            
                            		// Force options to be an object
                            		options = options || {};
                            
                            		var transport,
                            
                            			// URL without anti-cache param
                            			cacheURL,
                            
                            			// Response headers
                            			responseHeadersString,
                            			responseHeaders,
                            
                            			// timeout handle
                            			timeoutTimer,
                            
                            			// Url cleanup var
                            			urlAnchor,
                            
                            			// Request state (becomes false upon send and true upon completion)
                            			completed,
                            
                            			// To know if global events are to be dispatched
                            			fireGlobals,
                            
                            			// Loop variable
                            			i,
                            
                            			// uncached part of the url
                            			uncached,
                            
                            			// Create the final options object
                            			s = jQuery.ajaxSetup( {}, options ),
                            
                            			// Callbacks context
                            			callbackContext = s.context || s,
                            
                            			// Context for global events is callbackContext if it is a DOM node or jQuery collection
                            			globalEventContext = s.context &amp;&amp;
                            				( callbackContext.nodeType || callbackContext.jquery ) ?
                            					jQuery( callbackContext ) :
                            					jQuery.event,
                            
                            			// Deferreds
                            			deferred = jQuery.Deferred(),
                            			completeDeferred = jQuery.Callbacks( &quot;once memory&quot; ),
                            
                            			// Status-dependent callbacks
                            			statusCode = s.statusCode || {},
                            
                            			// Headers (they are sent all at once)
                            			requestHeaders = {},
                            			requestHeadersNames = {},
                            
                            			// Default abort message
                            			strAbort = &quot;canceled&quot;,
                            
                            			// Fake xhr
                            			jqXHR = {
                            				readyState: 0,
                            
                            				// Builds headers hashtable if needed
                            				getResponseHeader: function( key ) {
                            					var match;
                            					if ( completed ) {
                            						if ( !responseHeaders ) {
                            							responseHeaders = {};
                            							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                            								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
                            							}
                            						}
                            						match = responseHeaders[ key.toLowerCase() ];
                            					}
                            					return match == null ? null : match;
                            				},
                            
                            				// Raw string
                            				getAllResponseHeaders: function() {
                            					return completed ? responseHeadersString : null;
                            				},
                            
                            				// Caches the header
                            				setRequestHeader: function( name, value ) {
                            					if ( completed == null ) {
                            						name = requestHeadersNames[ name.toLowerCase() ] =
                            							requestHeadersNames[ name.toLowerCase() ] || name;
                            						requestHeaders[ name ] = value;
                            					}
                            					return this;
                            				},
                            
                            				// Overrides response content-type header
                            				overrideMimeType: function( type ) {
                            					if ( completed == null ) {
                            						s.mimeType = type;
                            					}
                            					return this;
                            				},
                            
                            				// Status-dependent callbacks
                            				statusCode: function( map ) {
                            					var code;
                            					if ( map ) {
                            						if ( completed ) {
                            
                            							// Execute the appropriate callbacks
                            							jqXHR.always( map[ jqXHR.status ] );
                            						} else {
                            
                            							// Lazy-add the new callbacks in a way that preserves old ones
                            							for ( code in map ) {
                            								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                            							}
                            						}
                            					}
                            					return this;
                            				},
                            
                            				// Cancel the request
                            				abort: function( statusText ) {
                            					var finalText = statusText || strAbort;
                            					if ( transport ) {
                            						transport.abort( finalText );
                            					}
                            					done( 0, finalText );
                            					return this;
                            				}
                            			};
                            
                            		// Attach deferreds
                            		deferred.promise( jqXHR );
                            
                            		// Add protocol if not provided (prefilters might expect it)
                            		// Handle falsy url in the settings object (#10093: consistency with old signature)
                            		// We also use the url parameter if available
                            		s.url = ( ( url || s.url || location.href ) + &quot;&quot; )
                            			.replace( rprotocol, location.protocol + &quot;//&quot; );
                            
                            		// Alias method option to type as per ticket #12004
                            		s.type = options.method || options.type || s.method || s.type;
                            
                            		// Extract dataTypes list
                            		s.dataTypes = ( s.dataType || &quot;*&quot; ).toLowerCase().match( rnothtmlwhite ) || [ &quot;&quot; ];
                            
                            		// A cross-domain request is in order when the origin doesn&#x27;t match the current origin.
                            		if ( s.crossDomain == null ) {
                            			urlAnchor = document.createElement( &quot;a&quot; );
                            
                            			// Support: IE &lt;=8 - 11, Edge 12 - 13
                            			// IE throws exception on accessing the href property if url is malformed,
                            			// e.g. http://example.com:80x/
                            			try {
                            				urlAnchor.href = s.url;
                            
                            				// Support: IE &lt;=8 - 11 only
                            				// Anchor&#x27;s host property isn&#x27;t correctly set when s.url is relative
                            				urlAnchor.href = urlAnchor.href;
                            				s.crossDomain = originAnchor.protocol + &quot;//&quot; + originAnchor.host !==
                            					urlAnchor.protocol + &quot;//&quot; + urlAnchor.host;
                            			} catch ( e ) {
                            
                            				// If there is an error parsing the URL, assume it is crossDomain,
                            				// it can be rejected by the transport if it is invalid
                            				s.crossDomain = true;
                            			}
                            		}
                            
                            		// Convert data if not already a string
                            		if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== &quot;string&quot; ) {
                            			s.data = jQuery.param( s.data, s.traditional );
                            		}
                            
                            		// Apply prefilters
                            		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
                            
                            		// If request was aborted inside a prefilter, stop there
                            		if ( completed ) {
                            			return jqXHR;
                            		}
                            
                            		// We can fire global events as of now if asked to
                            		// Don&#x27;t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
                            		fireGlobals = jQuery.event &amp;&amp; s.global;
                            
                            		// Watch for a new set of requests
                            		if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {
                            			jQuery.event.trigger( &quot;ajaxStart&quot; );
                            		}
                            
                            		// Uppercase the type
                            		s.type = s.type.toUpperCase();
                            
                            		// Determine if request has content
                            		s.hasContent = !rnoContent.test( s.type );
                            
                            		// Save the URL in case we&#x27;re toying with the If-Modified-Since
                            		// and/or If-None-Match header later on
                            		// Remove hash to simplify url manipulation
                            		cacheURL = s.url.replace( rhash, &quot;&quot; );
                            
                            		// More options handling for requests with no content
                            		if ( !s.hasContent ) {
                            
                            			// Remember the hash so we can put it back
                            			uncached = s.url.slice( cacheURL.length );
                            
                            			// If data is available, append data to url
                            			if ( s.data ) {
                            				cacheURL += ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.data;
                            
                            				// #9682: remove data so that it&#x27;s not used in an eventual retry
                            				delete s.data;
                            			}
                            
                            			// Add or update anti-cache param if needed
                            			if ( s.cache === false ) {
                            				cacheURL = cacheURL.replace( rantiCache, &quot;$1&quot; );
                            				uncached = ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + &quot;_=&quot; + ( nonce++ ) + uncached;
                            			}
                            
                            			// Put hash and anti-cache on the URL that will be requested (gh-1732)
                            			s.url = cacheURL + uncached;
                            
                            		// Change &#x27;%20&#x27; to &#x27;+&#x27; if this is encoded form body content (gh-2658)
                            		} else if ( s.data &amp;&amp; s.processData &amp;&amp;
                            			( s.contentType || &quot;&quot; ).indexOf( &quot;application/x-www-form-urlencoded&quot; ) === 0 ) {
                            			s.data = s.data.replace( r20, &quot;+&quot; );
                            		}
                            
                            		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                            		if ( s.ifModified ) {
                            			if ( jQuery.lastModified[ cacheURL ] ) {
                            				jqXHR.setRequestHeader( &quot;If-Modified-Since&quot;, jQuery.lastModified[ cacheURL ] );
                            			}
                            			if ( jQuery.etag[ cacheURL ] ) {
                            				jqXHR.setRequestHeader( &quot;If-None-Match&quot;, jQuery.etag[ cacheURL ] );
                            			}
                            		}
                            
                            		// Set the correct header, if data is being sent
                            		if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) {
                            			jqXHR.setRequestHeader( &quot;Content-Type&quot;, s.contentType );
                            		}
                            
                            		// Set the Accepts header for the server, depending on the dataType
                            		jqXHR.setRequestHeader(
                            			&quot;Accept&quot;,
                            			s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[ 0 ] ] ?
                            				s.accepts[ s.dataTypes[ 0 ] ] +
                            					( s.dataTypes[ 0 ] !== &quot;*&quot; ? &quot;, &quot; + allTypes + &quot;; q=0.01&quot; : &quot;&quot; ) :
                            				s.accepts[ &quot;*&quot; ]
                            		);
                            
                            		// Check for headers option
                            		for ( i in s.headers ) {
                            			jqXHR.setRequestHeader( i, s.headers[ i ] );
                            		}
                            
                            		// Allow custom headers/mimetypes and early abort
                            		if ( s.beforeSend &amp;&amp;
                            			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
                            
                            			// Abort if not done already and return
                            			return jqXHR.abort();
                            		}
                            
                            		// Aborting is no longer a cancellation
                            		strAbort = &quot;abort&quot;;
                            
                            		// Install callbacks on deferreds
                            		completeDeferred.add( s.complete );
                            		jqXHR.done( s.success );
                            		jqXHR.fail( s.error );
                            
                            		// Get transport
                            		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
                            
                            		// If no transport, we auto-abort
                            		if ( !transport ) {
                            			done( -1, &quot;No Transport&quot; );
                            		} else {
                            			jqXHR.readyState = 1;
                            
                            			// Send global event
                            			if ( fireGlobals ) {
                            				globalEventContext.trigger( &quot;ajaxSend&quot;, [ jqXHR, s ] );
                            			}
                            
                            			// If request was aborted inside ajaxSend, stop there
                            			if ( completed ) {
                            				return jqXHR;
                            			}
                            
                            			// Timeout
                            			if ( s.async &amp;&amp; s.timeout &gt; 0 ) {
                            				timeoutTimer = window.setTimeout( function() {
                            					jqXHR.abort( &quot;timeout&quot; );
                            				}, s.timeout );
                            			}
                            
                            			try {
                            				completed = false;
                            				transport.send( requestHeaders, done );
                            			} catch ( e ) {
                            
                            				// Rethrow post-completion exceptions
                            				if ( completed ) {
                            					throw e;
                            				}
                            
                            				// Propagate others as results
                            				done( -1, e );
                            			}
                            		}
                            
                            		// Callback for when everything is done
                            		function done( status, nativeStatusText, responses, headers ) {
                            			var isSuccess, success, error, response, modified,
                            				statusText = nativeStatusText;
                            
                            			// Ignore repeat invocations
                            			if ( completed ) {
                            				return;
                            			}
                            
                            			completed = true;
                            
                            			// Clear timeout if it exists
                            			if ( timeoutTimer ) {
                            				window.clearTimeout( timeoutTimer );
                            			}
                            
                            			// Dereference transport for early garbage collection
                            			// (no matter how long the jqXHR object will be used)
                            			transport = undefined;
                            
                            			// Cache response headers
                            			responseHeadersString = headers || &quot;&quot;;
                            
                            			// Set readyState
                            			jqXHR.readyState = status &gt; 0 ? 4 : 0;
                            
                            			// Determine if successful
                            			isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304;
                            
                            			// Get response data
                            			if ( responses ) {
                            				response = ajaxHandleResponses( s, jqXHR, responses );
                            			}
                            
                            			// Convert no matter what (that way responseXXX fields are always set)
                            			response = ajaxConvert( s, response, jqXHR, isSuccess );
                            
                            			// If successful, handle type chaining
                            			if ( isSuccess ) {
                            
                            				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                            				if ( s.ifModified ) {
                            					modified = jqXHR.getResponseHeader( &quot;Last-Modified&quot; );
                            					if ( modified ) {
                            						jQuery.lastModified[ cacheURL ] = modified;
                            					}
                            					modified = jqXHR.getResponseHeader( &quot;etag&quot; );
                            					if ( modified ) {
                            						jQuery.etag[ cacheURL ] = modified;
                            					}
                            				}
                            
                            				// if no content
                            				if ( status === 204 || s.type === &quot;HEAD&quot; ) {
                            					statusText = &quot;nocontent&quot;;
                            
                            				// if not modified
                            				} else if ( status === 304 ) {
                            					statusText = &quot;notmodified&quot;;
                            
                            				// If we have data, let&#x27;s convert it
                            				} else {
                            					statusText = response.state;
                            					success = response.data;
                            					error = response.error;
                            					isSuccess = !error;
                            				}
                            			} else {
                            
                            				// Extract error from statusText and normalize for non-aborts
                            				error = statusText;
                            				if ( status || !statusText ) {
                            					statusText = &quot;error&quot;;
                            					if ( status &lt; 0 ) {
                            						status = 0;
                            					}
                            				}
                            			}
                            
                            			// Set data for the fake xhr object
                            			jqXHR.status = status;
                            			jqXHR.statusText = ( nativeStatusText || statusText ) + &quot;&quot;;
                            
                            			// Success/Error
                            			if ( isSuccess ) {
                            				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                            			} else {
                            				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                            			}
                            
                            			// Status-dependent callbacks
                            			jqXHR.statusCode( statusCode );
                            			statusCode = undefined;
                            
                            			if ( fireGlobals ) {
                            				globalEventContext.trigger( isSuccess ? &quot;ajaxSuccess&quot; : &quot;ajaxError&quot;,
                            					[ jqXHR, s, isSuccess ? success : error ] );
                            			}
                            
                            			// Complete
                            			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
                            
                            			if ( fireGlobals ) {
                            				globalEventContext.trigger( &quot;ajaxComplete&quot;, [ jqXHR, s ] );
                            
                            				// Handle the global AJAX counter
                            				if ( !( --jQuery.active ) ) {
                            					jQuery.event.trigger( &quot;ajaxStop&quot; );
                            				}
                            			}
                            		}
                            
                            		return jqXHR;
                            	},
                            
                            	getJSON: function( url, data, callback ) {
                            		return jQuery.get( url, data, callback, &quot;json&quot; );
                            	},
                            
                            	getScript: function( url, callback ) {
                            		return jQuery.get( url, undefined, callback, &quot;script&quot; );
                            	}
                            } );
                            
                            jQuery.each( [ &quot;get&quot;, &quot;post&quot; ], function( i, method ) {
                            	jQuery[ method ] = function( url, data, callback, type ) {
                            
                            		// Shift arguments if data argument was omitted
                            		if ( jQuery.isFunction( data ) ) {
                            			type = type || callback;
                            			callback = data;
                            			data = undefined;
                            		}
                            
                            		// The url can be an options object (which then must have .url)
                            		return jQuery.ajax( jQuery.extend( {
                            			url: url,
                            			type: method,
                            			dataType: type,
                            			data: data,
                            			success: callback
                            		}, jQuery.isPlainObject( url ) &amp;&amp; url ) );
                            	};
                            } );
                            
                            
                            jQuery._evalUrl = function( url ) {
                            	return jQuery.ajax( {
                            		url: url,
                            
                            		// Make this explicit, since user can override this through ajaxSetup (#11264)
                            		type: &quot;GET&quot;,
                            		dataType: &quot;script&quot;,
                            		cache: true,
                            		async: false,
                            		global: false,
                            		&quot;throws&quot;: true
                            	} );
                            };
                            
                            
                            jQuery.fn.extend( {
                            	wrapAll: function( html ) {
                            		var wrap;
                            
                            		if ( this[ 0 ] ) {
                            			if ( jQuery.isFunction( html ) ) {
                            				html = html.call( this[ 0 ] );
                            			}
                            
                            			// The elements to wrap the target around
                            			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
                            
                            			if ( this[ 0 ].parentNode ) {
                            				wrap.insertBefore( this[ 0 ] );
                            			}
                            
                            			wrap.map( function() {
                            				var elem = this;
                            
                            				while ( elem.firstElementChild ) {
                            					elem = elem.firstElementChild;
                            				}
                            
                            				return elem;
                            			} ).append( this );
                            		}
                            
                            		return this;
                            	},
                            
                            	wrapInner: function( html ) {
                            		if ( jQuery.isFunction( html ) ) {
                            			return this.each( function( i ) {
                            				jQuery( this ).wrapInner( html.call( this, i ) );
                            			} );
                            		}
                            
                            		return this.each( function() {
                            			var self = jQuery( this ),
                            				contents = self.contents();
                            
                            			if ( contents.length ) {
                            				contents.wrapAll( html );
                            
                            			} else {
                            				self.append( html );
                            			}
                            		} );
                            	},
                            
                            	wrap: function( html ) {
                            		var isFunction = jQuery.isFunction( html );
                            
                            		return this.each( function( i ) {
                            			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
                            		} );
                            	},
                            
                            	unwrap: function( selector ) {
                            		this.parent( selector ).not( &quot;body&quot; ).each( function() {
                            			jQuery( this ).replaceWith( this.childNodes );
                            		} );
                            		return this;
                            	}
                            } );
                            
                            
                            jQuery.expr.pseudos.hidden = function( elem ) {
                            	return !jQuery.expr.pseudos.visible( elem );
                            };
                            jQuery.expr.pseudos.visible = function( elem ) {
                            	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
                            };
                            
                            
                            
                            
                            jQuery.ajaxSettings.xhr = function() {
                            	try {
                            		return new window.XMLHttpRequest();
                            	} catch ( e ) {}
                            };
                            
                            var xhrSuccessStatus = {
                            
                            		// File protocol always yields status code 0, assume 200
                            		0: 200,
                            
                            		// Support: IE &lt;=9 only
                            		// #1450: sometimes IE returns 1223 when it should be 204
                            		1223: 204
                            	},
                            	xhrSupported = jQuery.ajaxSettings.xhr();
                            
                            support.cors = !!xhrSupported &amp;&amp; ( &quot;withCredentials&quot; in xhrSupported );
                            support.ajax = xhrSupported = !!xhrSupported;
                            
                            jQuery.ajaxTransport( function( options ) {
                            	var callback, errorCallback;
                            
                            	// Cross domain only allowed if supported through XMLHttpRequest
                            	if ( support.cors || xhrSupported &amp;&amp; !options.crossDomain ) {
                            		return {
                            			send: function( headers, complete ) {
                            				var i,
                            					xhr = options.xhr();
                            
                            				xhr.open(
                            					options.type,
                            					options.url,
                            					options.async,
                            					options.username,
                            					options.password
                            				);
                            
                            				// Apply custom fields if provided
                            				if ( options.xhrFields ) {
                            					for ( i in options.xhrFields ) {
                            						xhr[ i ] = options.xhrFields[ i ];
                            					}
                            				}
                            
                            				// Override mime type if needed
                            				if ( options.mimeType &amp;&amp; xhr.overrideMimeType ) {
                            					xhr.overrideMimeType( options.mimeType );
                            				}
                            
                            				// X-Requested-With header
                            				// For cross-domain requests, seeing as conditions for a preflight are
                            				// akin to a jigsaw puzzle, we simply never set it to be sure.
                            				// (it can always be set on a per-request basis or even using ajaxSetup)
                            				// For same-domain requests, won&#x27;t change header if already provided.
                            				if ( !options.crossDomain &amp;&amp; !headers[ &quot;X-Requested-With&quot; ] ) {
                            					headers[ &quot;X-Requested-With&quot; ] = &quot;XMLHttpRequest&quot;;
                            				}
                            
                            				// Set headers
                            				for ( i in headers ) {
                            					xhr.setRequestHeader( i, headers[ i ] );
                            				}
                            
                            				// Callback
                            				callback = function( type ) {
                            					return function() {
                            						if ( callback ) {
                            							callback = errorCallback = xhr.onload =
                            								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                            
                            							if ( type === &quot;abort&quot; ) {
                            								xhr.abort();
                            							} else if ( type === &quot;error&quot; ) {
                            
                            								// Support: IE &lt;=9 only
                            								// On a manual native abort, IE9 throws
                            								// errors on any property access that is not readyState
                            								if ( typeof xhr.status !== &quot;number&quot; ) {
                            									complete( 0, &quot;error&quot; );
                            								} else {
                            									complete(
                            
                            										// File: protocol always yields status 0; see #8605, #14207
                            										xhr.status,
                            										xhr.statusText
                            									);
                            								}
                            							} else {
                            								complete(
                            									xhrSuccessStatus[ xhr.status ] || xhr.status,
                            									xhr.statusText,
                            
                            									// Support: IE &lt;=9 only
                            									// IE9 has no XHR2 but throws on binary (trac-11426)
                            									// For XHR2 non-text, let the caller handle it (gh-2498)
                            									( xhr.responseType || &quot;text&quot; ) !== &quot;text&quot;  ||
                            									typeof xhr.responseText !== &quot;string&quot; ?
                            										{ binary: xhr.response } :
                            										{ text: xhr.responseText },
                            									xhr.getAllResponseHeaders()
                            								);
                            							}
                            						}
                            					};
                            				};
                            
                            				// Listen to events
                            				xhr.onload = callback();
                            				errorCallback = xhr.onerror = callback( &quot;error&quot; );
                            
                            				// Support: IE 9 only
                            				// Use onreadystatechange to replace onabort
                            				// to handle uncaught aborts
                            				if ( xhr.onabort !== undefined ) {
                            					xhr.onabort = errorCallback;
                            				} else {
                            					xhr.onreadystatechange = function() {
                            
                            						// Check readyState before timeout as it changes
                            						if ( xhr.readyState === 4 ) {
                            
                            							// Allow onerror to be called first,
                            							// but that will not handle a native abort
                            							// Also, save errorCallback to a variable
                            							// as xhr.onerror cannot be accessed
                            							window.setTimeout( function() {
                            								if ( callback ) {
                            									errorCallback();
                            								}
                            							} );
                            						}
                            					};
                            				}
                            
                            				// Create the abort callback
                            				callback = callback( &quot;abort&quot; );
                            
                            				try {
                            
                            					// Do send the request (this may raise an exception)
                            					xhr.send( options.hasContent &amp;&amp; options.data || null );
                            				} catch ( e ) {
                            
                            					// #14683: Only rethrow if this hasn&#x27;t been notified as an error yet
                            					if ( callback ) {
                            						throw e;
                            					}
                            				}
                            			},
                            
                            			abort: function() {
                            				if ( callback ) {
                            					callback();
                            				}
                            			}
                            		};
                            	}
                            } );
                            
                            
                            
                            
                            // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
                            jQuery.ajaxPrefilter( function( s ) {
                            	if ( s.crossDomain ) {
                            		s.contents.script = false;
                            	}
                            } );
                            
                            // Install script dataType
                            jQuery.ajaxSetup( {
                            	accepts: {
                            		script: &quot;text/javascript, application/javascript, &quot; +
                            			&quot;application/ecmascript, application/x-ecmascript&quot;
                            	},
                            	contents: {
                            		script: /\b(?:java|ecma)script\b/
                            	},
                            	converters: {
                            		&quot;text script&quot;: function( text ) {
                            			jQuery.globalEval( text );
                            			return text;
                            		}
                            	}
                            } );
                            
                            // Handle cache&#x27;s special case and crossDomain
                            jQuery.ajaxPrefilter( &quot;script&quot;, function( s ) {
                            	if ( s.cache === undefined ) {
                            		s.cache = false;
                            	}
                            	if ( s.crossDomain ) {
                            		s.type = &quot;GET&quot;;
                            	}
                            } );
                            
                            // Bind script tag hack transport
                            jQuery.ajaxTransport( &quot;script&quot;, function( s ) {
                            
                            	// This transport only deals with cross domain requests
                            	if ( s.crossDomain ) {
                            		var script, callback;
                            		return {
                            			send: function( _, complete ) {
                            				script = jQuery( &quot;&lt;script&gt;&quot; ).prop( {
                            					charset: s.scriptCharset,
                            					src: s.url
                            				} ).on(
                            					&quot;load error&quot;,
                            					callback = function( evt ) {
                            						script.remove();
                            						callback = null;
                            						if ( evt ) {
                            							complete( evt.type === &quot;error&quot; ? 404 : 200, evt.type );
                            						}
                            					}
                            				);
                            
                            				// Use native DOM manipulation to avoid our domManip AJAX trickery
                            				document.head.appendChild( script[ 0 ] );
                            			},
                            			abort: function() {
                            				if ( callback ) {
                            					callback();
                            				}
                            			}
                            		};
                            	}
                            } );
                            
                            
                            
                            
                            var oldCallbacks = [],
                            	rjsonp = /(=)\?(?=&amp;|$)|\?\?/;
                            
                            // Default jsonp settings
                            jQuery.ajaxSetup( {
                            	jsonp: &quot;callback&quot;,
                            	jsonpCallback: function() {
                            		var callback = oldCallbacks.pop() || ( jQuery.expando + &quot;_&quot; + ( nonce++ ) );
                            		this[ callback ] = true;
                            		return callback;
                            	}
                            } );
                            
                            // Detect, normalize options and install callbacks for jsonp requests
                            jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) {
                            
                            	var callbackName, overwritten, responseContainer,
                            		jsonProp = s.jsonp !== false &amp;&amp; ( rjsonp.test( s.url ) ?
                            			&quot;url&quot; :
                            			typeof s.data === &quot;string&quot; &amp;&amp;
                            				( s.contentType || &quot;&quot; )
                            					.indexOf( &quot;application/x-www-form-urlencoded&quot; ) === 0 &amp;&amp;
                            				rjsonp.test( s.data ) &amp;&amp; &quot;data&quot;
                            		);
                            
                            	// Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set
                            	if ( jsonProp || s.dataTypes[ 0 ] === &quot;jsonp&quot; ) {
                            
                            		// Get callback name, remembering preexisting value associated with it
                            		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
                            			s.jsonpCallback() :
                            			s.jsonpCallback;
                            
                            		// Insert callback into url or form data
                            		if ( jsonProp ) {
                            			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, &quot;$1&quot; + callbackName );
                            		} else if ( s.jsonp !== false ) {
                            			s.url += ( rquery.test( s.url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.jsonp + &quot;=&quot; + callbackName;
                            		}
                            
                            		// Use data converter to retrieve json after script execution
                            		s.converters[ &quot;script json&quot; ] = function() {
                            			if ( !responseContainer ) {
                            				jQuery.error( callbackName + &quot; was not called&quot; );
                            			}
                            			return responseContainer[ 0 ];
                            		};
                            
                            		// Force json dataType
                            		s.dataTypes[ 0 ] = &quot;json&quot;;
                            
                            		// Install callback
                            		overwritten = window[ callbackName ];
                            		window[ callbackName ] = function() {
                            			responseContainer = arguments;
                            		};
                            
                            		// Clean-up function (fires after converters)
                            		jqXHR.always( function() {
                            
                            			// If previous value didn&#x27;t exist - remove it
                            			if ( overwritten === undefined ) {
                            				jQuery( window ).removeProp( callbackName );
                            
                            			// Otherwise restore preexisting value
                            			} else {
                            				window[ callbackName ] = overwritten;
                            			}
                            
                            			// Save back as free
                            			if ( s[ callbackName ] ) {
                            
                            				// Make sure that re-using the options doesn&#x27;t screw things around
                            				s.jsonpCallback = originalSettings.jsonpCallback;
                            
                            				// Save the callback name for future use
                            				oldCallbacks.push( callbackName );
                            			}
                            
                            			// Call if it was a function and we have a response
                            			if ( responseContainer &amp;&amp; jQuery.isFunction( overwritten ) ) {
                            				overwritten( responseContainer[ 0 ] );
                            			}
                            
                            			responseContainer = overwritten = undefined;
                            		} );
                            
                            		// Delegate to script
                            		return &quot;script&quot;;
                            	}
                            } );
                            
                            
                            
                            
                            // Support: Safari 8 only
                            // In Safari 8 documents created via document.implementation.createHTMLDocument
                            // collapse sibling forms: the second one becomes a child of the first one.
                            // Because of that, this security measure has to be disabled in Safari 8.
                            // https://bugs.webkit.org/show_bug.cgi?id=137337
                            support.createHTMLDocument = ( function() {
                            	var body = document.implementation.createHTMLDocument( &quot;&quot; ).body;
                            	body.innerHTML = &quot;&lt;form&gt;&lt;/form&gt;&lt;form&gt;&lt;/form&gt;&quot;;
                            	return body.childNodes.length === 2;
                            } )();
                            
                            
                            // Argument &quot;data&quot; should be string of html
                            // context (optional): If specified, the fragment will be created in this context,
                            // defaults to document
                            // keepScripts (optional): If true, will include scripts passed in the html string
                            jQuery.parseHTML = function( data, context, keepScripts ) {
                            	if ( typeof data !== &quot;string&quot; ) {
                            		return [];
                            	}
                            	if ( typeof context === &quot;boolean&quot; ) {
                            		keepScripts = context;
                            		context = false;
                            	}
                            
                            	var base, parsed, scripts;
                            
                            	if ( !context ) {
                            
                            		// Stop scripts or inline event handlers from being executed immediately
                            		// by using document.implementation
                            		if ( support.createHTMLDocument ) {
                            			context = document.implementation.createHTMLDocument( &quot;&quot; );
                            
                            			// Set the base href for the created document
                            			// so any parsed elements with URLs
                            			// are based on the document&#x27;s URL (gh-2965)
                            			base = context.createElement( &quot;base&quot; );
                            			base.href = document.location.href;
                            			context.head.appendChild( base );
                            		} else {
                            			context = document;
                            		}
                            	}
                            
                            	parsed = rsingleTag.exec( data );
                            	scripts = !keepScripts &amp;&amp; [];
                            
                            	// Single tag
                            	if ( parsed ) {
                            		return [ context.createElement( parsed[ 1 ] ) ];
                            	}
                            
                            	parsed = buildFragment( [ data ], context, scripts );
                            
                            	if ( scripts &amp;&amp; scripts.length ) {
                            		jQuery( scripts ).remove();
                            	}
                            
                            	return jQuery.merge( [], parsed.childNodes );
                            };
                            
                            
                            /**
                             * Load a url into a page
                             */
                            jQuery.fn.load = function( url, params, callback ) {
                            	var selector, type, response,
                            		self = this,
                            		off = url.indexOf( &quot; &quot; );
                            
                            	if ( off &gt; -1 ) {
                            		selector = stripAndCollapse( url.slice( off ) );
                            		url = url.slice( 0, off );
                            	}
                            
                            	// If it&#x27;s a function
                            	if ( jQuery.isFunction( params ) ) {
                            
                            		// We assume that it&#x27;s the callback
                            		callback = params;
                            		params = undefined;
                            
                            	// Otherwise, build a param string
                            	} else if ( params &amp;&amp; typeof params === &quot;object&quot; ) {
                            		type = &quot;POST&quot;;
                            	}
                            
                            	// If we have elements to modify, make the request
                            	if ( self.length &gt; 0 ) {
                            		jQuery.ajax( {
                            			url: url,
                            
                            			// If &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used.
                            			// Make value of this field explicit since
                            			// user can override it through ajaxSetup method
                            			type: type || &quot;GET&quot;,
                            			dataType: &quot;html&quot;,
                            			data: params
                            		} ).done( function( responseText ) {
                            
                            			// Save response for use in complete callback
                            			response = arguments;
                            
                            			self.html( selector ?
                            
                            				// If a selector was specified, locate the right elements in a dummy div
                            				// Exclude scripts to avoid IE &#x27;Permission Denied&#x27; errors
                            				jQuery( &quot;&lt;div&gt;&quot; ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
                            
                            				// Otherwise use the full result
                            				responseText );
                            
                            		// If the request succeeds, this function gets &quot;data&quot;, &quot;status&quot;, &quot;jqXHR&quot;
                            		// but they are ignored because response was set above.
                            		// If it fails, this function gets &quot;jqXHR&quot;, &quot;status&quot;, &quot;error&quot;
                            		} ).always( callback &amp;&amp; function( jqXHR, status ) {
                            			self.each( function() {
                            				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
                            			} );
                            		} );
                            	}
                            
                            	return this;
                            };
                            
                            
                            
                            
                            // Attach a bunch of functions for handling common AJAX events
                            jQuery.each( [
                            	&quot;ajaxStart&quot;,
                            	&quot;ajaxStop&quot;,
                            	&quot;ajaxComplete&quot;,
                            	&quot;ajaxError&quot;,
                            	&quot;ajaxSuccess&quot;,
                            	&quot;ajaxSend&quot;
                            ], function( i, type ) {
                            	jQuery.fn[ type ] = function( fn ) {
                            		return this.on( type, fn );
                            	};
                            } );
                            
                            
                            
                            
                            jQuery.expr.pseudos.animated = function( elem ) {
                            	return jQuery.grep( jQuery.timers, function( fn ) {
                            		return elem === fn.elem;
                            	} ).length;
                            };
                            
                            
                            
                            
                            jQuery.offset = {
                            	setOffset: function( elem, options, i ) {
                            		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                            			position = jQuery.css( elem, &quot;position&quot; ),
                            			curElem = jQuery( elem ),
                            			props = {};
                            
                            		// Set position first, in-case top/left are set even on static elem
                            		if ( position === &quot;static&quot; ) {
                            			elem.style.position = &quot;relative&quot;;
                            		}
                            
                            		curOffset = curElem.offset();
                            		curCSSTop = jQuery.css( elem, &quot;top&quot; );
                            		curCSSLeft = jQuery.css( elem, &quot;left&quot; );
                            		calculatePosition = ( position === &quot;absolute&quot; || position === &quot;fixed&quot; ) &amp;&amp;
                            			( curCSSTop + curCSSLeft ).indexOf( &quot;auto&quot; ) &gt; -1;
                            
                            		// Need to be able to calculate position if either
                            		// top or left is auto and position is either absolute or fixed
                            		if ( calculatePosition ) {
                            			curPosition = curElem.position();
                            			curTop = curPosition.top;
                            			curLeft = curPosition.left;
                            
                            		} else {
                            			curTop = parseFloat( curCSSTop ) || 0;
                            			curLeft = parseFloat( curCSSLeft ) || 0;
                            		}
                            
                            		if ( jQuery.isFunction( options ) ) {
                            
                            			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                            			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
                            		}
                            
                            		if ( options.top != null ) {
                            			props.top = ( options.top - curOffset.top ) + curTop;
                            		}
                            		if ( options.left != null ) {
                            			props.left = ( options.left - curOffset.left ) + curLeft;
                            		}
                            
                            		if ( &quot;using&quot; in options ) {
                            			options.using.call( elem, props );
                            
                            		} else {
                            			curElem.css( props );
                            		}
                            	}
                            };
                            
                            jQuery.fn.extend( {
                            	offset: function( options ) {
                            
                            		// Preserve chaining for setter
                            		if ( arguments.length ) {
                            			return options === undefined ?
                            				this :
                            				this.each( function( i ) {
                            					jQuery.offset.setOffset( this, options, i );
                            				} );
                            		}
                            
                            		var doc, docElem, rect, win,
                            			elem = this[ 0 ];
                            
                            		if ( !elem ) {
                            			return;
                            		}
                            
                            		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
                            		// Support: IE &lt;=11 only
                            		// Running getBoundingClientRect on a
                            		// disconnected node in IE throws an error
                            		if ( !elem.getClientRects().length ) {
                            			return { top: 0, left: 0 };
                            		}
                            
                            		rect = elem.getBoundingClientRect();
                            
                            		doc = elem.ownerDocument;
                            		docElem = doc.documentElement;
                            		win = doc.defaultView;
                            
                            		return {
                            			top: rect.top + win.pageYOffset - docElem.clientTop,
                            			left: rect.left + win.pageXOffset - docElem.clientLeft
                            		};
                            	},
                            
                            	position: function() {
                            		if ( !this[ 0 ] ) {
                            			return;
                            		}
                            
                            		var offsetParent, offset,
                            			elem = this[ 0 ],
                            			parentOffset = { top: 0, left: 0 };
                            
                            		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
                            		// because it is its only offset parent
                            		if ( jQuery.css( elem, &quot;position&quot; ) === &quot;fixed&quot; ) {
                            
                            			// Assume getBoundingClientRect is there when computed position is fixed
                            			offset = elem.getBoundingClientRect();
                            
                            		} else {
                            
                            			// Get *real* offsetParent
                            			offsetParent = this.offsetParent();
                            
                            			// Get correct offsets
                            			offset = this.offset();
                            			if ( !nodeName( offsetParent[ 0 ], &quot;html&quot; ) ) {
                            				parentOffset = offsetParent.offset();
                            			}
                            
                            			// Add offsetParent borders
                            			parentOffset = {
                            				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], &quot;borderTopWidth&quot;, true ),
                            				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], &quot;borderLeftWidth&quot;, true )
                            			};
                            		}
                            
                            		// Subtract parent offsets and element margins
                            		return {
                            			top: offset.top - parentOffset.top - jQuery.css( elem, &quot;marginTop&quot;, true ),
                            			left: offset.left - parentOffset.left - jQuery.css( elem, &quot;marginLeft&quot;, true )
                            		};
                            	},
                            
                            	// This method will return documentElement in the following cases:
                            	// 1) For the element inside the iframe without offsetParent, this method will return
                            	//    documentElement of the parent window
                            	// 2) For the hidden or detached element
                            	// 3) For body or html element, i.e. in case of the html node - it will return itself
                            	//
                            	// but those exceptions were never presented as a real life use-cases
                            	// and might be considered as more preferable results.
                            	//
                            	// This logic, however, is not guaranteed and can change at any point in the future
                            	offsetParent: function() {
                            		return this.map( function() {
                            			var offsetParent = this.offsetParent;
                            
                            			while ( offsetParent &amp;&amp; jQuery.css( offsetParent, &quot;position&quot; ) === &quot;static&quot; ) {
                            				offsetParent = offsetParent.offsetParent;
                            			}
                            
                            			return offsetParent || documentElement;
                            		} );
                            	}
                            } );
                            
                            // Create scrollLeft and scrollTop methods
                            jQuery.each( { scrollLeft: &quot;pageXOffset&quot;, scrollTop: &quot;pageYOffset&quot; }, function( method, prop ) {
                            	var top = &quot;pageYOffset&quot; === prop;
                            
                            	jQuery.fn[ method ] = function( val ) {
                            		return access( this, function( elem, method, val ) {
                            
                            			// Coalesce documents and windows
                            			var win;
                            			if ( jQuery.isWindow( elem ) ) {
                            				win = elem;
                            			} else if ( elem.nodeType === 9 ) {
                            				win = elem.defaultView;
                            			}
                            
                            			if ( val === undefined ) {
                            				return win ? win[ prop ] : elem[ method ];
                            			}
                            
                            			if ( win ) {
                            				win.scrollTo(
                            					!top ? val : win.pageXOffset,
                            					top ? val : win.pageYOffset
                            				);
                            
                            			} else {
                            				elem[ method ] = val;
                            			}
                            		}, method, val, arguments.length );
                            	};
                            } );
                            
                            // Support: Safari &lt;=7 - 9.1, Chrome &lt;=37 - 49
                            // Add the top/left cssHooks using jQuery.fn.position
                            // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
                            // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
                            // getComputedStyle returns percent when specified for top/left/bottom/right;
                            // rather than make the css module depend on the offset module, just check for it here
                            jQuery.each( [ &quot;top&quot;, &quot;left&quot; ], function( i, prop ) {
                            	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
                            		function( elem, computed ) {
                            			if ( computed ) {
                            				computed = curCSS( elem, prop );
                            
                            				// If curCSS returns percentage, fallback to offset
                            				return rnumnonpx.test( computed ) ?
                            					jQuery( elem ).position()[ prop ] + &quot;px&quot; :
                            					computed;
                            			}
                            		}
                            	);
                            } );
                            
                            
                            // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
                            jQuery.each( { Height: &quot;height&quot;, Width: &quot;width&quot; }, function( name, type ) {
                            	jQuery.each( { padding: &quot;inner&quot; + name, content: type, &quot;&quot;: &quot;outer&quot; + name },
                            		function( defaultExtra, funcName ) {
                            
                            		// Margin is only for outerHeight, outerWidth
                            		jQuery.fn[ funcName ] = function( margin, value ) {
                            			var chainable = arguments.length &amp;&amp; ( defaultExtra || typeof margin !== &quot;boolean&quot; ),
                            				extra = defaultExtra || ( margin === true || value === true ? &quot;margin&quot; : &quot;border&quot; );
                            
                            			return access( this, function( elem, type, value ) {
                            				var doc;
                            
                            				if ( jQuery.isWindow( elem ) ) {
                            
                            					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                            					return funcName.indexOf( &quot;outer&quot; ) === 0 ?
                            						elem[ &quot;inner&quot; + name ] :
                            						elem.document.documentElement[ &quot;client&quot; + name ];
                            				}
                            
                            				// Get document width or height
                            				if ( elem.nodeType === 9 ) {
                            					doc = elem.documentElement;
                            
                            					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                            					// whichever is greatest
                            					return Math.max(
                            						elem.body[ &quot;scroll&quot; + name ], doc[ &quot;scroll&quot; + name ],
                            						elem.body[ &quot;offset&quot; + name ], doc[ &quot;offset&quot; + name ],
                            						doc[ &quot;client&quot; + name ]
                            					);
                            				}
                            
                            				return value === undefined ?
                            
                            					// Get width or height on the element, requesting but not forcing parseFloat
                            					jQuery.css( elem, type, extra ) :
                            
                            					// Set width or height on the element
                            					jQuery.style( elem, type, value, extra );
                            			}, type, chainable ? margin : undefined, chainable );
                            		};
                            	} );
                            } );
                            
                            
                            jQuery.fn.extend( {
                            
                            	bind: function( types, data, fn ) {
                            		return this.on( types, null, data, fn );
                            	},
                            	unbind: function( types, fn ) {
                            		return this.off( types, null, fn );
                            	},
                            
                            	delegate: function( selector, types, data, fn ) {
                            		return this.on( types, selector, data, fn );
                            	},
                            	undelegate: function( selector, types, fn ) {
                            
                            		// ( namespace ) or ( selector, types [, fn] )
                            		return arguments.length === 1 ?
                            			this.off( selector, &quot;**&quot; ) :
                            			this.off( types, selector || &quot;**&quot;, fn );
                            	},
                            	holdReady: function( hold ) {
                            		if ( hold ) {
                            			jQuery.readyWait++;
                            		} else {
                            			jQuery.ready( true );
                            		}
                            	}
                            } );
                            
                            jQuery.isArray = Array.isArray;
                            jQuery.parseJSON = JSON.parse;
                            jQuery.nodeName = nodeName;
                            
                            
                            
                            
                            // Register as a named AMD module, since jQuery can be concatenated with other
                            // files that may use define, but not via a proper concatenation script that
                            // understands anonymous AMD modules. A named AMD is safest and most robust
                            // way to register. Lowercase jquery is used because AMD module names are
                            // derived from file names, and jQuery is normally delivered in a lowercase
                            // file name. Do this after creating the global so that if an AMD module wants
                            // to call noConflict to hide this version of jQuery, it will work.
                            
                            // Note that for maximum portability, libraries that are not jQuery should
                            // declare themselves as anonymous modules, and avoid setting a global if an
                            // AMD loader is present. jQuery is a special case. For more information, see
                            // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
                            
                            if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {
                            	define( &quot;jquery&quot;, [], function() {
                            		return jQuery;
                            	} );
                            }
                            
                            
                            
                            
                            var
                            
                            	// Map over jQuery in case of overwrite
                            	_jQuery = window.jQuery,
                            
                            	// Map over the $ in case of overwrite
                            	_$ = window.$;
                            
                            jQuery.noConflict = function( deep ) {
                            	if ( window.$ === jQuery ) {
                            		window.$ = _$;
                            	}
                            
                            	if ( deep &amp;&amp; window.jQuery === jQuery ) {
                            		window.jQuery = _jQuery;
                            	}
                            
                            	return jQuery;
                            };
                            
                            // Expose jQuery and $ identifiers, even in AMD
                            // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
                            // and CommonJS for browser emulators (#13566)
                            if ( !noGlobal ) {
                            	window.jQuery = window.$ = jQuery;
                            }
                            
                            
                            
                            
                            return jQuery;
                            } );
                            
                                </pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
    <script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
    <script src="../assets/vendor/prettify/prettify-min.js"></script>
    <script src="../assets/js/yuidoc-bootstrap.js"></script>
    <script>prettyPrint();</script>
</body>
</html>